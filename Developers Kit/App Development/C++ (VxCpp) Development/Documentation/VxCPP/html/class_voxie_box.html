<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VX++ Framework (VxCpp.dll): VoxieBox Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="vx++ logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VX++ Framework (VxCpp.dll)
   </div>
   <div id="projectbrief">Friendly Voxon development with classes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_voxie_box-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VoxieBox Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class.  
 <a href="class_voxie_box.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for VoxieBox:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_voxie_box.png" usemap="#VoxieBox_map" alt=""/>
  <map id="VoxieBox_map" name="VoxieBox_map">
<area href="class_i_voxie_box.html" title="Interface for VoxieBox class." alt="IVoxieBox" shape="rect" coords="0,0,68,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06195dca9603ea448f72d502808384b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a06195dca9603ea448f72d502808384b2">VoxieBox</a> ()</td></tr>
<tr class="memdesc:a06195dca9603ea448f72d502808384b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> constructor checks to see if another instance of <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> has been created.  <a href="class_voxie_box.html#a06195dca9603ea448f72d502808384b2">More...</a><br /></td></tr>
<tr class="separator:a06195dca9603ea448f72d502808384b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa529cf6b6239cb92f00527ae2eb225"><td class="memItemLeft" align="right" valign="top"><a id="a6fa529cf6b6239cb92f00527ae2eb225"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6fa529cf6b6239cb92f00527ae2eb225">~VoxieBox</a> ()</td></tr>
<tr class="memdesc:a6fa529cf6b6239cb92f00527ae2eb225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor for <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> calls <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:shutdown to stop hardware and release voxiebox.dll. <br /></td></tr>
<tr class="separator:a6fa529cf6b6239cb92f00527ae2eb225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd2ee2048f4b560910621c693709270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270">breath</a> ()</td></tr>
<tr class="memdesc:a0cd2ee2048f4b560910621c693709270"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'update loop' for a VX application also updates <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> struct.  <a href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270">More...</a><br /></td></tr>
<tr class="separator:a0cd2ee2048f4b560910621c693709270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fc4d29059d67c2df643073bd02b3c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af0fc4d29059d67c2df643073bd02b3c9">breath</a> (<a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> *input)</td></tr>
<tr class="memdesc:af0fc4d29059d67c2df643073bd02b3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A breath is a complete volume sweep.  <a href="class_voxie_box.html#af0fc4d29059d67c2df643073bd02b3c9">More...</a><br /></td></tr>
<tr class="separator:af0fc4d29059d67c2df643073bd02b3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b4793427d2d728cea01e1daa8893f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3">startFrame</a> ()</td></tr>
<tr class="memdesc:a54b4793427d2d728cea01e1daa8893f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">start building the frame buffer.  <a href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3">More...</a><br /></td></tr>
<tr class="separator:a54b4793427d2d728cea01e1daa8893f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d9b0954c410adf2323473e0ececcd2"><td class="memItemLeft" align="right" valign="top"><a id="a72d9b0954c410adf2323473e0ececcd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2">endFrame</a> ()</td></tr>
<tr class="memdesc:a72d9b0954c410adf2323473e0ececcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to signify the end of a volumetric frame. <br /></td></tr>
<tr class="separator:a72d9b0954c410adf2323473e0ececcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017f92d410603f30a1c1d1e27530cc67"><td class="memItemLeft" align="right" valign="top"><a id="a017f92d410603f30a1c1d1e27530cc67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a017f92d410603f30a1c1d1e27530cc67">endBreath</a> ()</td></tr>
<tr class="memdesc:a017f92d410603f30a1c1d1e27530cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop()</a> just with an alternative name - exits out the <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> loop. <br /></td></tr>
<tr class="separator:a017f92d410603f30a1c1d1e27530cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9f69b448fecf7ef2c9e2413d5feb8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c">quitLoop</a> ()</td></tr>
<tr class="memdesc:a6e9f69b448fecf7ef2c9e2413d5feb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to tell Voxiebox library you want to exit the <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> loop and quit the application.  <a href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c">More...</a><br /></td></tr>
<tr class="separator:a6e9f69b448fecf7ef2c9e2413d5feb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef23a011c4c37855471d336f02bc83a0"><td class="memItemLeft" align="right" valign="top"><a id="aef23a011c4c37855471d336f02bc83a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aef23a011c4c37855471d336f02bc83a0">shutdown</a> ()</td></tr>
<tr class="memdesc:aef23a011c4c37855471d336f02bc83a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees the voxiebox.DLL from memory and allows the file to be accessed by other processes <br /></td></tr>
<tr class="separator:aef23a011c4c37855471d336f02bc83a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df7e95b7c877b5942690affef94d4a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9df7e95b7c877b5942690affef94d4a6">init</a> ()</td></tr>
<tr class="memdesc:a9df7e95b7c877b5942690affef94d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalises and updates voxiebox.dll's voxie window (<a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>)  <a href="class_voxie_box.html#a9df7e95b7c877b5942690affef94d4a6">More...</a><br /></td></tr>
<tr class="separator:a9df7e95b7c877b5942690affef94d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd8983f63c8f659a5096a4f010b3f9"><td class="memItemLeft" align="right" valign="top"><a id="afdbd8983f63c8f659a5096a4f010b3f9"></a>
<a class="el" href="structvoxie__wind__t.html">voxie_wind_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#afdbd8983f63c8f659a5096a4f010b3f9">getVoxieWindow</a> ()</td></tr>
<tr class="memdesc:afdbd8983f63c8f659a5096a4f010b3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct <br /></td></tr>
<tr class="separator:afdbd8983f63c8f659a5096a4f010b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d87f07f268b16dc0cb95baa058796"><td class="memItemLeft" align="right" valign="top"><a id="a347d87f07f268b16dc0cb95baa058796"></a>
<a class="el" href="structvoxie__frame__t.html">voxie_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a347d87f07f268b16dc0cb95baa058796">getVoxieFrame</a> ()</td></tr>
<tr class="memdesc:a347d87f07f268b16dc0cb95baa058796"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the internal <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> struct <br /></td></tr>
<tr class="separator:a347d87f07f268b16dc0cb95baa058796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb378549c1bf96b3b3594425f4a1bfa"><td class="memItemLeft" align="right" valign="top"><a id="adfb378549c1bf96b3b3594425f4a1bfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#adfb378549c1bf96b3b3594425f4a1bfa">setBorder</a> (bool option)</td></tr>
<tr class="memdesc:adfb378549c1bf96b3b3594425f4a1bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">toggles a white border around the perimeter of the volumetric display. <br /></td></tr>
<tr class="separator:adfb378549c1bf96b3b3594425f4a1bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1a876f01b852e56fd8f2406f1e3168"><td class="memItemLeft" align="right" valign="top"><a id="a9d1a876f01b852e56fd8f2406f1e3168"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9d1a876f01b852e56fd8f2406f1e3168">setEnableExitOnEsc</a> (bool option)</td></tr>
<tr class="memdesc:a9d1a876f01b852e56fd8f2406f1e3168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles the use of the 'esc' key to escape a Voxon program (by calling <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop()</a>) <br /></td></tr>
<tr class="separator:a9d1a876f01b852e56fd8f2406f1e3168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18586f945ef596c0bd95b59f110aa6b1"><td class="memItemLeft" align="right" valign="top"><a id="a18586f945ef596c0bd95b59f110aa6b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a18586f945ef596c0bd95b59f110aa6b1">setEnableNavClipping</a> (bool option)</td></tr>
<tr class="memdesc:a18586f945ef596c0bd95b59f110aa6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles nav clipping (cursor / position is always inside the volume) when using the <a class="el" href="class_voxie_box.html#ad9440acc297003385583917cf2b60b8c" title="Return a point3d of the Nav&#39;s tracked position. Used primarly when the Space Nav is being used as a c...">VoxieBox::getNavPosition</a> or the <a class="el" href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839" title="draws a cursor unto the volumetric display at the position specified.">VoxieBox::drawCursor()</a> functions. Set to false by default. <br /></td></tr>
<tr class="separator:a18586f945ef596c0bd95b59f110aa6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9abb2d74f139a7bd104f93f184aad07"><td class="memItemLeft" align="right" valign="top"><a id="ab9abb2d74f139a7bd104f93f184aad07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab9abb2d74f139a7bd104f93f184aad07">setEnableMouseClipping</a> (bool option)</td></tr>
<tr class="memdesc:ab9abb2d74f139a7bd104f93f184aad07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true if you want the mouse to clip (cursor is always inside the volume) when using the <a class="el" href="class_voxie_box.html#ac567600c40003e62fbcf9ffe1aaf938b">VoxieBox::getMousePosition</a> or the <a class="el" href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839" title="draws a cursor unto the volumetric display at the position specified.">VoxieBox::drawCursor()</a> functions. <br /></td></tr>
<tr class="separator:ab9abb2d74f139a7bd104f93f184aad07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215f2f29a7d77011930fc0f05f426a13"><td class="memItemLeft" align="right" valign="top"><a id="a215f2f29a7d77011930fc0f05f426a13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a215f2f29a7d77011930fc0f05f426a13">setCleanExitOnQuitLoop</a> (bool option)</td></tr>
<tr class="memdesc:a215f2f29a7d77011930fc0f05f426a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">when enabled and <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop</a> is called the Voxiebox library is freed from memory <br /></td></tr>
<tr class="separator:a215f2f29a7d77011930fc0f05f426a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48963e610a6a5d5aa6e3fc06506f7272"><td class="memItemLeft" align="right" valign="top"><a id="a48963e610a6a5d5aa6e3fc06506f7272"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272">setEnableLegacyKeyInput</a> (bool option)</td></tr>
<tr class="memdesc:a48963e610a6a5d5aa6e3fc06506f7272"><td class="mdescLeft">&#160;</td><td class="mdescRight">toggles when enabled and <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop()</a> is called the Voxiebox libary is freed from memory. Set to true by default. <br /></td></tr>
<tr class="separator:a48963e610a6a5d5aa6e3fc06506f7272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedb5dc6e4d9d0109b5ae999d933457d"><td class="memItemLeft" align="right" valign="top"><a id="adedb5dc6e4d9d0109b5ae999d933457d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d">setEnableLegacyJoyInput</a> (bool option)</td></tr>
<tr class="memdesc:adedb5dc6e4d9d0109b5ae999d933457d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to handle Joy input manually. Disables many of the joy input functions. Set to false by default. <br /></td></tr>
<tr class="separator:adedb5dc6e4d9d0109b5ae999d933457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742aca3dfb890fb71c34bc0910f9483a"><td class="memItemLeft" align="right" valign="top"><a id="a742aca3dfb890fb71c34bc0910f9483a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a742aca3dfb890fb71c34bc0910f9483a">setEnableLegacyNavInput</a> (bool option)</td></tr>
<tr class="memdesc:a742aca3dfb890fb71c34bc0910f9483a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to handle Nav input manually. Disables many of the nav input functions. Set to false by default. <br /></td></tr>
<tr class="separator:a742aca3dfb890fb71c34bc0910f9483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f574314efcd1d8905809a125837cb"><td class="memItemLeft" align="right" valign="top"><a id="a223f574314efcd1d8905809a125837cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a223f574314efcd1d8905809a125837cb">setInvertZAxis</a> (bool option)</td></tr>
<tr class="memdesc:a223f574314efcd1d8905809a125837cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the Z axis. (by default - values are at the top of the screen and + values are below). Set to false by default. <br /></td></tr>
<tr class="separator:a223f574314efcd1d8905809a125837cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735ca240cef59150b3af3cad9025c02c"><td class="memItemLeft" align="right" valign="top"><a id="a735ca240cef59150b3af3cad9025c02c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a735ca240cef59150b3af3cad9025c02c">setEnableJoyDeadZone</a> (bool option)</td></tr>
<tr class="memdesc:a735ca240cef59150b3af3cad9025c02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles a joystick / gamepad dead zone on analog sticks. Set to true by default. <br /></td></tr>
<tr class="separator:a735ca240cef59150b3af3cad9025c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bb7671c5f5d2627e33e5f36c161e8d"><td class="memItemLeft" align="right" valign="top"><a id="a21bb7671c5f5d2627e33e5f36c161e8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a21bb7671c5f5d2627e33e5f36c161e8d">setEnableNavDeadZone</a> (bool option)</td></tr>
<tr class="memdesc:a21bb7671c5f5d2627e33e5f36c161e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles a dead zone for Space Navigator. Set to true by default. <br /></td></tr>
<tr class="separator:a21bb7671c5f5d2627e33e5f36c161e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ddc2acb04f13451519bdeff12c0587"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a53ddc2acb04f13451519bdeff12c0587">getDeltaTime</a> ()</td></tr>
<tr class="memdesc:a53ddc2acb04f13451519bdeff12c0587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns delta time (the time between volume updates) delta time is CPU speed dependent and can be used to make ensure timing is consistent between various computers / systems.  <a href="class_voxie_box.html#a53ddc2acb04f13451519bdeff12c0587">More...</a><br /></td></tr>
<tr class="separator:a53ddc2acb04f13451519bdeff12c0587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879b47da9d4fab087667a192cdb2504d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a879b47da9d4fab087667a192cdb2504d">getTime</a> ()</td></tr>
<tr class="memdesc:a879b47da9d4fab087667a192cdb2504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the running time (in seconds) from program execution till present.  <a href="class_voxie_box.html#a879b47da9d4fab087667a192cdb2504d">More...</a><br /></td></tr>
<tr class="separator:a879b47da9d4fab087667a192cdb2504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac60796c8cd10a98a2a23cb67107fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a33ac60796c8cd10a98a2a23cb67107fb">getVPS</a> ()</td></tr>
<tr class="memdesc:a33ac60796c8cd10a98a2a23cb67107fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the system's current VPS (volumes per second).  <a href="class_voxie_box.html#a33ac60796c8cd10a98a2a23cb67107fb">More...</a><br /></td></tr>
<tr class="separator:a33ac60796c8cd10a98a2a23cb67107fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c809c48ef2ead9cf98148df29a5636"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af0c809c48ef2ead9cf98148df29a5636">getAspectX</a> ()</td></tr>
<tr class="memdesc:af0c809c48ef2ead9cf98148df29a5636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect X ratio.  <a href="class_voxie_box.html#af0c809c48ef2ead9cf98148df29a5636">More...</a><br /></td></tr>
<tr class="separator:af0c809c48ef2ead9cf98148df29a5636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19f887b7e39ca3b4a152f8eeaa78d1b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad19f887b7e39ca3b4a152f8eeaa78d1b">getAspectY</a> ()</td></tr>
<tr class="memdesc:ad19f887b7e39ca3b4a152f8eeaa78d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Y ratio.  <a href="class_voxie_box.html#ad19f887b7e39ca3b4a152f8eeaa78d1b">More...</a><br /></td></tr>
<tr class="separator:ad19f887b7e39ca3b4a152f8eeaa78d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e33d171c5df12850c8d011eb5cdc442"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6e33d171c5df12850c8d011eb5cdc442">getAspectZ</a> ()</td></tr>
<tr class="memdesc:a6e33d171c5df12850c8d011eb5cdc442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Z ratio.  <a href="class_voxie_box.html#a6e33d171c5df12850c8d011eb5cdc442">More...</a><br /></td></tr>
<tr class="separator:a6e33d171c5df12850c8d011eb5cdc442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566a66c84473d36479a2a635adf512b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a566a66c84473d36479a2a635adf512b0">getAspect</a> ()</td></tr>
<tr class="memdesc:a566a66c84473d36479a2a635adf512b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> (x,y,z)  <a href="class_voxie_box.html#a566a66c84473d36479a2a635adf512b0">More...</a><br /></td></tr>
<tr class="separator:a566a66c84473d36479a2a635adf512b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf47390b8cd637ea529ee3703760207b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aaf47390b8cd637ea529ee3703760207b">setAspectX</a> (float newAspectX)</td></tr>
<tr class="memdesc:aaf47390b8cd637ea529ee3703760207b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s X aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>.  <a href="class_voxie_box.html#aaf47390b8cd637ea529ee3703760207b">More...</a><br /></td></tr>
<tr class="separator:aaf47390b8cd637ea529ee3703760207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4dd3e7e0e36fe288f37982e0523c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a2c4dd3e7e0e36fe288f37982e0523c1b">setAspectY</a> (float newAspectY)</td></tr>
<tr class="memdesc:a2c4dd3e7e0e36fe288f37982e0523c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s Y aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>.  <a href="class_voxie_box.html#a2c4dd3e7e0e36fe288f37982e0523c1b">More...</a><br /></td></tr>
<tr class="separator:a2c4dd3e7e0e36fe288f37982e0523c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0beb44d99ce82e52c19033641e3ee53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af0beb44d99ce82e52c19033641e3ee53">setAspectZ</a> (float newAspectZ)</td></tr>
<tr class="memdesc:af0beb44d99ce82e52c19033641e3ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s Z aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>.  <a href="class_voxie_box.html#af0beb44d99ce82e52c19033641e3ee53">More...</a><br /></td></tr>
<tr class="separator:af0beb44d99ce82e52c19033641e3ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6130d995104d6656a06161870e8ea725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6130d995104d6656a06161870e8ea725">setAspect</a> (<a class="el" href="structpoint3d.html">point3d</a> newAspect)</td></tr>
<tr class="memdesc:a6130d995104d6656a06161870e8ea725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>.  <a href="class_voxie_box.html#a6130d995104d6656a06161870e8ea725">More...</a><br /></td></tr>
<tr class="separator:a6130d995104d6656a06161870e8ea725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156a872314f4278160e4cac3c13d7b6b"><td class="memItemLeft" align="right" valign="top"><a id="a156a872314f4278160e4cac3c13d7b6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a156a872314f4278160e4cac3c13d7b6b">setDisplay2D</a> ()</td></tr>
<tr class="memdesc:a156a872314f4278160e4cac3c13d7b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off the reciprocating screen and effectively makes the display a '2D' screen. (Works on Voxon hardware only) <br /></td></tr>
<tr class="separator:a156a872314f4278160e4cac3c13d7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3413d107e7cd4534ff4aa07cb938495"><td class="memItemLeft" align="right" valign="top"><a id="ad3413d107e7cd4534ff4aa07cb938495"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad3413d107e7cd4534ff4aa07cb938495">setDisplay3D</a> ()</td></tr>
<tr class="memdesc:ad3413d107e7cd4534ff4aa07cb938495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on the reciprocating screen / activates the volumetric display. (Works on Voxon hardware only) <br /></td></tr>
<tr class="separator:ad3413d107e7cd4534ff4aa07cb938495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04a95bae0c856c9d1b22f1902673304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304">setView</a> (float xMin, float yMin, float zMin, float xMax, float yMax, float zMax)</td></tr>
<tr class="memdesc:ab04a95bae0c856c9d1b22f1902673304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom view.  <a href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304">More...</a><br /></td></tr>
<tr class="separator:ab04a95bae0c856c9d1b22f1902673304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a65f94d8985cbfc3f1520f5660c2fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae4a65f94d8985cbfc3f1520f5660c2fc">setView</a> (<a class="el" href="structpoint3d.html">point3d</a> LUT, <a class="el" href="structpoint3d.html">point3d</a> RDB)</td></tr>
<tr class="memdesc:ae4a65f94d8985cbfc3f1520f5660c2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same <a class="el" href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304" title="Set a custom view.">setView()</a> but using point3D for coordinates instead of 6 floats.  <a href="class_voxie_box.html#ae4a65f94d8985cbfc3f1520f5660c2fc">More...</a><br /></td></tr>
<tr class="separator:ae4a65f94d8985cbfc3f1520f5660c2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c75929ecde4250e3cdec02a4c94be76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a4c75929ecde4250e3cdec02a4c94be76">setMaskPlane</a> (float x0, float y0, float z0, float nx, float ny, float nz)</td></tr>
<tr class="memdesc:a4c75929ecde4250e3cdec02a4c94be76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call after each <a class="el" href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304" title="Set a custom view.">VoxieBox::setView()</a> to mask off a plane of a specified thickness.  <a href="class_voxie_box.html#a4c75929ecde4250e3cdec02a4c94be76">More...</a><br /></td></tr>
<tr class="separator:a4c75929ecde4250e3cdec02a4c94be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71d54273bfe9ded3d64aa44dd03af27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af71d54273bfe9ded3d64aa44dd03af27">setGlobalShader</a> (float horizontalAngle, float verticalAngle, float amplitude)</td></tr>
<tr class="memdesc:af71d54273bfe9ded3d64aa44dd03af27"><td class="mdescLeft">&#160;</td><td class="mdescRight">changes the global normal vector (vw.normhax) for shading.  <a href="class_voxie_box.html#af71d54273bfe9ded3d64aa44dd03af27">More...</a><br /></td></tr>
<tr class="separator:af71d54273bfe9ded3d64aa44dd03af27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadbb02dbc625dd7aa4f75eb67e32d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aaadbb02dbc625dd7aa4f75eb67e32d89">flushGfx</a> ()</td></tr>
<tr class="memdesc:aaadbb02dbc625dd7aa4f75eb67e32d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all graphics commands on internal buffer, causing all graphics commands to actually execute and complete.  <a href="class_voxie_box.html#aaadbb02dbc625dd7aa4f75eb67e32d89">More...</a><br /></td></tr>
<tr class="separator:aaadbb02dbc625dd7aa4f75eb67e32d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ea2cd5b99c01acb154c15f3ec3b884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a54ea2cd5b99c01acb154c15f3ec3b884">freeGfx</a> (char *fileName)</td></tr>
<tr class="memdesc:a54ea2cd5b99c01acb154c15f3ec3b884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a filename from VoxieBox.dll internal cache (any filename passed to voxie_drawmeshtex() / drawMesh, voxie_drawheimap() / drawHeightMap, voxie_drawspr() / drawModel)  <a href="class_voxie_box.html#a54ea2cd5b99c01acb154c15f3ec3b884">More...</a><br /></td></tr>
<tr class="separator:a54ea2cd5b99c01acb154c15f3ec3b884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f84d5dea8b5861ee9f31101b7374c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab9f84d5dea8b5861ee9f31101b7374c1">setProject</a> (int dispNum, int dir, float x, float y, int z, float *xo, float *yo)</td></tr>
<tr class="memdesc:ab9f84d5dea8b5861ee9f31101b7374c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced utility function for keystone calibration (used by graphcalc and keystone calibration in voxiedemo) see the source code for voxiedemo.c for an understanding of how this works.  <a href="class_voxie_box.html#ab9f84d5dea8b5861ee9f31101b7374c1">More...</a><br /></td></tr>
<tr class="separator:ab9f84d5dea8b5861ee9f31101b7374c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae999930f0ca537140166cbcfcbd301f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae999930f0ca537140166cbcfcbd301f4">setLeds</a> (int dispNum, int r, int g, int b)</td></tr>
<tr class="memdesc:ae999930f0ca537140166cbcfcbd301f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LEDs values on projector hardware.  <a href="class_voxie_box.html#ae999930f0ca537140166cbcfcbd301f4">More...</a><br /></td></tr>
<tr class="separator:ae999930f0ca537140166cbcfcbd301f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b420729da134fccd160090c2a5701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a4f4b420729da134fccd160090c2a5701">reportVoxieWind</a> (int posX, int posY)</td></tr>
<tr class="memdesc:a4f4b420729da134fccd160090c2a5701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes all the variables from the internal (vw) <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> onto the secondary (touch) screen.  <a href="class_voxie_box.html#a4f4b420729da134fccd160090c2a5701">More...</a><br /></td></tr>
<tr class="separator:a4f4b420729da134fccd160090c2a5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800ccbc5c2a20314f55b29d38030e13f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a800ccbc5c2a20314f55b29d38030e13f">reportVoxieFrame</a> (int posX, int posY)</td></tr>
<tr class="memdesc:a800ccbc5c2a20314f55b29d38030e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes some of the variables from the internal <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> onto the secondary (touch) screen.  <a href="class_voxie_box.html#a800ccbc5c2a20314f55b29d38030e13f">More...</a><br /></td></tr>
<tr class="separator:a800ccbc5c2a20314f55b29d38030e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053ccdfa875f9de492ac8dc0ce006bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a053ccdfa875f9de492ac8dc0ce006bb5">reportVoxieWind</a> (int posX, int posY, <a class="el" href="structvoxie__wind__t.html">voxie_wind_t</a> *VW)</td></tr>
<tr class="memdesc:a053ccdfa875f9de492ac8dc0ce006bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes all the variables of a <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct onto the secondary (touch) screen.  <a href="class_voxie_box.html#a053ccdfa875f9de492ac8dc0ce006bb5">More...</a><br /></td></tr>
<tr class="separator:a053ccdfa875f9de492ac8dc0ce006bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca032139f49b25ea1387100013493fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aca032139f49b25ea1387100013493fb0">reportVoxieFrame</a> (int posX, int posY, <a class="el" href="structvoxie__frame__t.html">voxie_frame_t</a> *VF)</td></tr>
<tr class="memdesc:aca032139f49b25ea1387100013493fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes some of the variables a <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> struct onto the secondary (touch) screen.  <a href="class_voxie_box.html#aca032139f49b25ea1387100013493fb0">More...</a><br /></td></tr>
<tr class="separator:aca032139f49b25ea1387100013493fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfb9b33cbc83e033b8db9f73e763c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6dfb9b33cbc83e033b8db9f73e763c1c">debugText</a> (int x, int y, int fcol, int bcol, const char *fmt,...)</td></tr>
<tr class="memdesc:a6dfb9b33cbc83e033b8db9f73e763c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">display text and/or variables unto to secondary (touch) screen. Supports in printf() format specifiers. -1 for transparent color  <a href="class_voxie_box.html#a6dfb9b33cbc83e033b8db9f73e763c1c">More...</a><br /></td></tr>
<tr class="separator:a6dfb9b33cbc83e033b8db9f73e763c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad21357a77e4e93ce528eed7d42d865"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a1ad21357a77e4e93ce528eed7d42d865">debugBar</a> (int posX, int posY, double currentVal, double maxVal, double minVal, char *text, int type)</td></tr>
<tr class="memdesc:a1ad21357a77e4e93ce528eed7d42d865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertical bar for help tracking variables onto the secondary (touch) screen.  <a href="class_voxie_box.html#a1ad21357a77e4e93ce528eed7d42d865">More...</a><br /></td></tr>
<tr class="separator:a1ad21357a77e4e93ce528eed7d42d865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472d7b26a2a8ae7b80a50d378ee79d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a472d7b26a2a8ae7b80a50d378ee79d9e">showVPS</a> (int posX, int posY)</td></tr>
<tr class="memdesc:a472d7b26a2a8ae7b80a50d378ee79d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays volumes per second (volumetric equivalent of 'FPS') and version info on the secondary (touch) screen.  <a href="class_voxie_box.html#a472d7b26a2a8ae7b80a50d378ee79d9e">More...</a><br /></td></tr>
<tr class="separator:a472d7b26a2a8ae7b80a50d378ee79d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53324f4cc479337b7d6ff456655284c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a53324f4cc479337b7d6ff456655284c2">debugDrawPix</a> (int x, int y, int col)</td></tr>
<tr class="memdesc:a53324f4cc479337b7d6ff456655284c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws single pixel on the secondary (touch) screen.  <a href="class_voxie_box.html#a53324f4cc479337b7d6ff456655284c2">More...</a><br /></td></tr>
<tr class="separator:a53324f4cc479337b7d6ff456655284c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65918047afd0334740143fdd17f376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#acc65918047afd0334740143fdd17f376">debugDrawHLine</a> (int xStartPos, int xEndPos, int y, int col)</td></tr>
<tr class="memdesc:acc65918047afd0334740143fdd17f376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws horizontal line on the secondary (touch) screen.  <a href="class_voxie_box.html#acc65918047afd0334740143fdd17f376">More...</a><br /></td></tr>
<tr class="separator:acc65918047afd0334740143fdd17f376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbf2b1c07262976e4ab3dc1dc09ac27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a5fbf2b1c07262976e4ab3dc1dc09ac27">debugDrawLine</a> (float xStartPos, float yStartPos, float xEndPos, float yEndPos, int col)</td></tr>
<tr class="memdesc:a5fbf2b1c07262976e4ab3dc1dc09ac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line on the secondary (touch) screen.  <a href="class_voxie_box.html#a5fbf2b1c07262976e4ab3dc1dc09ac27">More...</a><br /></td></tr>
<tr class="separator:a5fbf2b1c07262976e4ab3dc1dc09ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42835e3e2ca19a63a05d4c4a1f8c3e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a42835e3e2ca19a63a05d4c4a1f8c3e0a">debugDrawCircle</a> (int xCenterPos, int yCenterPos, int radius, int col)</td></tr>
<tr class="memdesc:a42835e3e2ca19a63a05d4c4a1f8c3e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw circle on the secondary (touch) screen.  <a href="class_voxie_box.html#a42835e3e2ca19a63a05d4c4a1f8c3e0a">More...</a><br /></td></tr>
<tr class="separator:a42835e3e2ca19a63a05d4c4a1f8c3e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4260b53e8e28020fcf22e7a00700ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad4260b53e8e28020fcf22e7a00700ab6">debugDrawBoxFill</a> (int xStartPos, int yStartPos, int xEndPos, int yEndPos, int col)</td></tr>
<tr class="memdesc:ad4260b53e8e28020fcf22e7a00700ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw filled rectangle on the secondary (touch) screen. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.  <a href="class_voxie_box.html#ad4260b53e8e28020fcf22e7a00700ab6">More...</a><br /></td></tr>
<tr class="separator:ad4260b53e8e28020fcf22e7a00700ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b2b2fe7c553bcb274b970f9d504dff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a65b2b2fe7c553bcb274b970f9d504dff">debugDrawCircFill</a> (int xCenterPos, int yCenterPos, int radius, int col)</td></tr>
<tr class="memdesc:a65b2b2fe7c553bcb274b970f9d504dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw filled circle on the secondary (touch) screen. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.  <a href="class_voxie_box.html#a65b2b2fe7c553bcb274b970f9d504dff">More...</a><br /></td></tr>
<tr class="separator:a65b2b2fe7c553bcb274b970f9d504dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb236e81acb2b909dfa7bc67d70b5c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#adb236e81acb2b909dfa7bc67d70b5c07">debugDrawTile</a> (<a class="el" href="structtiletype.html">tiletype</a> *source, int xpos, int ypos)</td></tr>
<tr class="memdesc:adb236e81acb2b909dfa7bc67d70b5c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a texture onto the secondary (touch) screen.  <a href="class_voxie_box.html#adb236e81acb2b909dfa7bc67d70b5c07">More...</a><br /></td></tr>
<tr class="separator:adb236e81acb2b909dfa7bc67d70b5c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5579e62d075cae7af8daf6770dd1bf88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a5579e62d075cae7af8daf6770dd1bf88">drawVox</a> (<a class="el" href="structpoint3d.html">point3d</a> pos, int col)</td></tr>
<tr class="memdesc:a5579e62d075cae7af8daf6770dd1bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a single voxel onto the volumetric using a single <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates.  <a href="class_voxie_box.html#a5579e62d075cae7af8daf6770dd1bf88">More...</a><br /></td></tr>
<tr class="separator:a5579e62d075cae7af8daf6770dd1bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f88d3c59c20fdceb07bef76f782bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a32f88d3c59c20fdceb07bef76f782bf3">drawVox</a> (float x, float y, float z, int col)</td></tr>
<tr class="memdesc:a32f88d3c59c20fdceb07bef76f782bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a single voxel onto the volumetric using 3 floats for coordinates.  <a href="class_voxie_box.html#a32f88d3c59c20fdceb07bef76f782bf3">More...</a><br /></td></tr>
<tr class="separator:a32f88d3c59c20fdceb07bef76f782bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a482189e5a8d97f41e99d6ac6cfbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a59a482189e5a8d97f41e99d6ac6cfbdd">drawBox</a> (<a class="el" href="structpoint3d.html">point3d</a> posLeftUpTop, <a class="el" href="structpoint3d.html">point3d</a> posRightDownBottom, int fillmode, int col)</td></tr>
<tr class="memdesc:a59a482189e5a8d97f41e99d6ac6cfbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a rectangle / box on the volumetric display using 2 point3ds for coordinates.  <a href="class_voxie_box.html#a59a482189e5a8d97f41e99d6ac6cfbdd">More...</a><br /></td></tr>
<tr class="separator:a59a482189e5a8d97f41e99d6ac6cfbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2107f035a5240bbdde8bff28cb03f9"><td class="memItemLeft" align="right" valign="top"><a id="afb2107f035a5240bbdde8bff28cb03f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#afb2107f035a5240bbdde8bff28cb03f9">drawBox</a> (float x0, float y0, float z0, float x1, float y1, float z1, int fillmode, int col)</td></tr>
<tr class="memdesc:afb2107f035a5240bbdde8bff28cb03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a rectangle/box on the volumetric display using 6 floats for coordinates. <br /></td></tr>
<tr class="separator:afb2107f035a5240bbdde8bff28cb03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a32fa6674e482fb2347e213604bb404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9a32fa6674e482fb2347e213604bb404">drawCube</a> (<a class="el" href="structpoint3d.html">point3d</a> *p, <a class="el" href="structpoint3d.html">point3d</a> *r, <a class="el" href="structpoint3d.html">point3d</a> *d, <a class="el" href="structpoint3d.html">point3d</a> *f, int fillmode, int col)</td></tr>
<tr class="memdesc:a9a32fa6674e482fb2347e213604bb404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cube using specified vectors to volumetric display. Similar to <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:<a class="el" href="class_voxie_box.html#a21acf498b44f568ba6a01ff6bb7b13d4" title="Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display.">drawModel()</a> but only draws a cube.  <a href="class_voxie_box.html#a9a32fa6674e482fb2347e213604bb404">More...</a><br /></td></tr>
<tr class="separator:a9a32fa6674e482fb2347e213604bb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4cc5d2d763c8aafe1ca08bc8bc2265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abc4cc5d2d763c8aafe1ca08bc8bc2265">drawSphere</a> (<a class="el" href="structpoint3d.html">point3d</a> pos, float radius, int fillmode, int col)</td></tr>
<tr class="memdesc:abc4cc5d2d763c8aafe1ca08bc8bc2265"><td class="mdescLeft">&#160;</td><td class="mdescRight">renders a sphere on the volumetric display using a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for position  <a href="class_voxie_box.html#abc4cc5d2d763c8aafe1ca08bc8bc2265">More...</a><br /></td></tr>
<tr class="separator:abc4cc5d2d763c8aafe1ca08bc8bc2265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233de3e5673e223ae90e82f5b2b89532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a233de3e5673e223ae90e82f5b2b89532">drawSphere</a> (float x, float y, float z, float radius, int fillmode, int col)</td></tr>
<tr class="memdesc:a233de3e5673e223ae90e82f5b2b89532"><td class="mdescLeft">&#160;</td><td class="mdescRight">renders a sphere on the volumetric display using 3 floats  <a href="class_voxie_box.html#a233de3e5673e223ae90e82f5b2b89532">More...</a><br /></td></tr>
<tr class="separator:a233de3e5673e223ae90e82f5b2b89532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057a91a5fbcb7dac98bae94214fe757c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a057a91a5fbcb7dac98bae94214fe757c">drawLine</a> (<a class="el" href="structpoint3d.html">point3d</a> startPos, <a class="el" href="structpoint3d.html">point3d</a> endPos, int col)</td></tr>
<tr class="memdesc:a057a91a5fbcb7dac98bae94214fe757c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a line on the volumetric display using <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates.  <a href="class_voxie_box.html#a057a91a5fbcb7dac98bae94214fe757c">More...</a><br /></td></tr>
<tr class="separator:a057a91a5fbcb7dac98bae94214fe757c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b3d35798ed4d74058e03d58634e03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ace0b3d35798ed4d74058e03d58634e03">drawLine</a> (float xStartPos, float yStartPos, float zStartPos, float xEndPos, float yEndPos, float zEndPos, int col)</td></tr>
<tr class="memdesc:ace0b3d35798ed4d74058e03d58634e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a line on the volumetric display using 6 floats for coordinates.  <a href="class_voxie_box.html#ace0b3d35798ed4d74058e03d58634e03">More...</a><br /></td></tr>
<tr class="separator:ace0b3d35798ed4d74058e03d58634e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39520956d73a5c0632bc46ae4d590b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a39520956d73a5c0632bc46ae4d590b18">drawPoly</a> (<a class="el" href="structpol__t.html">pol_t</a> *, int, int)</td></tr>
<tr class="memdesc:a39520956d73a5c0632bc46ae4d590b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a filled polygon. Assumes points are in loop order and coplanar.  <a href="class_voxie_box.html#a39520956d73a5c0632bc46ae4d590b18">More...</a><br /></td></tr>
<tr class="separator:a39520956d73a5c0632bc46ae4d590b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94cfd1251732ff5bcb5a3aa2d13d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aab94cfd1251732ff5bcb5a3aa2d13d4d">drawMesh</a> (char *fileNam, <a class="el" href="structpoltex__t.html">poltex_t</a> *verticeList, int verticeNum, int *meshList, int meshNum, int flags, int col)</td></tr>
<tr class="memdesc:aab94cfd1251732ff5bcb5a3aa2d13d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a mesh from a list of vertices can render in as dots, lines, polygons, or filled mesh.  <a href="class_voxie_box.html#aab94cfd1251732ff5bcb5a3aa2d13d4d">More...</a><br /></td></tr>
<tr class="separator:aab94cfd1251732ff5bcb5a3aa2d13d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f4ea3e418f3c33c8ff0a9d4a74167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8e2f4ea3e418f3c33c8ff0a9d4a74167">drawCone</a> (float xStartPos, float yStartPos, float zStartPos, float startRadius, float xEndPos, float yEndPos, float zEndPos, float endRadius, int fillmode, int col)</td></tr>
<tr class="memdesc:a8e2f4ea3e418f3c33c8ff0a9d4a74167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 6 floats for coordinates.  <a href="class_voxie_box.html#a8e2f4ea3e418f3c33c8ff0a9d4a74167">More...</a><br /></td></tr>
<tr class="separator:a8e2f4ea3e418f3c33c8ff0a9d4a74167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae708b7fe0ae0cd81fbae7ae66aaed4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae708b7fe0ae0cd81fbae7ae66aaed4b4">drawCone</a> (<a class="el" href="structpoint3d.html">point3d</a> startPos, float startRadius, <a class="el" href="structpoint3d.html">point3d</a> endPos, float endRadius, int fillmode, int col)</td></tr>
<tr class="memdesc:ae708b7fe0ae0cd81fbae7ae66aaed4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 2 point3ds for coordinates.  <a href="class_voxie_box.html#ae708b7fe0ae0cd81fbae7ae66aaed4b4">More...</a><br /></td></tr>
<tr class="separator:ae708b7fe0ae0cd81fbae7ae66aaed4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21acf498b44f568ba6a01ff6bb7b13d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a21acf498b44f568ba6a01ff6bb7b13d4">drawModel</a> (const char *filename, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int col)</td></tr>
<tr class="memdesc:a21acf498b44f568ba6a01ff6bb7b13d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display.  <a href="class_voxie_box.html#a21acf498b44f568ba6a01ff6bb7b13d4">More...</a><br /></td></tr>
<tr class="separator:a21acf498b44f568ba6a01ff6bb7b13d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c093ab5b951e958a673aafeaae9f925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7c093ab5b951e958a673aafeaae9f925">drawModelExt</a> (const char *filename, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int col, float forcescale, float fdrawratio, int flags)</td></tr>
<tr class="memdesc:a7c093ab5b951e958a673aafeaae9f925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders 3D model (.obj, .ply, .stl, .kv6) Displays a filename mesh onto the volumetric display. Extended from <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:drawModel.  <a href="class_voxie_box.html#a7c093ab5b951e958a673aafeaae9f925">More...</a><br /></td></tr>
<tr class="separator:a7c093ab5b951e958a673aafeaae9f925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecf77ce85155bb153c2f67c777815a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a3ecf77ce85155bb153c2f67c777815a3">drawQuad</a> (char *filename, <a class="el" href="structpoint3d.html">point3d</a> *pos, float width, float height, float hang, float vang, float tilt, int col, float uValue, float vValue)</td></tr>
<tr class="memdesc:a3ecf77ce85155bb153c2f67c777815a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a 2D textured (.png, .jpg... most image formats) quad (plane) onto the volumetric display. Useful to rendering 2D textures. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.  <a href="class_voxie_box.html#a3ecf77ce85155bb153c2f67c777815a3">More...</a><br /></td></tr>
<tr class="separator:a3ecf77ce85155bb153c2f67c777815a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2364111ffd69401b54067d8172165ed5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a2364111ffd69401b54067d8172165ed5">drawHeightMap</a> (char *fileName, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int colorKey, int reserved, int flags)</td></tr>
<tr class="memdesc:a2364111ffd69401b54067d8172165ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a heightmap (.jpg, .png or tiletype data) onto the volumetric display.  <a href="class_voxie_box.html#a2364111ffd69401b54067d8172165ed5">More...</a><br /></td></tr>
<tr class="separator:a2364111ffd69401b54067d8172165ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d582343c43cbe82ce8df1e362055ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a86d582343c43cbe82ce8df1e362055ad">drawText</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, int col, const char *fmt,...)</td></tr>
<tr class="memdesc:a86d582343c43cbe82ce8df1e362055ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string (printf-style) unto the volumetric display.  <a href="class_voxie_box.html#a86d582343c43cbe82ce8df1e362055ad">More...</a><br /></td></tr>
<tr class="separator:a86d582343c43cbe82ce8df1e362055ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc219b542cd45c05f9691187cdf5865"><td class="memItemLeft" align="right" valign="top"><a id="a7fc219b542cd45c05f9691187cdf5865"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7fc219b542cd45c05f9691187cdf5865">drawDicom</a> (<a class="el" href="structvoxie__dicom__t.html">voxie_dicom_t</a> *vd, const char *gfilnam, <a class="el" href="structpoint3d.html">point3d</a> *gp, <a class="el" href="structpoint3d.html">point3d</a> *gr, <a class="el" href="structpoint3d.html">point3d</a> *gd, <a class="el" href="structpoint3d.html">point3d</a> *gf, int *animn, int *loaddone)</td></tr>
<tr class="memdesc:a7fc219b542cd45c05f9691187cdf5865"><td class="mdescLeft">&#160;</td><td class="mdescRight">draw a DICOM file onto the volumetric display. - for help with this function call contact voxon photonics directly. <br /></td></tr>
<tr class="separator:a7fc219b542cd45c05f9691187cdf5865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f5d41f0d1b3cef1593d959df423238"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a92f5d41f0d1b3cef1593d959df423238">getKeyState</a> (int scancode)</td></tr>
<tr class="memdesc:a92f5d41f0d1b3cef1593d959df423238"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a key's input state (0 = no press, 1 = just pressed, 3 = held down) see vxInputTypes.h::Keys for scancodes  <a href="class_voxie_box.html#a92f5d41f0d1b3cef1593d959df423238">More...</a><br /></td></tr>
<tr class="separator:a92f5d41f0d1b3cef1593d959df423238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d73e1715406da5bdb1b4a0296ab9e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a76d73e1715406da5bdb1b4a0296ab9e4">getKeyIsDown</a> (int scancode)</td></tr>
<tr class="memdesc:a76d73e1715406da5bdb1b4a0296ab9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if the scancode's key is held down (pressed). For scancodes see vxInputTypes.h::Keys  <a href="class_voxie_box.html#a76d73e1715406da5bdb1b4a0296ab9e4">More...</a><br /></td></tr>
<tr class="separator:a76d73e1715406da5bdb1b4a0296ab9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7783714d972bc677504abd16e91fc53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae7783714d972bc677504abd16e91fc53">getKeyOnDown</a> (int scancode)</td></tr>
<tr class="memdesc:ae7783714d972bc677504abd16e91fc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a 1 if the scancode's key is just pressed. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys  <a href="class_voxie_box.html#ae7783714d972bc677504abd16e91fc53">More...</a><br /></td></tr>
<tr class="separator:ae7783714d972bc677504abd16e91fc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368adfcb2a7d29bc794c0a6c672ec862"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a368adfcb2a7d29bc794c0a6c672ec862">getKeyDownTime</a> (int scancode)</td></tr>
<tr class="memdesc:a368adfcb2a7d29bc794c0a6c672ec862"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the time (in seconds) The scancode's key has been held down for requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> to be set to false to work  <a href="class_voxie_box.html#a368adfcb2a7d29bc794c0a6c672ec862">More...</a><br /></td></tr>
<tr class="separator:a368adfcb2a7d29bc794c0a6c672ec862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67eea4625f9c2df1403f25a108301e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae67eea4625f9c2df1403f25a108301e7">getKeyOnUp</a> (int scancode)</td></tr>
<tr class="memdesc:ae67eea4625f9c2df1403f25a108301e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a 1 if the scancode's key is just released. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys  <a href="class_voxie_box.html#ae67eea4625f9c2df1403f25a108301e7">More...</a><br /></td></tr>
<tr class="separator:ae67eea4625f9c2df1403f25a108301e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aa369d7331f1e2680803ea84dd022b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a53aa369d7331f1e2680803ea84dd022b">getKeyStream</a> ()</td></tr>
<tr class="memdesc:a53aa369d7331f1e2680803ea84dd022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns buffered ASCII keyboard input.  <a href="class_voxie_box.html#a53aa369d7331f1e2680803ea84dd022b">More...</a><br /></td></tr>
<tr class="separator:a53aa369d7331f1e2680803ea84dd022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7203e5ec0048f62640fc3dbccffe582a"><td class="memItemLeft" align="right" valign="top"><a id="a7203e5ec0048f62640fc3dbccffe582a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7203e5ec0048f62640fc3dbccffe582a">getKeyStreamScanCode</a> ()</td></tr>
<tr class="memdesc:a7203e5ec0048f62640fc3dbccffe582a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to getKeyStream but beturns only the scancode of the keystate of a streaming state. To be run with a while loop. Returns 0 if no more keys are in the stream. <br /></td></tr>
<tr class="separator:a7203e5ec0048f62640fc3dbccffe582a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e0592fdd5b0ac20f71f1779db9fd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae2e0592fdd5b0ac20f71f1779db9fd84">reportKeyboard</a> (int posX, int posY)</td></tr>
<tr class="memdesc:ae2e0592fdd5b0ac20f71f1779db9fd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of the keyboard on to the secondary (touch) screen. Used to help with debugging/.  <a href="class_voxie_box.html#ae2e0592fdd5b0ac20f71f1779db9fd84">More...</a><br /></td></tr>
<tr class="separator:ae2e0592fdd5b0ac20f71f1779db9fd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139974ac1d2f57c560d3dd269f9d2ac"><td class="memItemLeft" align="right" valign="top"><a id="af139974ac1d2f57c560d3dd269f9d2ac"></a>
<a class="el" href="structvoxie__keyboard__history__t.html">voxie_keyboard_history_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af139974ac1d2f57c560d3dd269f9d2ac">getKeyHistory</a> ()</td></tr>
<tr class="memdesc:af139974ac1d2f57c560d3dd269f9d2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns internal <a class="el" href="structvoxie__keyboard__history__t.html" title="used internally by VoxieBox to log various keyboard button inputs this struct allows you to view the ...">voxie_keyboard_history_t</a> struct which holds the keyboard input history. setEnableLegacyKeyInput but be set to false. <br /></td></tr>
<tr class="separator:af139974ac1d2f57c560d3dd269f9d2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bee40c97a178811c285249d31fb19d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a05bee40c97a178811c285249d31fb19d">getMouseXDelta</a> ()</td></tr>
<tr class="memdesc:a05bee40c97a178811c285249d31fb19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's X delta movement. Reads from internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>.  <a href="class_voxie_box.html#a05bee40c97a178811c285249d31fb19d">More...</a><br /></td></tr>
<tr class="separator:a05bee40c97a178811c285249d31fb19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a8261118e2b077e874eba3d2b32deb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad8a8261118e2b077e874eba3d2b32deb">getMouseYDelta</a> ()</td></tr>
<tr class="memdesc:ad8a8261118e2b077e874eba3d2b32deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's Y delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>.  <a href="class_voxie_box.html#ad8a8261118e2b077e874eba3d2b32deb">More...</a><br /></td></tr>
<tr class="separator:ad8a8261118e2b077e874eba3d2b32deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcd3a5457b65f75e0352804b6b5686e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8bcd3a5457b65f75e0352804b6b5686e">getMouseZDelta</a> ()</td></tr>
<tr class="memdesc:a8bcd3a5457b65f75e0352804b6b5686e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's Z delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>.  <a href="class_voxie_box.html#a8bcd3a5457b65f75e0352804b6b5686e">More...</a><br /></td></tr>
<tr class="separator:a8bcd3a5457b65f75e0352804b6b5686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05020085c7aa8fab0d9035b451384285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a05020085c7aa8fab0d9035b451384285">getMouseDelta</a> ()</td></tr>
<tr class="memdesc:a05020085c7aa8fab0d9035b451384285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's X,Y and Z delta movements as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>.  <a href="class_voxie_box.html#a05020085c7aa8fab0d9035b451384285">More...</a><br /></td></tr>
<tr class="separator:a05020085c7aa8fab0d9035b451384285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac567600c40003e62fbcf9ffe1aaf938b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ac567600c40003e62fbcf9ffe1aaf938b">getMousePosition</a> ()</td></tr>
<tr class="separator:ac567600c40003e62fbcf9ffe1aaf938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb94038629b4f11362e2c09981f1168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abdb94038629b4f11362e2c09981f1168">setMousePosition</a> (<a class="el" href="structpoint3d.html">point3d</a> newPos)</td></tr>
<tr class="memdesc:abdb94038629b4f11362e2c09981f1168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides internal mouse position with a new <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> position.  <a href="class_voxie_box.html#abdb94038629b4f11362e2c09981f1168">More...</a><br /></td></tr>
<tr class="separator:abdb94038629b4f11362e2c09981f1168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feed90a86a1187d9aef38cda59804da"><td class="memItemLeft" align="right" valign="top"><a id="a7feed90a86a1187d9aef38cda59804da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7feed90a86a1187d9aef38cda59804da">setMouseXYSensitivity</a> (float newAmount)</td></tr>
<tr class="memdesc:a7feed90a86a1187d9aef38cda59804da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Mouse's X and Y sensitivity. 0.001 is default. (0.0001 = low sensitive, 0.9 = extremely sensitive) Mouse movements work in intergers the amount is scaled down. <br /></td></tr>
<tr class="separator:a7feed90a86a1187d9aef38cda59804da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9a9fb0b08afd89678f664e98b0dd69"><td class="memItemLeft" align="right" valign="top"><a id="aaf9a9fb0b08afd89678f664e98b0dd69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aaf9a9fb0b08afd89678f664e98b0dd69">setMouseZSensitivity</a> (float newAmount)</td></tr>
<tr class="memdesc:aaf9a9fb0b08afd89678f664e98b0dd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Mouse's Z sensitivity. 0.0005 is default. Since Mouse movements work in intergers the amount is scaled down. <br /></td></tr>
<tr class="separator:aaf9a9fb0b08afd89678f664e98b0dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9198d489a52c186090f1a1f0589f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af8e9198d489a52c186090f1a1f0589f1">setMouseDoubleClickThreshold</a> (double timeThreshold)</td></tr>
<tr class="memdesc:af8e9198d489a52c186090f1a1f0589f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time between mouse clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb" title="Returns 1 if particular Mouse&#39;s buttonCode has been clicked twice within the double click threshold.">getMouseDoubleClick()</a>)  <a href="class_voxie_box.html#af8e9198d489a52c186090f1a1f0589f1">More...</a><br /></td></tr>
<tr class="separator:af8e9198d489a52c186090f1a1f0589f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4ffb974a7b7ed79159d281ab053643"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aea4ffb974a7b7ed79159d281ab053643">getMouseDoubleClickThreshold</a> ()</td></tr>
<tr class="memdesc:aea4ffb974a7b7ed79159d281ab053643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse double click threshold. (how quickly 2 mouse clicks signify a 'double click'). Presented in seconds.  <a href="class_voxie_box.html#aea4ffb974a7b7ed79159d281ab053643">More...</a><br /></td></tr>
<tr class="separator:aea4ffb974a7b7ed79159d281ab053643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e6174c6c2c64d157e27b4a10354fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad90e6174c6c2c64d157e27b4a10354fa">getMouseZSensitivity</a> ()</td></tr>
<tr class="memdesc:ad90e6174c6c2c64d157e27b4a10354fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mouse Z sensitivity. Default is 0.0005.  <a href="class_voxie_box.html#ad90e6174c6c2c64d157e27b4a10354fa">More...</a><br /></td></tr>
<tr class="separator:ad90e6174c6c2c64d157e27b4a10354fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722648b0a9d0a393521d25e7f3ba4600"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a722648b0a9d0a393521d25e7f3ba4600">getMouseXYSensitivity</a> ()</td></tr>
<tr class="memdesc:a722648b0a9d0a393521d25e7f3ba4600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mouse XY sensitivity. Default is 0.001.  <a href="class_voxie_box.html#a722648b0a9d0a393521d25e7f3ba4600">More...</a><br /></td></tr>
<tr class="separator:a722648b0a9d0a393521d25e7f3ba4600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9505deb662efbbd9d955158be30575f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9505deb662efbbd9d955158be30575f5">getMouseButtonState</a> ()</td></tr>
<tr class="memdesc:a9505deb662efbbd9d955158be30575f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>.  <a href="class_voxie_box.html#a9505deb662efbbd9d955158be30575f5">More...</a><br /></td></tr>
<tr class="separator:a9505deb662efbbd9d955158be30575f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb63bd24d7437b0ce407ebe619907e79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abb63bd24d7437b0ce407ebe619907e79">getMousePrevButtonState</a> ()</td></tr>
<tr class="memdesc:abb63bd24d7437b0ce407ebe619907e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse previous button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br  />
  <a href="class_voxie_box.html#abb63bd24d7437b0ce407ebe619907e79">More...</a><br /></td></tr>
<tr class="separator:abb63bd24d7437b0ce407ebe619907e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65fbb73532b95287a314acf018ebc58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ac65fbb73532b95287a314acf018ebc58">getMouseButtonIsDown</a> (int buttonCode)</td></tr>
<tr class="memdesc:ac65fbb73532b95287a314acf018ebc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of mouse's buttonCode.  <a href="class_voxie_box.html#ac65fbb73532b95287a314acf018ebc58">More...</a><br /></td></tr>
<tr class="separator:ac65fbb73532b95287a314acf018ebc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70ad6a3746e626b2486f5d09cc2460"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a5b70ad6a3746e626b2486f5d09cc2460">getMouseButtonOnDown</a> (int buttonCode)</td></tr>
<tr class="memdesc:a5b70ad6a3746e626b2486f5d09cc2460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of mouse's buttonCode.  <a href="class_voxie_box.html#a5b70ad6a3746e626b2486f5d09cc2460">More...</a><br /></td></tr>
<tr class="separator:a5b70ad6a3746e626b2486f5d09cc2460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5757b6a7369f171f64c4088cc4ad2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0c5757b6a7369f171f64c4088cc4ad2d">getMouseButtonOnUp</a> (int buttonCode)</td></tr>
<tr class="memdesc:a0c5757b6a7369f171f64c4088cc4ad2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if desired MoustButton has been just released ('on up')  <a href="class_voxie_box.html#a0c5757b6a7369f171f64c4088cc4ad2d">More...</a><br /></td></tr>
<tr class="separator:a0c5757b6a7369f171f64c4088cc4ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e820dbd04614d0a72ee9648de0f72b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6e820dbd04614d0a72ee9648de0f72b5">getMouseButtonDownTime</a> (int buttonCode)</td></tr>
<tr class="memdesc:a6e820dbd04614d0a72ee9648de0f72b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mount of time (in seconds) a mouse's button has been pressed.  <a href="class_voxie_box.html#a6e820dbd04614d0a72ee9648de0f72b5">More...</a><br /></td></tr>
<tr class="separator:a6e820dbd04614d0a72ee9648de0f72b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a19c0708fa54178016751597357bcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb">getMouseDoubleClick</a> (int buttonCode)</td></tr>
<tr class="memdesc:af5a19c0708fa54178016751597357bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Mouse's buttonCode has been clicked twice within the double click threshold.  <a href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb">More...</a><br /></td></tr>
<tr class="separator:af5a19c0708fa54178016751597357bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2b7e9e938d61314aaf8c3b23fbae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8fc2b7e9e938d61314aaf8c3b23fbae2">reportMouse</a> (int posX, int posY, bool showCursor=true)</td></tr>
<tr class="memdesc:a8fc2b7e9e938d61314aaf8c3b23fbae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports mouse input state information onto secondary (touch) screen.  <a href="class_voxie_box.html#a8fc2b7e9e938d61314aaf8c3b23fbae2">More...</a><br /></td></tr>
<tr class="separator:a8fc2b7e9e938d61314aaf8c3b23fbae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec539a88701b8f924728b6c97d5c59d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8ec539a88701b8f924728b6c97d5c59d">getMouseState</a> ()</td></tr>
<tr class="memdesc:a8ec539a88701b8f924728b6c97d5c59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal (in) voxie_inputs_t struct.  <a href="class_voxie_box.html#a8ec539a88701b8f924728b6c97d5c59d">More...</a><br /></td></tr>
<tr class="separator:a8ec539a88701b8f924728b6c97d5c59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19870dae738a7c8214ea9d23580b8c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a19870dae738a7c8214ea9d23580b8c19">setMouseState</a> (<a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> newMouse)</td></tr>
<tr class="memdesc:a19870dae738a7c8214ea9d23580b8c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> mouse state.  <a href="class_voxie_box.html#a19870dae738a7c8214ea9d23580b8c19">More...</a><br /></td></tr>
<tr class="separator:a19870dae738a7c8214ea9d23580b8c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a30340112a8c0b2096209367d3a839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839">drawCursor</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, int inputType, int inputID, int col)</td></tr>
<tr class="memdesc:aa1a30340112a8c0b2096209367d3a839"><td class="mdescLeft">&#160;</td><td class="mdescRight">draws a cursor unto the volumetric display at the position specified. <br  />
  <a href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839">More...</a><br /></td></tr>
<tr class="separator:aa1a30340112a8c0b2096209367d3a839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b13f647843d26d5a2ac773120698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9a99b13f647843d26d5a2ac773120698">setMouseOrientation</a> (int orientation)</td></tr>
<tr class="memdesc:a9a99b13f647843d26d5a2ac773120698"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the orientation of the user's intended position when using the mouse  <a href="class_voxie_box.html#a9a99b13f647843d26d5a2ac773120698">More...</a><br /></td></tr>
<tr class="separator:a9a99b13f647843d26d5a2ac773120698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9a424af65cf4b24a598bc16ab2ddfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6c9a424af65cf4b24a598bc16ab2ddfc">getMouseOrientation</a> ()</td></tr>
<tr class="memdesc:a6c9a424af65cf4b24a598bc16ab2ddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the orientation set for the mouse  <a href="class_voxie_box.html#a6c9a424af65cf4b24a598bc16ab2ddfc">More...</a><br /></td></tr>
<tr class="separator:a6c9a424af65cf4b24a598bc16ab2ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0698a2ecfef631c2e021b3b8fe8ddee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0698a2ecfef631c2e021b3b8fe8ddee7">touchAddCustomLayout</a> (const <a class="el" href="structtouchkey__t.html">touchkey_t</a> *touchkey=<a class="el" href="vx_input_types_8h.html#a9cd8ea1ad292fb3d042f2436b6b6e276">default_touchkey</a>, int sizeOfArray=sizeof(<a class="el" href="vx_input_types_8h.html#a9cd8ea1ad292fb3d042f2436b6b6e276">default_touchkey</a>)/sizeof(<a class="el" href="structtouchkey__t.html">touchkey_t</a>))</td></tr>
<tr class="memdesc:a0698a2ecfef631c2e021b3b8fe8ddee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add custom touch keys. (enable touch keyboard under 'Misc' menu tab)  <a href="class_voxie_box.html#a0698a2ecfef631c2e021b3b8fe8ddee7">More...</a><br /></td></tr>
<tr class="separator:a0698a2ecfef631c2e021b3b8fe8ddee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ab69387e02516d39dcb21c0bc2d34d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a88ab69387e02516d39dcb21c0bc2d34d">updateJoyState</a> (int controllerID, <a class="el" href="structvoxie__xbox__t.html">voxie_xbox_t</a> *vx)</td></tr>
<tr class="memdesc:a88ab69387e02516d39dcb21c0bc2d34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the game controller's input state. Used to manage game controller inputs when <a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> is set to true.  <a href="class_voxie_box.html#a88ab69387e02516d39dcb21c0bc2d34d">More...</a><br /></td></tr>
<tr class="separator:a88ab69387e02516d39dcb21c0bc2d34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841bb02d7571ab57ab9c92192b934a1e"><td class="memItemLeft" align="right" valign="top"><a id="a841bb02d7571ab57ab9c92192b934a1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a841bb02d7571ab57ab9c92192b934a1e">setJoyInputToXInput</a> ()</td></tr>
<tr class="memdesc:a841bb02d7571ab57ab9c92192b934a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class to use the XInput API to read joystick inputs (for modern game controllers). <br /></td></tr>
<tr class="separator:a841bb02d7571ab57ab9c92192b934a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c501eaaf3f903cf257b1900c63b439"><td class="memItemLeft" align="right" valign="top"><a id="ae3c501eaaf3f903cf257b1900c63b439"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae3c501eaaf3f903cf257b1900c63b439">setJoyInputToDirectInput</a> ()</td></tr>
<tr class="memdesc:ae3c501eaaf3f903cf257b1900c63b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class to use the DirectInput API to read joystick inputs (for older game controllers). Uses joyGetPosEx function. <br /></td></tr>
<tr class="separator:ae3c501eaaf3f903cf257b1900c63b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fb680710180b707008854ca5357095"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad6fb680710180b707008854ca5357095">getJoyButtonState</a> (int controllerID)</td></tr>
<tr class="memdesc:ad6fb680710180b707008854ca5357095"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the game controllers button state. See vxInputTypes::JoyButtonCodes for details.  <a href="class_voxie_box.html#ad6fb680710180b707008854ca5357095">More...</a><br /></td></tr>
<tr class="separator:ad6fb680710180b707008854ca5357095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e29e9b674fb64f020ed160bb860a4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a80e29e9b674fb64f020ed160bb860a4d">getJoyButtonIsDown</a> (int controllerID, int joyButtonCode)</td></tr>
<tr class="memdesc:a80e29e9b674fb64f020ed160bb860a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is pressed down. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes <br  />
  <a href="class_voxie_box.html#a80e29e9b674fb64f020ed160bb860a4d">More...</a><br /></td></tr>
<tr class="separator:a80e29e9b674fb64f020ed160bb860a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc32bcc1084748c3d92576fbf8ce8db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#acfc32bcc1084748c3d92576fbf8ce8db">getJoyButtonOnDown</a> (int controllerID, int joyButtonCode)</td></tr>
<tr class="memdesc:acfc32bcc1084748c3d92576fbf8ce8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is just pressed. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes.  <a href="class_voxie_box.html#acfc32bcc1084748c3d92576fbf8ce8db">More...</a><br /></td></tr>
<tr class="separator:acfc32bcc1084748c3d92576fbf8ce8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0e98814ee28a4b8b18029be43a114e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0c0e98814ee28a4b8b18029be43a114e">getJoyButtonOnUp</a> (int controllerID, int joyButtonCode)</td></tr>
<tr class="memdesc:a0c0e98814ee28a4b8b18029be43a114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is just released. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes.  <a href="class_voxie_box.html#a0c0e98814ee28a4b8b18029be43a114e">More...</a><br /></td></tr>
<tr class="separator:a0c0e98814ee28a4b8b18029be43a114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242e70d38cb4e18575128574b7e3f2f9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a242e70d38cb4e18575128574b7e3f2f9">getJoyAnalogAxisValue</a> (int controllerID, int axis)</td></tr>
<tr class="memdesc:a242e70d38cb4e18575128574b7e3f2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a single analog axis (control stick) from a game controller. Value as an float range between -1 and 1, 0 is centred.  <a href="class_voxie_box.html#a242e70d38cb4e18575128574b7e3f2f9">More...</a><br /></td></tr>
<tr class="separator:a242e70d38cb4e18575128574b7e3f2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef8c955082e7b08d9e8240dcc82ad39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint2d.html">point2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aaef8c955082e7b08d9e8240dcc82ad39">getJoyAnalogAxisValueP2D</a> (int controllerID, int stick)</td></tr>
<tr class="memdesc:aaef8c955082e7b08d9e8240dcc82ad39"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the analog axis (control stick) from a game controller. Value as an Point2d range between -1 and 1, 0 is centred.  <a href="class_voxie_box.html#aaef8c955082e7b08d9e8240dcc82ad39">More...</a><br /></td></tr>
<tr class="separator:aaef8c955082e7b08d9e8240dcc82ad39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b196d4bc33271a26c62e140cd300ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a1b196d4bc33271a26c62e140cd300ea5">setJoyVibrate</a> (int controllerID, float leftMotorSpeed, float rightMotorSpeed)</td></tr>
<tr class="memdesc:a1b196d4bc33271a26c62e140cd300ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates vibration motors in XBox controller. XInput controllers only. To stop Be sure to call again with lmot=0.f, rmot=0.f!  <a href="class_voxie_box.html#a1b196d4bc33271a26c62e140cd300ea5">More...</a><br /></td></tr>
<tr class="separator:a1b196d4bc33271a26c62e140cd300ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0927f2395d4eb7bf55ddf31c355e57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0c0927f2395d4eb7bf55ddf31c355e57">getJoyNum</a> ()</td></tr>
<tr class="memdesc:a0c0927f2395d4eb7bf55ddf31c355e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of USB game controllers detected by the system.  <a href="class_voxie_box.html#a0c0927f2395d4eb7bf55ddf31c355e57">More...</a><br /></td></tr>
<tr class="separator:a0c0927f2395d4eb7bf55ddf31c355e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a1d2f5b9fa08b8ee93509a56b4493"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a2d7a1d2f5b9fa08b8ee93509a56b4493">getJoyButtonDownTime</a> (int controllerID, int joyButtonCode)</td></tr>
<tr class="memdesc:a2d7a1d2f5b9fa08b8ee93509a56b4493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a value in seconds of how long a controller's button has been held down for. Requires <a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> to be set to false to work. <br  />
  <a href="class_voxie_box.html#a2d7a1d2f5b9fa08b8ee93509a56b4493">More...</a><br /></td></tr>
<tr class="separator:a2d7a1d2f5b9fa08b8ee93509a56b4493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eedd380668a3439dbac70f8b9e40f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aa0eedd380668a3439dbac70f8b9e40f4">reportJoy</a> (int posX, int posY)</td></tr>
<tr class="memdesc:aa0eedd380668a3439dbac70f8b9e40f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports the state of the game controllers on to the secondary (touch) screen  <a href="class_voxie_box.html#aa0eedd380668a3439dbac70f8b9e40f4">More...</a><br /></td></tr>
<tr class="separator:aa0eedd380668a3439dbac70f8b9e40f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb8993bdc46f151be65314e05c8ef5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0eb8993bdc46f151be65314e05c8ef5f">setJoyDeadZone</a> (double deadZoneValue)</td></tr>
<tr class="memdesc:a0eb8993bdc46f151be65314e05c8ef5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal dead zone value for game controlers. (dead zone is the area where not input is detected). Value between 0 and 1. 0 = no deadzone. 1 = all deadzone. default is 0.3;.  <a href="class_voxie_box.html#a0eb8993bdc46f151be65314e05c8ef5f">More...</a><br /></td></tr>
<tr class="separator:a0eb8993bdc46f151be65314e05c8ef5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d69f900c71fa9c40d4df408ad873b77"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9d69f900c71fa9c40d4df408ad873b77">getJoyDeadZone</a> ()</td></tr>
<tr class="memdesc:a9d69f900c71fa9c40d4df408ad873b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal gamepad's dead zone value. Default is 0.3.  <a href="class_voxie_box.html#a9d69f900c71fa9c40d4df408ad873b77">More...</a><br /></td></tr>
<tr class="separator:a9d69f900c71fa9c40d4df408ad873b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec1b6790e95f3b4db74ebd73100e9d7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7ec1b6790e95f3b4db74ebd73100e9d7">getJoyTriggerValue</a> (int controllerID, int joyTriggerCode)</td></tr>
<tr class="memdesc:a7ec1b6790e95f3b4db74ebd73100e9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a controllers analog trigger value. 0 = 0% pressed ... 1 = 100% pressed. Presented as a float.  <a href="class_voxie_box.html#a7ec1b6790e95f3b4db74ebd73100e9d7">More...</a><br /></td></tr>
<tr class="separator:a7ec1b6790e95f3b4db74ebd73100e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff3b5678ba8d2e676fc73e7dd980ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a43ff3b5678ba8d2e676fc73e7dd980ff">setJoyOrientation</a> (int controllerID, int orientation)</td></tr>
<tr class="memdesc:a43ff3b5678ba8d2e676fc73e7dd980ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the orientation of the users intended position when using a game controller. At what side are they facing towards the volumetric display.  <a href="class_voxie_box.html#a43ff3b5678ba8d2e676fc73e7dd980ff">More...</a><br /></td></tr>
<tr class="separator:a43ff3b5678ba8d2e676fc73e7dd980ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca965eb57b330aa2cc4f067ee9fcfb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#adca965eb57b330aa2cc4f067ee9fcfb5">getJoyOrientation</a> (int controllerID)</td></tr>
<tr class="memdesc:adca965eb57b330aa2cc4f067ee9fcfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the orientation set for a specific game controller  <a href="class_voxie_box.html#adca965eb57b330aa2cc4f067ee9fcfb5">More...</a><br /></td></tr>
<tr class="separator:adca965eb57b330aa2cc4f067ee9fcfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a760d5670b3588aa95f97f831200bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a70a760d5670b3588aa95f97f831200bd">updateNavState</a> (int spaceNavID, <a class="el" href="structvoxie__nav__t.html">voxie_nav_t</a> *nav)</td></tr>
<tr class="memdesc:a70a760d5670b3588aa95f97f831200bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies 3DConnexion Space Navigator controller state to <a class="el" href="structvoxie__nav__t.html" title="3D SpaceMouse / Space Navigator by 3DConnexion input state struct. Used to manage SpaceNav input">voxie_nav_t</a> structure.  <a href="class_voxie_box.html#a70a760d5670b3588aa95f97f831200bd">More...</a><br /></td></tr>
<tr class="separator:a70a760d5670b3588aa95f97f831200bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8111bba76a21851f4280c09a9f90c332"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8111bba76a21851f4280c09a9f90c332">getNavNum</a> ()</td></tr>
<tr class="memdesc:a8111bba76a21851f4280c09a9f90c332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note for a SpaceNav to be detected it must be moved (is detecte when any of the SpaceNav's axis movements)  <a href="class_voxie_box.html#a8111bba76a21851f4280c09a9f90c332">More...</a><br /></td></tr>
<tr class="separator:a8111bba76a21851f4280c09a9f90c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd0190500f7279e6cd769004cc5a430"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8dd0190500f7279e6cd769004cc5a430">reportNav</a> (int posX, int posY, bool showCursor=true)</td></tr>
<tr class="memdesc:a8dd0190500f7279e6cd769004cc5a430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all SpaceNav input state onto the secondary (touch screen)  <a href="class_voxie_box.html#a8dd0190500f7279e6cd769004cc5a430">More...</a><br /></td></tr>
<tr class="separator:a8dd0190500f7279e6cd769004cc5a430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f3c3618a055cb191b7ccbf8155e38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a5e8f3c3618a055cb191b7ccbf8155e38">getNavButtonState</a> (int spaceNavID)</td></tr>
<tr class="memdesc:a5e8f3c3618a055cb191b7ccbf8155e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the button values (presented as binary of each button) for the Space Navigator. 0 = none, 1 = left, 2 = right, 3 = both.  <a href="class_voxie_box.html#a5e8f3c3618a055cb191b7ccbf8155e38">More...</a><br /></td></tr>
<tr class="separator:a5e8f3c3618a055cb191b7ccbf8155e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd2282f3ea1faa75500c0c95c6127c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aecd2282f3ea1faa75500c0c95c6127c1">getNavPrevButtonState</a> (int spaceNavID)</td></tr>
<tr class="memdesc:aecd2282f3ea1faa75500c0c95c6127c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the previous button values. Used for a legacy way to create your own button functions. Useful if <a class="el" href="class_voxie_box.html#a742aca3dfb890fb71c34bc0910f9483a" title="Set to true to handle Nav input manually. Disables many of the nav input functions....">setEnableLegacyNavInput()</a> is set to true.  <a href="class_voxie_box.html#aecd2282f3ea1faa75500c0c95c6127c1">More...</a><br /></td></tr>
<tr class="separator:aecd2282f3ea1faa75500c0c95c6127c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9440acc297003385583917cf2b60b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad9440acc297003385583917cf2b60b8c">getNavPosition</a> (int spaceNavID)</td></tr>
<tr class="memdesc:ad9440acc297003385583917cf2b60b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of the Nav's tracked position. Used primarly when the Space Nav is being used as a cursor.  <a href="class_voxie_box.html#ad9440acc297003385583917cf2b60b8c">More...</a><br /></td></tr>
<tr class="separator:ad9440acc297003385583917cf2b60b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf26a972aaae97bff81d7e7874f43b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#adbf26a972aaae97bff81d7e7874f43b1">getNavAngleDelta</a> (int spaceNavID)</td></tr>
<tr class="memdesc:adbf26a972aaae97bff81d7e7874f43b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Space Nav's angle input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change.  <a href="class_voxie_box.html#adbf26a972aaae97bff81d7e7874f43b1">More...</a><br /></td></tr>
<tr class="separator:adbf26a972aaae97bff81d7e7874f43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec281a876a0ced290f5936a31a0398ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aec281a876a0ced290f5936a31a0398ad">getNavDirectionDelta</a> (int spaceNavID)</td></tr>
<tr class="memdesc:aec281a876a0ced290f5936a31a0398ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Space Nav's direction input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change.  <a href="class_voxie_box.html#aec281a876a0ced290f5936a31a0398ad">More...</a><br /></td></tr>
<tr class="separator:aec281a876a0ced290f5936a31a0398ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dbdfe055747aa3f8922acde13aa67d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a96dbdfe055747aa3f8922acde13aa67d">getNavDirectionDeltaAxis</a> (int spaceNavID, int axis)</td></tr>
<tr class="memdesc:a96dbdfe055747aa3f8922acde13aa67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single axis of a Space Nav's direction delta (range is -1 to 1, 0 is centred). Axis 0 = x, 1 = y, 2 = z.  <a href="class_voxie_box.html#a96dbdfe055747aa3f8922acde13aa67d">More...</a><br /></td></tr>
<tr class="separator:a96dbdfe055747aa3f8922acde13aa67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1d49e5492f701cbf2926daaa464e8e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6c1d49e5492f701cbf2926daaa464e8e">getNavAngleDeltaAxis</a> (int spaceNavID, int axis)</td></tr>
<tr class="memdesc:a6c1d49e5492f701cbf2926daaa464e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a single axis of a spaceNav's angle delta (range is -1 to 1, 0 is centred). Axis 0 = x, 1 = y, 2 = z  <a href="class_voxie_box.html#a6c1d49e5492f701cbf2926daaa464e8e">More...</a><br /></td></tr>
<tr class="separator:a6c1d49e5492f701cbf2926daaa464e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e15621a0580a65cf2a88861eb8739"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a543e15621a0580a65cf2a88861eb8739">getNavButtonIsDown</a> (int spaceNavID, int buttonCode)</td></tr>
<tr class="memdesc:a543e15621a0580a65cf2a88861eb8739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button is being pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.  <a href="class_voxie_box.html#a543e15621a0580a65cf2a88861eb8739">More...</a><br /></td></tr>
<tr class="separator:a543e15621a0580a65cf2a88861eb8739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be43475c0e8cf140ae7fac98b79e69e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a8be43475c0e8cf140ae7fac98b79e69e">getNavButtonOnUp</a> (int spaceNavID, int buttonCode)</td></tr>
<tr class="memdesc:a8be43475c0e8cf140ae7fac98b79e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button has been just released from being held ('on up').  <a href="class_voxie_box.html#a8be43475c0e8cf140ae7fac98b79e69e">More...</a><br /></td></tr>
<tr class="separator:a8be43475c0e8cf140ae7fac98b79e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ee0e4687d8f2fe4278ef65e1294cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0a4ee0e4687d8f2fe4278ef65e1294cb">getNavButtonOnDown</a> (int spaceNavID, int buttonCode)</td></tr>
<tr class="memdesc:a0a4ee0e4687d8f2fe4278ef65e1294cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button has just been pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.  <a href="class_voxie_box.html#a0a4ee0e4687d8f2fe4278ef65e1294cb">More...</a><br /></td></tr>
<tr class="separator:a0a4ee0e4687d8f2fe4278ef65e1294cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4918d2f0e6e2f09d6e32ddafc9ec34"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a2e4918d2f0e6e2f09d6e32ddafc9ec34">getNavButtonDownTime</a> (int spaceNavID, int buttonCode)</td></tr>
<tr class="memdesc:a2e4918d2f0e6e2f09d6e32ddafc9ec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in seconds how long a Space Nav's button has been held down, otherwise returns a 0.  <a href="class_voxie_box.html#a2e4918d2f0e6e2f09d6e32ddafc9ec34">More...</a><br /></td></tr>
<tr class="separator:a2e4918d2f0e6e2f09d6e32ddafc9ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5194f3ae9e1e488f13dedc06631b2a51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51">getNavDoubleClick</a> (int spaceNavID, int buttonCode)</td></tr>
<tr class="memdesc:a5194f3ae9e1e488f13dedc06631b2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's buttonCode has been clicked twice within the double click threshold.  <a href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51">More...</a><br /></td></tr>
<tr class="separator:a5194f3ae9e1e488f13dedc06631b2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33485d39d396339de3d3be5241886c8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a33485d39d396339de3d3be5241886c8b">setNavDoubleClickThreshold</a> (double timeThreshold)</td></tr>
<tr class="memdesc:a33485d39d396339de3d3be5241886c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time between Space Nav clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51" title="Returns 1 if particular Space Nav&#39;s buttonCode has been clicked twice within the double click thresho...">getNavDoubleClick()</a>)  <a href="class_voxie_box.html#a33485d39d396339de3d3be5241886c8b">More...</a><br /></td></tr>
<tr class="separator:a33485d39d396339de3d3be5241886c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040618235390a1e8457be8bafca4eab3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a040618235390a1e8457be8bafca4eab3">getNavDoubleClickThreshold</a> ()</td></tr>
<tr class="separator:a040618235390a1e8457be8bafca4eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e5853eae6ad4f8da0048fc9fae2913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a64e5853eae6ad4f8da0048fc9fae2913">setNavDeadZone</a> (double deadZoneValue)</td></tr>
<tr class="memdesc:a64e5853eae6ad4f8da0048fc9fae2913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal deadzone for Space Navigators. (dead zone is the area where not input is detected)  <a href="class_voxie_box.html#a64e5853eae6ad4f8da0048fc9fae2913">More...</a><br /></td></tr>
<tr class="separator:a64e5853eae6ad4f8da0048fc9fae2913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc0196ee995635d7b1c6b955456f9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#acdc0196ee995635d7b1c6b955456f9a9">setNavSensitivity</a> (int spaceNavID, double newAmount)</td></tr>
<tr class="memdesc:acdc0196ee995635d7b1c6b955456f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Space Nav's sensitivity. Used to manage the Space Nav being used as a cursor. 0.0025 is default. Higher values increase sensitivity <br  />
  <a href="class_voxie_box.html#acdc0196ee995635d7b1c6b955456f9a9">More...</a><br /></td></tr>
<tr class="separator:acdc0196ee995635d7b1c6b955456f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07bee3c01da9e338ecace0a62f1e76a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae07bee3c01da9e338ecace0a62f1e76a">getNavSensitivity</a> (int spaceNavID)</td></tr>
<tr class="separator:ae07bee3c01da9e338ecace0a62f1e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92a13cfc256f19b916053d9c95011c5"><td class="memItemLeft" align="right" valign="top"><a id="ad92a13cfc256f19b916053d9c95011c5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad92a13cfc256f19b916053d9c95011c5">getNavDeadZone</a> ()</td></tr>
<tr class="memdesc:ad92a13cfc256f19b916053d9c95011c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal dead one value for the Space Navigator <br /></td></tr>
<tr class="separator:ad92a13cfc256f19b916053d9c95011c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2be6e36f3e52ae33ef46b1d281196a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af2be6e36f3e52ae33ef46b1d281196a0">setNavOrientation</a> (int spaceNavID, int orientation)</td></tr>
<tr class="memdesc:af2be6e36f3e52ae33ef46b1d281196a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the orientation of the user's intended position when using a Space Nav  <a href="class_voxie_box.html#af2be6e36f3e52ae33ef46b1d281196a0">More...</a><br /></td></tr>
<tr class="separator:af2be6e36f3e52ae33ef46b1d281196a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27815db90d21bf6e8df80dc19ab88ee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a27815db90d21bf6e8df80dc19ab88ee1">getNavOrientation</a> (int spaceNavID)</td></tr>
<tr class="memdesc:a27815db90d21bf6e8df80dc19ab88ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the orientation set for a specific Space Nav  <a href="class_voxie_box.html#a27815db90d21bf6e8df80dc19ab88ee1">More...</a><br /></td></tr>
<tr class="separator:a27815db90d21bf6e8df80dc19ab88ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5879b3f95704ba0563b3ed33c71cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#afb5879b3f95704ba0563b3ed33c71cea">menuReset</a> (int(*menu_update)(int id, char *st, double val, int how, void *userdata), void *userdata, char *bgImageFileName)</td></tr>
<tr class="memdesc:afb5879b3f95704ba0563b3ed33c71cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to reset the voxie menu and set a new custom menu update function (the menu which is on the secondary touch screen)  <a href="class_voxie_box.html#afb5879b3f95704ba0563b3ed33c71cea">More...</a><br /></td></tr>
<tr class="separator:afb5879b3f95704ba0563b3ed33c71cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f01b6afc8d26019e504d9154aab915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad0f01b6afc8d26019e504d9154aab915">menuAddTab</a> (char *st, int x, int y, int xs, int ys)</td></tr>
<tr class="memdesc:ad0f01b6afc8d26019e504d9154aab915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add custom menu tab on secondary (touch) screen menu (NOTE: there's only space for 2 more tabs on the 7" 1024x600 LCD screen)  <a href="class_voxie_box.html#ad0f01b6afc8d26019e504d9154aab915">More...</a><br /></td></tr>
<tr class="separator:ad0f01b6afc8d26019e504d9154aab915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24182daedfd67f13974273f2b2786c86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a24182daedfd67f13974273f2b2786c86">menuAddItem</a> (char *st, int x, int y, int xSize, int ySize, int id, int type, int state, int col, double startingVal, double minVal, double maxVal1, double minStepVal, double majStepVal)</td></tr>
<tr class="memdesc:a24182daedfd67f13974273f2b2786c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add item to a menu tab.  <a href="class_voxie_box.html#a24182daedfd67f13974273f2b2786c86">More...</a><br /></td></tr>
<tr class="separator:a24182daedfd67f13974273f2b2786c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb7fb316be13efd98f26e623aeb03b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abbb7fb316be13efd98f26e623aeb03b3">updateMenu</a> (int id, char *st, int state, double v)</td></tr>
<tr class="memdesc:abbb7fb316be13efd98f26e623aeb03b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once the menu is created, use this function to update a string, button status, or slider value.  <a href="class_voxie_box.html#abbb7fb316be13efd98f26e623aeb03b3">More...</a><br /></td></tr>
<tr class="separator:abbb7fb316be13efd98f26e623aeb03b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99015ec6f52f91cc0c80f9e8236385"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ace99015ec6f52f91cc0c80f9e8236385">playSound</a> (const char *fileName, int sourceChannel, int volumeLeft, int volumeRight, float playBackSpeed)</td></tr>
<tr class="memdesc:ace99015ec6f52f91cc0c80f9e8236385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays a sound (can be WAV, FLAC, MP3, M4A)  <a href="class_voxie_box.html#ace99015ec6f52f91cc0c80f9e8236385">More...</a><br /></td></tr>
<tr class="separator:ace99015ec6f52f91cc0c80f9e8236385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059069f0ecf2a149bbd8775e52613397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a059069f0ecf2a149bbd8775e52613397">updateSound</a> (int handleID, int sourceChannel, int volumeLeft, int volumeRight, float playBackSpeed)</td></tr>
<tr class="memdesc:a059069f0ecf2a149bbd8775e52613397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a currently playing sound.  <a href="class_voxie_box.html#a059069f0ecf2a149bbd8775e52613397">More...</a><br /></td></tr>
<tr class="separator:a059069f0ecf2a149bbd8775e52613397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e420ba18c63d86a4577fb5472ec7e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a46e420ba18c63d86a4577fb5472ec7e6">setAudioPlayCallBack</a> (void(*userplayfunc)(int *sampleBuffer, int sampleRate))</td></tr>
<tr class="memdesc:a46e420ba18c63d86a4577fb5472ec7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a custom audio callback function to play PCM / raw audio data.  <a href="class_voxie_box.html#a46e420ba18c63d86a4577fb5472ec7e6">More...</a><br /></td></tr>
<tr class="separator:a46e420ba18c63d86a4577fb5472ec7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd5f1ed65146b38989ae45430ed8a52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a1cd5f1ed65146b38989ae45430ed8a52">setAudioRecordCallBack</a> (void(*userrecfunc)(int *sampleBuffer, int sampleRate))</td></tr>
<tr class="memdesc:a1cd5f1ed65146b38989ae45430ed8a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a custom audio callback function to record PCM audio data (not a file)  <a href="class_voxie_box.html#a1cd5f1ed65146b38989ae45430ed8a52">More...</a><br /></td></tr>
<tr class="separator:a1cd5f1ed65146b38989ae45430ed8a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e449e778187eb0964434e2fc6ab08a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a6e449e778187eb0964434e2fc6ab08a8">mountZip</a> (char *fileName)</td></tr>
<tr class="memdesc:a6e449e778187eb0964434e2fc6ab08a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">mountZip - extracts and loads a .zip file into memory.  <a href="class_voxie_box.html#a6e449e778187eb0964434e2fc6ab08a8">More...</a><br /></td></tr>
<tr class="separator:a6e449e778187eb0964434e2fc6ab08a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f4a5ab82b92bef56f68004f11c62d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a91f4a5ab82b92bef56f68004f11c62d0">captureVolumeAsPly</a> ()</td></tr>
<tr class="memdesc:a91f4a5ab82b92bef56f68004f11c62d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PLY file.  <a href="class_voxie_box.html#a91f4a5ab82b92bef56f68004f11c62d0">More...</a><br /></td></tr>
<tr class="separator:a91f4a5ab82b92bef56f68004f11c62d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0fd4cfab9f4e1ec8a6acb6c5680efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aad0fd4cfab9f4e1ec8a6acb6c5680efb">captureVolumeAsPng</a> ()</td></tr>
<tr class="memdesc:aad0fd4cfab9f4e1ec8a6acb6c5680efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PNG file.  <a href="class_voxie_box.html#aad0fd4cfab9f4e1ec8a6acb6c5680efb">More...</a><br /></td></tr>
<tr class="separator:aad0fd4cfab9f4e1ec8a6acb6c5680efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029bd84f038b1716b05e40d7ad7adecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a029bd84f038b1716b05e40d7ad7adecd">captureVolume</a> (const char *fileName, int volCapMode, int targetVPS)</td></tr>
<tr class="memdesc:a029bd84f038b1716b05e40d7ad7adecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a capture of the volumetric buffer to occur on the next frame, or video capture to start /stop.  <a href="class_voxie_box.html#a029bd84f038b1716b05e40d7ad7adecd">More...</a><br /></td></tr>
<tr class="separator:a029bd84f038b1716b05e40d7ad7adecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155c5a410037eb09258b8ee414ae3491"><td class="memItemLeft" align="right" valign="top"><a id="a155c5a410037eb09258b8ee414ae3491"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a155c5a410037eb09258b8ee414ae3491">captureVolumeStop</a> ()</td></tr>
<tr class="memdesc:a155c5a410037eb09258b8ee414ae3491"><td class="mdescLeft">&#160;</td><td class="mdescRight">If volumetric recording is happening. call this function to stop. <br /></td></tr>
<tr class="separator:a155c5a410037eb09258b8ee414ae3491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbb09888096ee6591139e038c4d0cf0"><td class="memItemLeft" align="right" valign="top">__int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#afdbb09888096ee6591139e038c4d0cf0">getVxCppVersion</a> ()</td></tr>
<tr class="memdesc:afdbb09888096ee6591139e038c4d0cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a timestamp of the compile date of VxCpp.dll expressed as an __int64. (format: YYYYMMDDHHmmss)  <a href="class_voxie_box.html#afdbb09888096ee6591139e038c4d0cf0">More...</a><br /></td></tr>
<tr class="separator:afdbb09888096ee6591139e038c4d0cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f58cd3799f8c4146d7c662afc9e3ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ad6f58cd3799f8c4146d7c662afc9e3ac">scrollCol</a> (int offset)</td></tr>
<tr class="memdesc:ad6f58cd3799f8c4146d7c662afc9e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a scrolling color as an RGB hexidemical value  <a href="class_voxie_box.html#ad6f58cd3799f8c4146d7c662afc9e3ac">More...</a><br /></td></tr>
<tr class="separator:ad6f58cd3799f8c4146d7c662afc9e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00690aafd4ba31250980297091bde565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a00690aafd4ba31250980297091bde565">setColScrollSpeed</a> (double speed)</td></tr>
<tr class="memdesc:a00690aafd4ba31250980297091bde565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the speed of the internal color scroller default is 0.1. Value is how long in seconds before a color change.  <a href="class_voxie_box.html#a00690aafd4ba31250980297091bde565">More...</a><br /></td></tr>
<tr class="separator:a00690aafd4ba31250980297091bde565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab6ff6b07e15a38ad5a4127f32f246"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#afbab6ff6b07e15a38ad5a4127f32f246">clipInsideVolume</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, float radius=0)</td></tr>
<tr class="memdesc:afbab6ff6b07e15a38ad5a4127f32f246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clips a point to ensures it is within the volumes display's bounds.  <a href="class_voxie_box.html#afbab6ff6b07e15a38ad5a4127f32f246">More...</a><br /></td></tr>
<tr class="separator:afbab6ff6b07e15a38ad5a4127f32f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c394fd79456ebdda335a9493bb5ee8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a26c394fd79456ebdda335a9493bb5ee8">pointSame</a> (<a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b, <a class="el" href="structpoint3d.html">point3d</a> accuracy)</td></tr>
<tr class="memdesc:a26c394fd79456ebdda335a9493bb5ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy ammount specified.  <a href="class_voxie_box.html#a26c394fd79456ebdda335a9493bb5ee8">More...</a><br /></td></tr>
<tr class="separator:a26c394fd79456ebdda335a9493bb5ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77183817f6b5ea5b61542970b1b58d5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a77183817f6b5ea5b61542970b1b58d5c">pointSame</a> (<a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b, <a class="el" href="structpoint2d.html">point2d</a> accuracy)</td></tr>
<tr class="memdesc:a77183817f6b5ea5b61542970b1b58d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy ammount specified.  <a href="class_voxie_box.html#a77183817f6b5ea5b61542970b1b58d5c">More...</a><br /></td></tr>
<tr class="separator:a77183817f6b5ea5b61542970b1b58d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19897535ef0590f9c88e5fdf9b0bd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a3f19897535ef0590f9c88e5fdf9b0bd9">colorHexDivide</a> (int color, float divideAmount)</td></tr>
<tr class="separator:a3f19897535ef0590f9c88e5fdf9b0bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcbfb676db6668d6f3da9139b5382dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7fcbfb676db6668d6f3da9139b5382dc">tweenCol</a> (int color, int speed, int destcolor)</td></tr>
<tr class="memdesc:a7fcbfb676db6668d6f3da9139b5382dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tweens a color to the destination color. good for fade outs or tweens.  <a href="class_voxie_box.html#a7fcbfb676db6668d6f3da9139b5382dc">More...</a><br /></td></tr>
<tr class="separator:a7fcbfb676db6668d6f3da9139b5382dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2ecdc33fcfccd752bb1614d4dbbeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#af3d2ecdc33fcfccd752bb1614d4dbbeb">brightenCol</a> (int color, int amount)</td></tr>
<tr class="memdesc:af3d2ecdc33fcfccd752bb1614d4dbbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brighten (saturate) a color by adding only RGB values if they are needed.  <a href="class_voxie_box.html#af3d2ecdc33fcfccd752bb1614d4dbbeb">More...</a><br /></td></tr>
<tr class="separator:af3d2ecdc33fcfccd752bb1614d4dbbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86416c1d6137cc2027a5c7934663f3b4"><td class="memItemLeft" align="right" valign="top"><a id="a86416c1d6137cc2027a5c7934663f3b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a86416c1d6137cc2027a5c7934663f3b4">randomCol</a> ()</td></tr>
<tr class="memdesc:a86416c1d6137cc2027a5c7934663f3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a random color based on the RANDOM_COLOR defined in <a class="el" href="vx_data_types_8h.html" title="VX++ data types header contains definitions of all Voxon related structs and types.">vxDataTypes.h</a> <br /></td></tr>
<tr class="separator:a86416c1d6137cc2027a5c7934663f3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad425b1e77b65a3a1131fc281d85a546"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aad425b1e77b65a3a1131fc281d85a546">sphereCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *sphereAPos, double sphereARadius, <a class="el" href="structpoint3d.html">point3d</a> *sphereBPos, double sphereBRadius, bool showCollisionBox=false)</td></tr>
<tr class="memdesc:aad425b1e77b65a3a1131fc281d85a546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere collision check. Check if two spheres are touching. Returns 1 if collision is found otherwise returns 0.  <a href="class_voxie_box.html#aad425b1e77b65a3a1131fc281d85a546">More...</a><br /></td></tr>
<tr class="separator:aad425b1e77b65a3a1131fc281d85a546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b8ee0d69b5f28f90f73a9a21968313"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab6b8ee0d69b5f28f90f73a9a21968313">boxInsideCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *LUTpos, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos, <a class="el" href="structpoint3d.html">point3d</a> collisionPos, bool showCollisionBox=false)</td></tr>
<tr class="memdesc:ab6b8ee0d69b5f28f90f73a9a21968313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box inside collision check. Check if a position is inside a box shape. boxTLU = Top, Left, Up, boxBRD = bottom, right, down.  <a href="class_voxie_box.html#ab6b8ee0d69b5f28f90f73a9a21968313">More...</a><br /></td></tr>
<tr class="separator:ab6b8ee0d69b5f28f90f73a9a21968313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac793efbe7ce15deb9ceddb4da105c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9ac793efbe7ce15deb9ceddb4da105c0">boxCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *LUTpos1, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos1, <a class="el" href="structpoint3d.html">point3d</a> *LUTpos2, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos2, bool showCollisionBox=false)</td></tr>
<tr class="memdesc:a9ac793efbe7ce15deb9ceddb4da105c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box to Box collision check. Check if two box shapes colliding. boxTLU = Top, Left, Up, boxBRD = bottom, right, down.  <a href="class_voxie_box.html#a9ac793efbe7ce15deb9ceddb4da105c0">More...</a><br /></td></tr>
<tr class="separator:a9ac793efbe7ce15deb9ceddb4da105c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8968200374c40be26146b163f5d209"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aec8968200374c40be26146b163f5d209">moveToPos</a> (<a class="el" href="structpoint3d.html">point3d</a> *currentPos, <a class="el" href="structpoint3d.html">point3d</a> destinationPos, float speed, float accuracy)</td></tr>
<tr class="memdesc:aec8968200374c40be26146b163f5d209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates/"moves" a point from the current position towards the destination point. Returns 1 if currentPos collides with destinnationPos otherwise returns a 0. <br  />
  <a href="class_voxie_box.html#aec8968200374c40be26146b163f5d209">More...</a><br /></td></tr>
<tr class="separator:aec8968200374c40be26146b163f5d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195de3f83ede25857dd8c62795cfd970"><td class="memItemLeft" align="right" valign="top"><a id="a195de3f83ede25857dd8c62795cfd970"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a195de3f83ede25857dd8c62795cfd970">rotVex</a> (float angInRaidans, <a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b)</td></tr>
<tr class="memdesc:a195de3f83ede25857dd8c62795cfd970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> vectors a &amp; b around their common plane, by angle expressed in radians. <br /></td></tr>
<tr class="separator:a195de3f83ede25857dd8c62795cfd970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdaa76981d00b5ed6498c54ea0e4f09"><td class="memItemLeft" align="right" valign="top"><a id="aefdaa76981d00b5ed6498c54ea0e4f09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#aefdaa76981d00b5ed6498c54ea0e4f09">rotVexD</a> (float angInDegrees, <a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b)</td></tr>
<tr class="memdesc:aefdaa76981d00b5ed6498c54ea0e4f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> vectors a &amp; b around their common plane, by angle expressed in degrees. <br /></td></tr>
<tr class="separator:aefdaa76981d00b5ed6498c54ea0e4f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd0c907500cddbee805994ca0588097"><td class="memItemLeft" align="right" valign="top"><a id="abcd0c907500cddbee805994ca0588097"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abcd0c907500cddbee805994ca0588097">rotVex</a> (float angInRaidans, <a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b)</td></tr>
<tr class="memdesc:abcd0c907500cddbee805994ca0588097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> vectors a &amp; b around their common plane, by angle expressed in radians. <br /></td></tr>
<tr class="separator:abcd0c907500cddbee805994ca0588097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e6989c622fc7cb86a03bbdf6c4981"><td class="memItemLeft" align="right" valign="top"><a id="ab31e6989c622fc7cb86a03bbdf6c4981"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab31e6989c622fc7cb86a03bbdf6c4981">rotVexD</a> (float angInDegrees, <a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b)</td></tr>
<tr class="memdesc:ab31e6989c622fc7cb86a03bbdf6c4981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> vectors a &amp; b around their common plane, by angle expressed in degrees. <br /></td></tr>
<tr class="separator:ab31e6989c622fc7cb86a03bbdf6c4981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a221c9856e247de0944341960c9ebbb"><td class="memItemLeft" align="right" valign="top"><a id="a1a221c9856e247de0944341960c9ebbb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a1a221c9856e247de0944341960c9ebbb">_kzaddstack</a> (const char *fileName)</td></tr>
<tr class="memdesc:a1a221c9856e247de0944341960c9ebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a1a221c9856e247de0944341960c9ebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9c43aa6cbda15e4f4dac3f8dc3729"><td class="memItemLeft" align="right" valign="top"><a id="ac1d9c43aa6cbda15e4f4dac3f8dc3729"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ac1d9c43aa6cbda15e4f4dac3f8dc3729">_kzuninit</a> ()</td></tr>
<tr class="memdesc:ac1d9c43aa6cbda15e4f4dac3f8dc3729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:ac1d9c43aa6cbda15e4f4dac3f8dc3729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae421e98a34343800aa3dc8cf471e324a"><td class="memItemLeft" align="right" valign="top"><a id="ae421e98a34343800aa3dc8cf471e324a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ae421e98a34343800aa3dc8cf471e324a">_kzsetfil</a> (FILE *fileName)</td></tr>
<tr class="memdesc:ae421e98a34343800aa3dc8cf471e324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:ae421e98a34343800aa3dc8cf471e324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d443a8241a696e30e20f3d4533077e"><td class="memItemLeft" align="right" valign="top"><a id="a80d443a8241a696e30e20f3d4533077e"></a>
INT_PTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a80d443a8241a696e30e20f3d4533077e">_kzopen</a> (const char *st)</td></tr>
<tr class="memdesc:a80d443a8241a696e30e20f3d4533077e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a80d443a8241a696e30e20f3d4533077e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9abdb4addb662885bb04fa5959342"><td class="memItemLeft" align="right" valign="top"><a id="a4df9abdb4addb662885bb04fa5959342"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a4df9abdb4addb662885bb04fa5959342">_kzfindfilestart</a> (const char *st)</td></tr>
<tr class="memdesc:a4df9abdb4addb662885bb04fa5959342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a4df9abdb4addb662885bb04fa5959342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3658452833363b42e2185df980c3ff"><td class="memItemLeft" align="right" valign="top"><a id="a4f3658452833363b42e2185df980c3ff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a4f3658452833363b42e2185df980c3ff">_kzfindfile</a> (kzfind_t *find, <a class="el" href="structkzfileinfo__t.html">kzfileinfo_t</a> *fileinfo)</td></tr>
<tr class="memdesc:a4f3658452833363b42e2185df980c3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a4f3658452833363b42e2185df980c3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c6edb3e89cbfaf226954b77e2fdd0"><td class="memItemLeft" align="right" valign="top"><a id="a7a5c6edb3e89cbfaf226954b77e2fdd0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a7a5c6edb3e89cbfaf226954b77e2fdd0">_kzread</a> (kzfile_t *kzfile, void *buffer, unsigned int leng)</td></tr>
<tr class="memdesc:a7a5c6edb3e89cbfaf226954b77e2fdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a7a5c6edb3e89cbfaf226954b77e2fdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358d2d0e5dbdf95b1361298bc1844293"><td class="memItemLeft" align="right" valign="top"><a id="a358d2d0e5dbdf95b1361298bc1844293"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a358d2d0e5dbdf95b1361298bc1844293">_kzfilelength</a> (kzfile_t *kzfile)</td></tr>
<tr class="memdesc:a358d2d0e5dbdf95b1361298bc1844293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a358d2d0e5dbdf95b1361298bc1844293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2059d1b5eaf47f9fc5e6a86bc13cd2"><td class="memItemLeft" align="right" valign="top"><a id="a9b2059d1b5eaf47f9fc5e6a86bc13cd2"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a9b2059d1b5eaf47f9fc5e6a86bc13cd2">_kztell</a> (kzfile_t *kzfile)</td></tr>
<tr class="memdesc:a9b2059d1b5eaf47f9fc5e6a86bc13cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a9b2059d1b5eaf47f9fc5e6a86bc13cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911600747379ce7293fe04e5db4886de"><td class="memItemLeft" align="right" valign="top"><a id="a911600747379ce7293fe04e5db4886de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a911600747379ce7293fe04e5db4886de">_kzseek</a> (kzfile_t *kzfile, int offset, int whence)</td></tr>
<tr class="memdesc:a911600747379ce7293fe04e5db4886de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a911600747379ce7293fe04e5db4886de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28ceca8a1259cd8a22a5b644bb6056f"><td class="memItemLeft" align="right" valign="top"><a id="ab28ceca8a1259cd8a22a5b644bb6056f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#ab28ceca8a1259cd8a22a5b644bb6056f">_kzgetc</a> (kzfile_t *kzfile)</td></tr>
<tr class="memdesc:ab28ceca8a1259cd8a22a5b644bb6056f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:ab28ceca8a1259cd8a22a5b644bb6056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf03170ecdd80dc684bcf8da60eaec9b"><td class="memItemLeft" align="right" valign="top"><a id="acf03170ecdd80dc684bcf8da60eaec9b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#acf03170ecdd80dc684bcf8da60eaec9b">_kzeof</a> (kzfile_t *kzfile)</td></tr>
<tr class="memdesc:acf03170ecdd80dc684bcf8da60eaec9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:acf03170ecdd80dc684bcf8da60eaec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18743fd056d8d808dbacac8ca4f85c80"><td class="memItemLeft" align="right" valign="top"><a id="a18743fd056d8d808dbacac8ca4f85c80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a18743fd056d8d808dbacac8ca4f85c80">_kzclose</a> (kzfile_t *kzfile)</td></tr>
<tr class="memdesc:a18743fd056d8d808dbacac8ca4f85c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:a18743fd056d8d808dbacac8ca4f85c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6a1b69a3f260b8217d34e417c760e2"><td class="memItemLeft" align="right" valign="top"><a id="a0d6a1b69a3f260b8217d34e417c760e2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a0d6a1b69a3f260b8217d34e417c760e2">_kpgetdim</a> (const char *buffer, int nby, int *xsiz, int *ysiz)</td></tr>
<tr class="memdesc:a0d6a1b69a3f260b8217d34e417c760e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing image files. <br /></td></tr>
<tr class="separator:a0d6a1b69a3f260b8217d34e417c760e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82abf8d443c2bb3c0634d3b42f016129"><td class="memItemLeft" align="right" valign="top"><a id="a82abf8d443c2bb3c0634d3b42f016129"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#a82abf8d443c2bb3c0634d3b42f016129">_kprender</a> (const char *buffer, int nby, INT_PTR fptr, int bpl, int xsiz, int ysiz, int xoff, int yoff)</td></tr>
<tr class="memdesc:a82abf8d443c2bb3c0634d3b42f016129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing image files. <br /></td></tr>
<tr class="separator:a82abf8d443c2bb3c0634d3b42f016129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66c2fec1770dcbb665f191a3bde2ed"><td class="memItemLeft" align="right" valign="top"><a id="abb66c2fec1770dcbb665f191a3bde2ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_voxie_box.html#abb66c2fec1770dcbb665f191a3bde2ed">_kpzload</a> (const char *fileName, INT_PTR *fptr, INT_PTR *bpl, INT_PTR *xsiz, INT_PTR *ysiz)</td></tr>
<tr class="memdesc:abb66c2fec1770dcbb665f191a3bde2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function for managing zip files. <br /></td></tr>
<tr class="separator:abb66c2fec1770dcbb665f191a3bde2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class. </p>
<p>Voxiebox.dll into a <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class.</p>
<p>All voxiebox.dll functions presented as class with additional helper functions included.</p>
<p>The <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class is all the voxiebox.dll functions, helper functions and internal variables to manage a Voxon volumetric application. <br  />
 The <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class can be interfaced with the <a class="el" href="class_i_voxie_box.html" title="Interface for VoxieBox class.">IVoxieBox</a> and used a pointer reference This allows the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class to be used with OO principals and C++ development easier for Voxon applications. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06195dca9603ea448f72d502808384b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06195dca9603ea448f72d502808384b2">&#9670;&nbsp;</a></span>VoxieBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VoxieBox::VoxieBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> constructor checks to see if another instance of <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> has been created. </p>
<p>If not; then loads the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct (vw) into memory. Then calls <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:<a class="el" href="class_voxie_box.html#a9df7e95b7c877b5942690affef94d4a6" title="Initalises and updates voxiebox.dll&#39;s voxie window (voxie_wind_t)">init()</a> &amp; initialise the data, loads settings from voxiebox.ini and voxie_menu_0.ini <br  />
 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ac793efbe7ce15deb9ceddb4da105c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac793efbe7ce15deb9ceddb4da105c0">&#9670;&nbsp;</a></span>boxCollideChk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::boxCollideChk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>LUTpos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>RDBpos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>LUTpos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>RDBpos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showCollisionBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Box to Box collision check. Check if two box shapes colliding. boxTLU = Top, Left, Up, boxBRD = bottom, right, down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUTpos</td><td>pointer to the Left, Up, Top position of the first box. </td></tr>
    <tr><td class="paramname">RDBpos</td><td>pointer to the Right, Down, Bottom position of the first box. </td></tr>
    <tr><td class="paramname">LUTpos</td><td>pointer to the Left, Up, Top position of the second box. </td></tr>
    <tr><td class="paramname">RDBpos</td><td>pointer to the Right, Down, Bottom position of the second box. </td></tr>
    <tr><td class="paramname">showCollisionBox</td><td>For debugging set to false by default. Set to true to render the collision box onto the volumetric display. (Note : The collision check must be called within the start and end frame)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if collision position is within (inside) the box otherwise returns 0 To check to just see if a position is inside of a box use boxInsideCollidChk() </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a6770c0826e853800e4b1c218ac29c58f">IVoxieBox</a>.</p>

</div>
</div>
<a id="ab6b8ee0d69b5f28f90f73a9a21968313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b8ee0d69b5f28f90f73a9a21968313">&#9670;&nbsp;</a></span>boxInsideCollideChk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::boxInsideCollideChk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>LUTpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>RDBpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>collisionPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showCollisionBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Box inside collision check. Check if a position is inside a box shape. boxTLU = Top, Left, Up, boxBRD = bottom, right, down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUTpos</td><td>pointer to the Left, Up, Top position of the box. </td></tr>
    <tr><td class="paramname">RDBpos</td><td>pointer to the Right, Down, Bottom position of the box. </td></tr>
    <tr><td class="paramname">collisionPos</td><td>the collision position to check. </td></tr>
    <tr><td class="paramname">showCollisionBox</td><td>For debugging set to false by default. Set to true to render the collision box onto the volumetric display. (Note : The collision check must be called within the start and end frame)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if collision position is within (inside) the box otherwise returns 0 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a7687f3274f6f8c7ff2b875ea45b1d136">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0cd2ee2048f4b560910621c693709270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd2ee2048f4b560910621c693709270">&#9670;&nbsp;</a></span>breath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::breath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The 'update loop' for a VX application also updates <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> struct. </p>
<p>Call this once per frame to update variables in voxie_inputs_t structure. returns typically returns a 1. returns a 0 when the program wants to quit. run as a while loop " while (voxiebox::breath() )" using <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> with no parameters uses internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> structure (in) to input updates.</p>
<p>Note the VxCpp version of <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> also updates: the internal timers, checks if the hardware is a rotating or up / down display, calls other input checks (for nav, joy and keyboard), listens for key input to rotate the emulator screen, and the 'Esc' key to quit the application, tracks the mouse position and updates the rainbow color variable. (most of) These are common tasks a typical VX developer would have to do themselves.</p>
<dl class="section return"><dt>Returns</dt><dd>typically returns a 1, returns a 0 when the program wants to quit. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af0814d9392e461322f177e41026754e8">IVoxieBox</a>.</p>

</div>
</div>
<a id="af0fc4d29059d67c2df643073bd02b3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fc4d29059d67c2df643073bd02b3c9">&#9670;&nbsp;</a></span>breath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::breath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A breath is a complete volume sweep. </p>
<p>Call this once per frame to update variables in voxie_inputs_t structure. returns typically returns a 1. returns a 0 when the program wants to quit. run as a while loop " while (voxiebox::breath() )" using <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> with no parameters uses internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> structure(in) to input updates.</p>
<p>Note the VxCpp version of <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> also updates: the internal timers, checks if the hardware is a rotating or up / down display, calls other input checks (for nav, joy and keyboard), listens for key input to rotate the emulator screen, and the 'Esc' key to quit the application, tracks the mouse position and updates the rainbow color variable. (most of) These are common tasks a typical VX developer would have to do themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>pointer to the voxie_inputs_t to update the input state ( <a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_inputs_t()</a> manages the mouse input ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>typically returns a 1, returns a 0 when the program wants to quit. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#abadd2a46b41c146060e1c8e3a9f265af">IVoxieBox</a>.</p>

</div>
</div>
<a id="af3d2ecdc33fcfccd752bb1614d4dbbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d2ecdc33fcfccd752bb1614d4dbbeb">&#9670;&nbsp;</a></span>brightenCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::brightenCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Brighten (saturate) a color by adding only RGB values if they are needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>the color value to brighten </td></tr>
    <tr><td class="paramname">amount</td><td>the amount of color to add range (0 - 255) each value is 1 hex value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new brightened color value. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="a029bd84f038b1716b05e40d7ad7adecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029bd84f038b1716b05e40d7ad7adecd">&#9670;&nbsp;</a></span>captureVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::captureVolume </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volumeCaptureMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetVPS</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a capture of the volumetric buffer to occur on the next frame, or video capture to start /stop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the file name of the capture - if null writes to the next available nonexistent numbered file: VOXIE0000.PNG, VOXIE0001.PNG, .. </td></tr>
    <tr><td class="paramname">volumeCaptureMode</td><td>the capture mode to use. Off (Stop recording) = 0, Single PLY = 1, Single PNG = 2, Single REC = 3, Video Rec = 4, Single VCB = 5, Video VCB = 6; </td></tr>
    <tr><td class="paramname">targetVPS</td><td>if Note : If fileName is NULL, writes to the next available nonexistent numbered file: VOXIE0000.PNG, VOXIE0001.PNG, .. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab4d60ee7b816a989268ad51acde83678">IVoxieBox</a>.</p>

</div>
</div>
<a id="a91f4a5ab82b92bef56f68004f11c62d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f4a5ab82b92bef56f68004f11c62d0">&#9670;&nbsp;</a></span>captureVolumeAsPly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::captureVolumeAsPly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PLY file. </p>
<p>Writes to the next available nonexistent numbered file: VOXIE0000.PNG, VOXIE0001.PNG, .. will output in the current .exe folder unless VoxieBox.ini contains "volcapdir=" variable where a custom output directory can be set (default for voxiebox.ini is "volcapdir=c:\voxon\media\MyCaptures\" </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a9587e0673776b7c76fac23724a518110">IVoxieBox</a>.</p>

</div>
</div>
<a id="aad0fd4cfab9f4e1ec8a6acb6c5680efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0fd4cfab9f4e1ec8a6acb6c5680efb">&#9670;&nbsp;</a></span>captureVolumeAsPng()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::captureVolumeAsPng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PNG file. </p>
<p>Writes to the next available nonexistent numbered file: VOXIE0000.PNG, VOXIE0001.PNG, .. will output in the current .exe folder unless VoxieBox.ini contains "volcapdir=" variable where a custom output directory can be set (default for voxiebox.ini is "volcapdir=c:\voxon\media\MyCaptures\" </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a9bc8d74514430fe346055b6bf1a84055">IVoxieBox</a>.</p>

</div>
</div>
<a id="afbab6ff6b07e15a38ad5a4127f32f246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab6ff6b07e15a38ad5a4127f32f246">&#9670;&nbsp;</a></span>clipInsideVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::clipInsideVolume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clips a point to ensures it is within the volumes display's bounds. </p>
<p>Adjust a point if it is outside of the volume. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>pointer of the <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> to check </td></tr>
    <tr><td class="paramname">radius</td><td>the size of radius to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in bits of what dimension is outside the range for Up/Down 1st bit x, 2nd bit y, 3rd bit z. For Spinner 1st bit x or y, 2nd bit z </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a9b4dc27ae10877c6aaacd55bce7b825e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a3f19897535ef0590f9c88e5fdf9b0bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f19897535ef0590f9c88e5fdf9b0bd9">&#9670;&nbsp;</a></span>colorHexDivide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::colorHexDivide </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>divideAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>the RGB hexidemical color to scale down </td></tr>
    <tr><td class="paramname">divideAmount</td><td>the mount to divide the color value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new scaled down color value as an RGB hexidemical color value. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a0adc7e9b3038b5e2259f2acd39232e98">IVoxieBox</a>.</p>

</div>
</div>
<a id="a1ad21357a77e4e93ce528eed7d42d865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad21357a77e4e93ce528eed7d42d865">&#9670;&nbsp;</a></span>debugBar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::debugBar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currentVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a vertical bar for help tracking variables onto the secondary (touch) screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posx</td><td>the x position for the debug bar </td></tr>
    <tr><td class="paramname">posy</td><td>the y position for the debug bar </td></tr>
    <tr><td class="paramname">currentVal</td><td>the current value (the variable you want to track) to pass to the debug bar </td></tr>
    <tr><td class="paramname">maxVal</td><td>the max value to render to the debug bar </td></tr>
    <tr><td class="paramname">minVal</td><td>the min value to render to the debug bar </td></tr>
    <tr><td class="paramname">text</td><td>any text to place with the debug bar (the title) </td></tr>
    <tr><td class="paramname">type</td><td>the type of debug bar. 0 = default closer to max value is 'good'. 1 = closer to max value is 'bad', 2 = mini bar (smaller version with no text), 3 = mini bar centered at 0 for results that can be postive and negative</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a float which is a percentage of how close the currentVal is to the maxVal </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a54467a9435d9213382bd1b08ee3537f2">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad4260b53e8e28020fcf22e7a00700ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4260b53e8e28020fcf22e7a00700ab6">&#9670;&nbsp;</a></span>debugDrawBoxFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawBoxFill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw filled rectangle on the secondary (touch) screen. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xStartPos</td><td>left most starting position of box </td></tr>
    <tr><td class="paramname">yStartPos</td><td>top most starting position of box </td></tr>
    <tr><td class="paramname">xEndPos</td><td>right most ending position of box </td></tr>
    <tr><td class="paramname">yEndPos</td><td>bottom most ending position of box </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexadecimal RGB color value </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a70dd8950c07fb19ea767125d724d924f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a65b2b2fe7c553bcb274b970f9d504dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b2b2fe7c553bcb274b970f9d504dff">&#9670;&nbsp;</a></span>debugDrawCircFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawCircFill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xCenterPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yCenterPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw filled circle on the secondary (touch) screen. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xCenterPos</td><td>x horizontal circle's center position </td></tr>
    <tr><td class="paramname">yCenterPos</td><td>y vertical circle's center position </td></tr>
    <tr><td class="paramname">radius</td><td>radius of circle. Size in pixels </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexadecimal RGB color value </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aa24dd42295b886eb9e576eb5813fe6f5">IVoxieBox</a>.</p>

</div>
</div>
<a id="a42835e3e2ca19a63a05d4c4a1f8c3e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42835e3e2ca19a63a05d4c4a1f8c3e0a">&#9670;&nbsp;</a></span>debugDrawCircle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawCircle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xCenterPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yCenterPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw circle on the secondary (touch) screen. </p>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>y coordinate of the circle's center. </td></tr>
    <tr><td class="paramname">x</td><td>x coordinate of the circle's center. </td></tr>
    <tr><td class="paramname">radius</td><td>radius size in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>24-bit RGB color of the line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af1f50d77e22fbaf7261869504388931e">IVoxieBox</a>.</p>

</div>
</div>
<a id="acc65918047afd0334740143fdd17f376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc65918047afd0334740143fdd17f376">&#9670;&nbsp;</a></span>debugDrawHLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawHLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws horizontal line on the secondary (touch) screen. </p>
<p>Drawing is always from left to right. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xStartPos</td><td>coordinate of the starting x pixel. Needs to be the left most pixel. </td></tr>
    <tr><td class="paramname">xEndPos</td><td>coordinate of the ending x pixel. Needs to be the right most pixel. </td></tr>
    <tr><td class="paramname">y</td><td>coordinate of the y pixel. Where the line is drawn on the y axis. </td></tr>
    <tr><td class="paramname">col</td><td>24-bit RGB color of the line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae2257f7413272cdb6ade0f7e62886b62">IVoxieBox</a>.</p>

</div>
</div>
<a id="a5fbf2b1c07262976e4ab3dc1dc09ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbf2b1c07262976e4ab3dc1dc09ac27">&#9670;&nbsp;</a></span>debugDrawLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawLine </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a line on the secondary (touch) screen. </p>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xStartPos</td><td>coordinate of the starting x pixel. Needs to be the left most pixel. </td></tr>
    <tr><td class="paramname">xEndPos</td><td>coordinate of the ending x pixel. Needs to be the right most pixel. </td></tr>
    <tr><td class="paramname">yStartPos</td><td>coordinate of the starting y pixel. Needs to be the left most pixel. </td></tr>
    <tr><td class="paramname">yEndPos</td><td>coordinate of the ending y pixel. Needs to be the right most pixel. </td></tr>
    <tr><td class="paramname">col</td><td>24-bit RGB color of the line. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a20ba4f6c944b21722d247b89a7c6f36f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a53324f4cc479337b7d6ff456655284c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53324f4cc479337b7d6ff456655284c2">&#9670;&nbsp;</a></span>debugDrawPix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawPix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws single pixel on the secondary (touch) screen. </p>
<p>Must be called within the <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x position of pixel location </td></tr>
    <tr><td class="paramname">y</td><td>y position of pixel location </td></tr>
    <tr><td class="paramname">col</td><td>24-bit RGB color </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a75d9281d2937cda6c6e193cb8ad8493a">IVoxieBox</a>.</p>

</div>
</div>
<a id="adb236e81acb2b909dfa7bc67d70b5c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb236e81acb2b909dfa7bc67d70b5c07">&#9670;&nbsp;</a></span>debugDrawTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugDrawTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtiletype.html">tiletype</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ypos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a texture onto the secondary (touch) screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiletype</td><td>* source pointer to a tile type <br  />
 </td></tr>
    <tr><td class="paramname">int</td><td>xpos the x position to render onto the secondary (touch) screen </td></tr>
    <tr><td class="paramname">int</td><td>ypos the y position to render onto the secondary (touch) screen</td></tr>
  </table>
  </dd>
</dl>
<p>Tile must be fully within bounds of screen. </p><pre class="fragment">                    Note :  Alpha bytes (bits 24-31) of source pixels control what's drawn:
                    0: fully transparent (pixel is ignored)
                    1-254: blending in between (NOTE: will render slower than 0 or 255)
                    255: fully opaque (pixel is copied to screen)

                    @Example on how to create a tile type data (the pure pixel data from an image

                    // how to create a tile type to show onto the 2D screen.
                        tiletype example;                               // define new tiletype type
                    example.x = 800;                                // get the image's x dimension (look at the details of the file - Windows explorer -&gt; properties)
                    example.y = 600;                                // get the image's y dimension (look at the details of the file - Windows explorer -&gt; properties)
                    example.p = (example.x&lt;&lt;2);                     // define the pitch number of bytes per horizontal line (usually x*4 but may be higher or negative)
                    example.f = (INT_PTR)malloc(balls.p*balls.y);   // create pointer to 1st pixel
                    voxie-&gt;_kpzload((char*)"example.jpg", &amp;example.f, &amp;example.p, &amp;example.x, &amp;example.y);      // load the image into file memory pass in the pointers

                    to render your tiletype unto the 2D display call 
                    voxie-&gt;debugDrawTile(&amp;example, xposition, yposition);
</pre> 
<p>Implements <a class="el" href="class_i_voxie_box.html#ad79e32860cfac14a5a124dda8b4ec44e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6dfb9b33cbc83e033b8db9f73e763c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfb9b33cbc83e033b8db9f73e763c1c">&#9670;&nbsp;</a></span>debugText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::debugText </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>display text and/or variables unto to secondary (touch) screen. Supports in printf() format specifiers. -1 for transparent color </p>
<pre class="fragment">    @example debugText(100,100, 0xffffff, -1, "Interger value %d, float value %1.2f", myInt, myFloat);
       would display a white text message 100 pixels from the left and 100 pixels from the top of touch the screen. 
    The message will say "Interger value X, float value Y" with X and Y being the values of those variables. 
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x position to render text on the secondary (touch) screen </td></tr>
    <tr><td class="paramname">y</td><td>y position to render text on the secondary (touch) screen </td></tr>
    <tr><td class="paramname">fcol</td><td>foreground color expressed as hexdemical value (RGB) (-1 to indicate transparent) </td></tr>
    <tr><td class="paramname">bcol</td><td>background color expressed as hexdemical value (RGB) (-1 to indicate transparent) </td></tr>
    <tr><td class="paramname">fmt</td><td>ASCII null terminated text string (must be pre-formatted by caller).</td></tr>
  </table>
  </dd>
</dl>
<p>Note: must be called within the start and end of the frame functions to appear. <br  />
 </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a74b422c7e3d78991b25d875b52e13e27">IVoxieBox</a>.</p>

</div>
</div>
<a id="a59a482189e5a8d97f41e99d6ac6cfbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a482189e5a8d97f41e99d6ac6cfbdd">&#9670;&nbsp;</a></span>drawBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>posLeftUpTop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>posRightDownBottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a rectangle / box on the volumetric display using 2 point3ds for coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posLeftUpTop</td><td>left up top corner of the box </td></tr>
    <tr><td class="paramname">posRightDownBottom</td><td>bottom, right, down corner of the box </td></tr>
    <tr><td class="paramname">fillmode</td><td>The fillmode type 0:dots, 1:lines, 2:surfaces, 3:solid </td></tr>
    <tr><td class="paramname">col</td><td>RGB 24-bit hexidemical color value</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a03d4968628a24bafafedc4908433a351">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8e2f4ea3e418f3c33c8ff0a9d4a74167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2f4ea3e418f3c33c8ff0a9d4a74167">&#9670;&nbsp;</a></span>drawCone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawCone </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 6 floats for coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xStartPos</td><td>the x position of starting point (1st sphere) </td></tr>
    <tr><td class="paramname">yStartPos</td><td>the y position of starting point (1st sphere) </td></tr>
    <tr><td class="paramname">zStartPos</td><td>the z position of starting point (1st sphere) </td></tr>
    <tr><td class="paramname">startRadius</td><td>the radius size of the starting point (1st sphere) </td></tr>
    <tr><td class="paramname">xEndPos</td><td>the x position of ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">yEndPos</td><td>the y position of ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">zEndPos</td><td>the z position of ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">endRadius</td><td>the radius size of the ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">fillmode</td><td>the type of fill 0=shell, 1=solid filled </td></tr>
    <tr><td class="paramname">col</td><td>RGB 24-bit color</td></tr>
  </table>
  </dd>
</dl>
<p>Shape is basically two spheres connected together like a tube.</p>
<p>Note: be careful with using the solid filled (fillmode 1) type as it can quite a performance hit. (draws many voxels) Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a7642a7a9e61f0eab8c906d1862ac67e4">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae708b7fe0ae0cd81fbae7ae66aaed4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae708b7fe0ae0cd81fbae7ae66aaed4b4">&#9670;&nbsp;</a></span>drawCone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawCone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 2 point3ds for coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td>the x,y,z position of starting point (1st sphere) </td></tr>
    <tr><td class="paramname">startRadius</td><td>the radius size of the starting point (1st sphere) </td></tr>
    <tr><td class="paramname">endPos</td><td>the x,y,z position of ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">endRadius</td><td>the radius size of the ending point (2nd sphere) </td></tr>
    <tr><td class="paramname">fillmode</td><td>the type of fill 0=shell, 1=solid filled </td></tr>
    <tr><td class="paramname">col</td><td>RGB 24-bit color</td></tr>
  </table>
  </dd>
</dl>
<p>Shape is basically two spheres connected together like a tube.</p>
<p>Note: be careful with using the solid filled (fillmode 1) type as it can quite a performance hit. (draws many voxels) Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a2583f5a4cc4cc56b3dd26e2bf1d044a1">IVoxieBox</a>.</p>

</div>
</div>
<a id="a9a32fa6674e482fb2347e213604bb404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a32fa6674e482fb2347e213604bb404">&#9670;&nbsp;</a></span>drawCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>rVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>dVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>fVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a cube using specified vectors to volumetric display. Similar to <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:<a class="el" href="class_voxie_box.html#a21acf498b44f568ba6a01ff6bb7b13d4" title="Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display.">drawModel()</a> but only draws a cube. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>position for left-up-top corner </td></tr>
    <tr><td class="paramname">rVector</td><td>right vector </td></tr>
    <tr><td class="paramname">dVector</td><td>down vector </td></tr>
    <tr><td class="paramname">fVector</td><td>forward vector </td></tr>
    <tr><td class="paramname">fillmode</td><td>0:dots, 1:edges/wireframe, 2:surfaces, 3:solid filled </td></tr>
    <tr><td class="paramname">col</td><td>24-bit color as RGB hexadecimal</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a864f0cd3a5b55e11b31551fa8ac4fcc5">IVoxieBox</a>.</p>

</div>
</div>
<a id="aa1a30340112a8c0b2096209367d3a839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a30340112a8c0b2096209367d3a839">&#9670;&nbsp;</a></span>drawCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawCursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>draws a cursor unto the volumetric display at the position specified. <br  />
 </p>
<p>Draws a cursor on the display based on various input types that can be used. Supports custom positions or Mouse, Gamepad or SpaceNav </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the cursor to track </td></tr>
    <tr><td class="paramname">inputType</td><td>the input type (0 is mouse, 1 is spaceNav, 2 is Joystick, 3 is all three, 4 is none, 5 is filled state (so you can make your own) ) </td></tr>
    <tr><td class="paramname">inputID</td><td>the idenfication number of the input type (which SpaceNav or Joystick?) </td></tr>
    <tr><td class="paramname">col</td><td>the color of the cursor</td></tr>
  </table>
  </dd>
</dl>
<p>Note : as with all drawing calls, Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8a1ddebc86b80d60b74cd5613bb1a88c">IVoxieBox</a>.</p>

</div>
</div>
<a id="a2364111ffd69401b54067d8172165ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2364111ffd69401b54067d8172165ed5">&#9670;&nbsp;</a></span>drawHeightMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::drawHeightMap </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>rVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>dVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>fVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colorKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a heightmap (.jpg, .png or tiletype data) onto the volumetric display. </p>
<p>A heightmap is a 2D image which also contains a height channel along side it. Open up some of the heightmap examples for a demo. Demview uses them to render all its information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>filename or pointer to 2d array containing image &amp; heightmap stored alpha channel. </td></tr>
    <tr><td class="paramname">pos</td><td>the position of the top-left corner of the heightmap. </td></tr>
    <tr><td class="paramname">rVector</td><td>the right vector. rVector.x indicates how wide the height map is also holds rotational data </td></tr>
    <tr><td class="paramname">dVector</td><td>the down vector. rVector.y indicates how long the height map is also holds rotational data </td></tr>
    <tr><td class="paramname">fVector</td><td>the forward vector. fVector.z indicates the height the height map it also holds rotational data @ </td></tr>
    <tr><td class="paramname">colorkey</td><td>ARGB 32-bit color to be transparent (supported in nearest mode only) </td></tr>
    <tr><td class="paramname">flags</td><td>various flags to adjust render settings. see flags examples. <pre class="fragment">             @example of different flag settings to use
             (1&lt;&lt;0): reserved (height dither now controlled by vw.dither)
             (1&lt;&lt;1): 0=nearest filter , 1=bilinear filter  (recommended)
             (1&lt;&lt;2): 0=color dither off , 1=color dither on  (recommended)
             (1&lt;&lt;3): 0=filnam is filename string, 1=filnam is tiletype * or pointer to 2d array.
             (1&lt;&lt;4): 0=texture clamp    , 1=texture wrap
             (1&lt;&lt;5): 0=8-bit height     , 1=mapzen.com terrarium style height
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Note : about scaling and sizing the rVector.z, dVector.z, fVector.x, fVector.y are all not used to render the heightMap but their values are important for storing rotational information. the height / scale of the heightmap is the difference between pos.z and fVector.z values. pos.z is height=0, pos.z+fVector.z is height=255</p>
<dl class="section return"><dt>Returns</dt><dd>average height in middle region, range:{0..255} Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a34b200f89ba0ec2c92a1a7e10c761d83">IVoxieBox</a>.</p>

</div>
</div>
<a id="ace0b3d35798ed4d74058e03d58634e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0b3d35798ed4d74058e03d58634e03">&#9670;&nbsp;</a></span>drawLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawLine </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a line on the volumetric display using 6 floats for coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xStartPos</td><td>x position for 1st (starting) point </td></tr>
    <tr><td class="paramname">yStartPos</td><td>y position for 1st (starting) point </td></tr>
    <tr><td class="paramname">zStartPos</td><td>z position for 1st (starting) point </td></tr>
    <tr><td class="paramname">xEndPos</td><td>x position for 2nd (ending) point </td></tr>
    <tr><td class="paramname">yEndPos</td><td>y position for 2nd (ending) point </td></tr>
    <tr><td class="paramname">zEndPos</td><td>z position for 2nd (ending) point </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexidemical color value (RGB)</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a35934307729ad81b2871ee342f7031c5">IVoxieBox</a>.</p>

</div>
</div>
<a id="a057a91a5fbcb7dac98bae94214fe757c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057a91a5fbcb7dac98bae94214fe757c">&#9670;&nbsp;</a></span>drawLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>startPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>endPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a line on the volumetric display using <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPos</td><td><a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of first (starting) position. </td></tr>
    <tr><td class="paramname">endPos</td><td><a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of second (end) position.</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a83ea84e318c1e5178abac5c66f883d70">IVoxieBox</a>.</p>

</div>
</div>
<a id="aab94cfd1251732ff5bcb5a3aa2d13d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94cfd1251732ff5bcb5a3aa2d13d4d">&#9670;&nbsp;</a></span>drawMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawMesh </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoltex__t.html">poltex_t</a> *&#160;</td>
          <td class="paramname"><em>verticeList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verticeNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>meshList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a mesh from a list of vertices can render in as dots, lines, polygons, or filled mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileNam</td><td>texture filename or pointer to tiletype structure if (flags&amp;8) or leave null for no texture Be sure to fill .u and .v fields of <a class="el" href="structpoltex__t.html" title="3D point with texture coordinate and color (ARGB32). Used by VoxieBox::drawMesh()">poltex_t</a> when using a texture. </td></tr>
    <tr><td class="paramname">verticeList</td><td>pointer to the list of vertices array (as a <a class="el" href="structpoltex__t.html" title="3D point with texture coordinate and color (ARGB32). Used by VoxieBox::drawMesh()">poltex_t</a> data type) </td></tr>
    <tr><td class="paramname">verticeNum</td><td>max number of vertices in the vertices array </td></tr>
    <tr><td class="paramname">meshList</td><td>pointer to the list of facets as vertex indices or -1 to end current primitive and start next one, -2 to end loop </td></tr>
    <tr><td class="paramname">meshNum</td><td>number of entries in mesh array </td></tr>
    <tr><td class="paramname">flags</td><td>mosty fill mode and texture settings +0:dots, +1:lines, +2:surfaces, +3:solid, +8:texnam is tiletype * instead of filename </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexidemical color value (RGB) <pre class="fragment">    @example

     //Example for fillmode 0 (dots) mesh and meshn are ignored - pass 0's in their place.
     poltex_t vt[4]; int i = 0;
     vt[0].x =-0.8; vt[0].y =-0.8; vt[0].z = 0.0; vt[0].col = 0xffffff;
     vt[1].x =+0.8; vt[1].y =+0.8; vt[1].z = 0.0; vt[1].col = 0xffffff;
     vt[2].x =-0.8; vt[2].y =+0.8; vt[2].z = 0.0; vt[2].col = 0xffffff;
     vt[3].x =+0.8; vt[3].y =-0.8; vt[3].z = 0.0; vt[3].col = 0xffffff;
     voxie_drawmeshtex(&amp;vf,0,vt,4,0,0,0,0xffffff);

     //Example for fillmode 1 (line list): wireframe 'X'
     poltex_t vt[4]; int mesh[6]; i = 0;
     vt[0].x =-0.8; vt[0].y =-0.8; vt[0].z = 0.0; vt[0].col = 0xffffff;
     vt[1].x =+0.8; vt[1].y =+0.8; vt[1].z = 0.0; vt[1].col = 0xffffff;
     vt[2].x =-0.8; vt[2].y =+0.8; vt[2].z = 0.0; vt[2].col = 0xffffff;
     vt[3].x =+0.8; vt[3].y =-0.8; vt[3].z = 0.0; vt[3].col = 0xffffff;
     mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = -1; //-1 = end of line sequence
     mesh[i++] = 2; mesh[i++] = 3; mesh[i++] = -1;
     voxie_drawmeshtex(&amp;vf,0,vt,4,mesh,i,1,0xffffff);

     //Example for fillmode 2 (polygon list) or fillmode 3 (solid filled): tetrahedron
     poltex_t vt[4]; int mesh[16], i = 0;
     vt[0].x =-0.4; vt[0].y =-0.4; vt[0].z =-0.4; vt[0].col = 0xffffff;
     vt[1].x =-0.4; vt[1].y =+0.4; vt[1].z =+0.4; vt[1].col = 0xffffff;
     vt[2].x =+0.4; vt[2].y =-0.4; vt[2].z =+0.4; vt[2].col = 0xffffff;
     vt[3].x =+0.4; vt[3].y =+0.4; vt[3].z =-0.4; vt[3].col = 0xffffff;
     mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = 2; mesh[i++] = -1; //-1 = end of polygonal facet
     mesh[i++] = 1; mesh[i++] = 0; mesh[i++] = 3; mesh[i++] = -1;
     mesh[i++] = 2; mesh[i++] = 1; mesh[i++] = 3; mesh[i++] = -1;
     mesh[i++] = 0; mesh[i++] = 2; mesh[i++] = 3; mesh[i++] = -1; 
     voxie_drawmeshtex(&amp;vf,0,vt,4,mesh,i,2 (or 3) ,0xffffff);

     //Example for fillmode 2 (complex poly w/hole: 2-triangle donut)
     poltex_t vt[6]; int mesh[8], i = 0;
     vt[0].x =-0.75; vt[0].y =+0.50; vt[0].z = 0.0; vt[0].col = 0xffffff;  //     / \
     vt[1].x = 0.00; vt[1].y =-0.75; vt[1].z = 0.0; vt[1].col = 0xffffff;  //    / . \
     vt[2].x =+0.75; vt[2].y =+0.50; vt[2].z = 0.0; vt[2].col = 0xffffff;  //   / /_\ \
     vt[3].x =-0.25; vt[3].y =+0.25; vt[3].z = 0.0; vt[3].col = 0xffffff;  //  /       \
     vt[4].x = 0.00; vt[4].y =-0.25; vt[4].z = 0.0; vt[4].col = 0xffffff;  // /---------\
     vt[5].x =+0.25; vt[5].y =+0.25; vt[5].z = 0.0; vt[5].col = 0xffffff;
     mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = 2; mesh[i++] = -2; //-2 = end loop
     mesh[i++] = 3; mesh[i++] = 4; mesh[i++] = 5; mesh[i++] = -1; //-1 = end polygonal facet
     voxie_drawmeshtex(&amp;vf,0,vt,4,mesh,i,2 (or 3),0xffffff);
</pre> Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af3117fc00bdda31f169586de339d336d">IVoxieBox</a>.</p>

</div>
</div>
<a id="a21acf498b44f568ba6a01ff6bb7b13d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21acf498b44f568ba6a01ff6bb7b13d4">&#9670;&nbsp;</a></span>drawModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::drawModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>rVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>dVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>fVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0x404040</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display. </p>
<p>known as voxie_drawspr ("draw sprite") in the voxiebox.h / voxiebox.dll. Renamed to "draw model" as a more apt description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>filename. Cached internally. Currently supports .KV6,.STL,.OBJ,.PLY </td></tr>
    <tr><td class="paramname">pos</td><td>position of center of model (pivot) </td></tr>
    <tr><td class="paramname">rVector</td><td>right vector set to {1,0,0} for a un warped normal view </td></tr>
    <tr><td class="paramname">dVector</td><td>down vector set to {0,1,0} for an un warped normal view </td></tr>
    <tr><td class="paramname">fVector</td><td>forward vector set to {0,0,1} for an un warped normal view </td></tr>
    <tr><td class="paramname">col</td><td>color multiplier. 24-bit color, each 8 bits scales intensity of respective component. 64=1.0 or no scale. Use 0x404040 for no change; 0x808080 to draw as double brightness, etc.. (currently ignored)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1=found file &amp; valid, 0=bad file</dd></dl>
<p>Note : the col parameter works differently to most col values. As it is scaled 0x404040 is equall to 0xFFFFFF color values are scaled up by x 4. You can use VoxieBox::colorHexDivide(col, 4) to divide the intended color by a 4th to render it in its true color. This is useful when you want your model to be shown at the correct color.</p>
<p>For more options when using this function </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#a7c093ab5b951e958a673aafeaae9f925" title="Renders 3D model (.obj, .ply, .stl, .kv6) Displays a filename mesh onto the volumetric display....">VoxieBox::drawModelExt</a> Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a323fe437c563e47f755bd953ce376e01">IVoxieBox</a>.</p>

</div>
</div>
<a id="a7c093ab5b951e958a673aafeaae9f925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c093ab5b951e958a673aafeaae9f925">&#9670;&nbsp;</a></span>drawModelExt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::drawModelExt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>rVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>dVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>fVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>forceScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fdrawratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders 3D model (.obj, .ply, .stl, .kv6) Displays a filename mesh onto the volumetric display. Extended from <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:drawModel. </p>
<p>Known as voxie_drawspr_ext ("draw sprite extended") in the voxiebox.h / voxiebox.dll. Renamed to "draw model extended" as a more apt description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>filename. Cached internally. Currently supports .KV6,.STL,.OBJ,.PLY </td></tr>
    <tr><td class="paramname">pos</td><td>position of center of model (pivot) </td></tr>
    <tr><td class="paramname">rVector</td><td>right vector set to {1,0,0} for a un warped normal view </td></tr>
    <tr><td class="paramname">dVector</td><td>down vector set to {0,1,0} for an un warped normal view </td></tr>
    <tr><td class="paramname">fVector</td><td>forward vector set to {0,0,1} for an un warped normal view </td></tr>
    <tr><td class="paramname">col</td><td>color multiplier. 24-bit color, each 8 bits scales intensity of respective component. 64=1.0 or no scale. Use 0x404040 for no change; 0x808080 to draw as double brightness, etc.. (currently ignored) </td></tr>
    <tr><td class="paramname">forceScale</td><td>for STL files, forces scale factor (for alignment inside ZIP animations) Leave this 0.f typically. </td></tr>
    <tr><td class="paramname">fdrawratio</td><td>fraction of model to draw (hack for animation) </td></tr>
    <tr><td class="paramname">flags</td><td>Bit 0:0=normal, 1:wireframe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1=found file&amp;valid, 0=bad file</dd></dl>
<p>Note : the col parameter works differently to most col values. As it is scaled 0x404040 is equall to 0xFFFFFF color values are scaled up by x 4. You can use VoxieBox::colorHexDivide(col, 4) to divide the intended color by a 4th to render it in its true color. This is useful when you want your model to be shown at the correct color.</p>
<p>For a more simpler function </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#a21acf498b44f568ba6a01ff6bb7b13d4" title="Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display.">VoxieBox::drawModel</a> Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac423496589210300b8b1375e6611b9a5">IVoxieBox</a>.</p>

</div>
</div>
<a id="a39520956d73a5c0632bc46ae4d590b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39520956d73a5c0632bc46ae4d590b18">&#9670;&nbsp;</a></span>drawPoly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpol__t.html">pol_t</a> *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ptCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a filled polygon. Assumes points are in loop order and coplanar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>pointer to the <a class="el" href="structpol__t.html" title="point3d with index to next point in loop (starting at 0). Similar to poltex_t but with no texture dat...">pol_t</a> array (consists list of vertices and their 'next point index') </td></tr>
    <tr><td class="paramname">pt_count</td><td>the number of vertices in the <a class="el" href="structpol__t.html" title="point3d with index to next point in loop (starting at 0). Similar to poltex_t but with no texture dat...">pol_t</a> array </td></tr>
    <tr><td class="paramname">p2</td><td>is an index to the next point on the loop. Holes/multiple loops are supported. </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexidemical color value (RGB) <pre class="fragment">     @example For example, this would draw a flat draw a rectangle:
     pol_t pt[4];
     pt[0].x = 0.0; pt[0].y = 0.0; pt[0].z = 0.0; pt[0].p2 = 1;
     pt[1].x = 0.5; pt[1].y = 0.0; pt[1].z = 0.0; pt[1].p2 = 2;
     pt[2].x = 0.5; pt[2].y = 0.8; pt[2].z = 0.0; pt[2].p2 = 3;
     pt[3].x = 0.0; pt[3].y = 0.8; pt[3].z = 0.0; pt[3].p2 = 0;
    drawPoly(pol_t &amp;pt, 4, 0xffffff);
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>vxDataTypes.h::pol_t</dd></dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#aaa3ebdbb54ba68da8ff10557775d7575">IVoxieBox</a>.</p>

</div>
</div>
<a id="a3ecf77ce85155bb153c2f67c777815a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecf77ce85155bb153c2f67c777815a3">&#9670;&nbsp;</a></span>drawQuad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawQuad </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vAng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>twist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0x404040</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>uValue</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vValue</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a 2D textured (.png, .jpg... most image formats) quad (plane) onto the volumetric display. Useful to rendering 2D textures. Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename / path for the texture to load (.png, .jpg... most image formats supported) </td></tr>
    <tr><td class="paramname">pos</td><td>the center position of the quad to render </td></tr>
    <tr><td class="paramname">width</td><td>x dimension of the quad (how wide). </td></tr>
    <tr><td class="paramname">height</td><td>y dimension of the quad (how high). </td></tr>
    <tr><td class="paramname">hang</td><td>the horizontal angle (yaw) . 0 is front facing. 180 is facing the back of the display. presented in degrees. </td></tr>
    <tr><td class="paramname">hang</td><td>the vertical angle (pitch). 0 is horizontal facing. 90 is facing vertical. presented in degrees. </td></tr>
    <tr><td class="paramname">twist</td><td>how much 'twist' is in the quad. (roll) in the quad 0 is flat. presented in degrees. </td></tr>
    <tr><td class="paramname">col</td><td>the color value of the texture 0x404040 is the natural color from the texture anything less or more will add a tint to the texture. </td></tr>
    <tr><td class="paramname">u</td><td>the u value of the texture. Adjusting this stretches / the horizontal texture size. Default is 1 </td></tr>
    <tr><td class="paramname">u</td><td>the v value of the texture. Adjusting this stretches / the vertical texture size. Default is 1</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a313435cdb69eb055de94a918c4335875">IVoxieBox</a>.</p>

</div>
</div>
<a id="a233de3e5673e223ae90e82f5b2b89532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233de3e5673e223ae90e82f5b2b89532">&#9670;&nbsp;</a></span>drawSphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawSphere </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>renders a sphere on the volumetric display using 3 floats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x position of the sphere's centre position </td></tr>
    <tr><td class="paramname">y</td><td>y position of the sphere's centre position </td></tr>
    <tr><td class="paramname">z</td><td>z position of the sphere's centre position </td></tr>
    <tr><td class="paramname">radius</td><td>the radius (size) of the sphere </td></tr>
    <tr><td class="paramname">fill</td><td>the fill mode 0 = shell, 1 = filled </td></tr>
    <tr><td class="paramname">col</td><td>the color as a RGB hex value</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. fillmode 1 (filled) will only color absolute colors ( 0xFF0000, 0x00FF00, 0xFFFF00, etc...) </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a4efd69105c342b088db2ae2c313450b1">IVoxieBox</a>.</p>

</div>
</div>
<a id="abc4cc5d2d763c8aafe1ca08bc8bc2265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4cc5d2d763c8aafe1ca08bc8bc2265">&#9670;&nbsp;</a></span>drawSphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawSphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fillmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>renders a sphere on the volumetric display using a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>x,y,z position of the sphere's centre position </td></tr>
    <tr><td class="paramname">radius</td><td>the radius (size) of the sphere </td></tr>
    <tr><td class="paramname">fill</td><td>the fill mode 0 = shell, 1 = filled </td></tr>
    <tr><td class="paramname">col</td><td>the color as a RGB hex value</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. fillmode 1 (filled) will only color absolute colors ( 0xFF0000, 0x00FF00, 0xFFFF00, etc...) </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a77b2874018085bbf077a6b4eff015a94">IVoxieBox</a>.</p>

</div>
</div>
<a id="a86d582343c43cbe82ce8df1e362055ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d582343c43cbe82ce8df1e362055ad">&#9670;&nbsp;</a></span>drawText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>rVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>dVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a string (printf-style) unto the volumetric display. </p>
<p>Used for displaying text on the volumetric display. Best to keep the text to be near the top or bottom of the display and flat for maximum readability</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the left, up, top position for the text to start. </td></tr>
    <tr><td class="paramname">r</td><td>right vector use r.x value to set the width of the text. Set r.y and r.z to 0 for straight text </td></tr>
    <tr><td class="paramname">d</td><td>down vector use d.y value to set the height of the text. Set d.x and d.z to 0 for straight text </td></tr>
    <tr><td class="paramname">col</td><td>int hex color value. (0xRGB) </td></tr>
    <tr><td class="paramname">fmt*</td><td>Extension for C/C++ allowing use of this function printf-style. Example '(char*) Hello World Show a int d", myInt'</td></tr>
  </table>
  </dd>
</dl>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5400e4b60902e40463a30a978a1e48a3">IVoxieBox</a>.</p>

</div>
</div>
<a id="a32f88d3c59c20fdceb07bef76f782bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f88d3c59c20fdceb07bef76f782bf3">&#9670;&nbsp;</a></span>drawVox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawVox </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a single voxel onto the volumetric using 3 floats for coordinates. </p>
<p>Draw single voxel at specified location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x position of the voxel's location </td></tr>
    <tr><td class="paramname">y</td><td>y position of the voxel's location </td></tr>
    <tr><td class="paramname">z</td><td>z position of the voxel's location </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexidemical color value</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: The intensity of each color component in col is used for dithering, meaning a voxel might not plot if the intensity of the color component is less than 255. This is by design to allow shades. If you want the voxel to always plot, use 255's in each color component.</p>
<p>Must be called between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> &amp; <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">endFrame()</a> functions. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8a86e311b962c310f85287a9f5de8550">IVoxieBox</a>.</p>

</div>
</div>
<a id="a5579e62d075cae7af8daf6770dd1bf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5579e62d075cae7af8daf6770dd1bf88">&#9670;&nbsp;</a></span>drawVox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::drawVox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em> = <code>0xffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders a single voxel onto the volumetric using a single <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates. </p>
<p>Draw single voxel at specified location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>x,y,z position of the voxel's location </td></tr>
    <tr><td class="paramname">col</td><td>24-bit hexidemical color value</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: The intensity of each color component in col is used for dithering, meaning a voxel might not plot if the intensity of the color component is less than 255. This is by design to allow shades. If you want the voxel to always plot, use 255's in each color component. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a3c7fe8c4b4024b2c41e25563ef0773d1">IVoxieBox</a>.</p>

</div>
</div>
<a id="aaadbb02dbc625dd7aa4f75eb67e32d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadbb02dbc625dd7aa4f75eb67e32d89">&#9670;&nbsp;</a></span>flushGfx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::flushGfx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush all graphics commands on internal buffer, causing all graphics commands to actually execute and complete. </p>
<p>This might be used if one wanted to do some low level access to the voxel buffer. For advanced users only. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae278a85705ab4b72799149f66a25d9c6">IVoxieBox</a>.</p>

</div>
</div>
<a id="a54ea2cd5b99c01acb154c15f3ec3b884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ea2cd5b99c01acb154c15f3ec3b884">&#9670;&nbsp;</a></span>freeGfx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::freeGfx </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a filename from VoxieBox.dll internal cache (any filename passed to voxie_drawmeshtex() / drawMesh, voxie_drawheimap() / drawHeightMap, voxie_drawspr() / drawModel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>the file path and file name of the file to remove from the internal cache NOTE: Pass a '*' file name to remove entire internal cache </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a54f27146d212e0f9381fee3876d996c7">IVoxieBox</a>.</p>

</div>
</div>
<a id="a566a66c84473d36479a2a635adf512b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566a66c84473d36479a2a635adf512b0">&#9670;&nbsp;</a></span>getAspect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getAspect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> (x,y,z) </p>
<dl class="section return"><dt>Returns</dt><dd>returns all the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> (x,y,z) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5dd459c25d00473a9c3e02de521276a7">IVoxieBox</a>.</p>

</div>
</div>
<a id="af0c809c48ef2ead9cf98148df29a5636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c809c48ef2ead9cf98148df29a5636">&#9670;&nbsp;</a></span>getAspectX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getAspectX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect X ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect X ratio (default is 1) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a6d03c32956dfacd485319d2d42be03f9">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad19f887b7e39ca3b4a152f8eeaa78d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19f887b7e39ca3b4a152f8eeaa78d1b">&#9670;&nbsp;</a></span>getAspectY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getAspectY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Y ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Y ratio (default is 1) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af6097ac6cf301b39a51e6eaaf1b9d4ee">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6e33d171c5df12850c8d011eb5cdc442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e33d171c5df12850c8d011eb5cdc442">&#9670;&nbsp;</a></span>getAspectZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getAspectZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Z ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Z ratio (default is .40) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af449963d7adc67b2de74129520029e92">IVoxieBox</a>.</p>

</div>
</div>
<a id="a53ddc2acb04f13451519bdeff12c0587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ddc2acb04f13451519bdeff12c0587">&#9670;&nbsp;</a></span>getDeltaTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getDeltaTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns delta time (the time between volume updates) delta time is CPU speed dependent and can be used to make ensure timing is consistent between various computers / systems. </p>
<dl class="section return"><dt>Returns</dt><dd>in seconds the delta time (time between volume updates) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a2f6a7fe0548aa9527155cd0f6d91b1ad">IVoxieBox</a>.</p>

</div>
</div>
<a id="a242e70d38cb4e18575128574b7e3f2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242e70d38cb4e18575128574b7e3f2f9">&#9670;&nbsp;</a></span>getJoyAnalogAxisValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getJoyAnalogAxisValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a single analog axis (control stick) from a game controller. Value as an float range between -1 and 1, 0 is centred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the controller ID you want to check (0 = player 1, 1 = player 2... etc) </td></tr>
    <tr><td class="paramname">axis</td><td>the controller's Axis to check (vxInputTypes.h::ControllerAxis) 0 left stick x, 1 left stick y, 2 right stick x, 3 right stick y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the single analog axis as a float. Range between -1 and 1, 0 is centred. To get both the X and Y values together </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#aaef8c955082e7b08d9e8240dcc82ad39" title="returns the analog axis (control stick) from a game controller. Value as an Point2d range between -1 ...">getJoyAnalogAxisValueP2D()</a> <br  />
 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a71c2c098f8230ae8c51af959e98662f3">IVoxieBox</a>.</p>

</div>
</div>
<a id="aaef8c955082e7b08d9e8240dcc82ad39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef8c955082e7b08d9e8240dcc82ad39">&#9670;&nbsp;</a></span>getJoyAnalogAxisValueP2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint2d.html">point2d</a> VoxieBox::getJoyAnalogAxisValueP2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the analog axis (control stick) from a game controller. Value as an Point2d range between -1 and 1, 0 is centred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the controller ID you want to check (0 = player 1, 1 = player 2... etc) </td></tr>
    <tr><td class="paramname">stick</td><td>0 for left stick, 1 for right stick</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the XY analog axis as a Point2d. Range between -1 and 1, 0 is centred. To get a single dimension </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#a242e70d38cb4e18575128574b7e3f2f9" title="returns a single analog axis (control stick) from a game controller. Value as an float range between ...">getJoyAnalogAxisValue()</a> </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aad10211c95357357171eafd939e86261">IVoxieBox</a>.</p>

</div>
</div>
<a id="a2d7a1d2f5b9fa08b8ee93509a56b4493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7a1d2f5b9fa08b8ee93509a56b4493">&#9670;&nbsp;</a></span>getJoyButtonDownTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getJoyButtonDownTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joyButtonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a value in seconds of how long a controller's button has been held down for. Requires <a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> to be set to false to work. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>Which game controller to check(0 - 3) </td></tr>
    <tr><td class="paramname">joyButtonCode</td><td>Which button press to check <pre class="fragment">    JOY_DPAD_UP = 0,            //!&lt; bit 0 value 1          Digital Dpad Up
     JOY_DPAD_DOWN = 1,         //!&lt; bit 1 value 2          Digital Dpad Down
     JOY_DPAD_LEFT = 2,         //!&lt; bit 2 value 4          Digital Dpad Left
     JOY_DPAD_RIGHT = 3,            //!&lt; bit 3 value 8          Digital Dpad Right
     JOY_START = 4,             //!&lt; bit 4 value 16         Start Button
     JOY_BACK = 5,              //!&lt; bit 5 value 32         Back Button
     JOY_LEFT_THUMB = 6,            //!&lt; bit 6 value 64         Left Thumb Stick Button (when you press 'down' on the left analog stick)
     JOY_RIGHT_THUMB = 7,       //!&lt; bit 7 value 128        Right Thumb Stick Button (when you press 'down' on the right analog stick)
     JOY_LEFT_SHOULDER = 8,     //!&lt; bit 8 value 256        Left Shoulder Bumper Button - not the Shoulder triggers are analog
     JOY_RIGHT_SHOULDER = 9,        //!&lt; bit 9 value 512        Right Shoulder Bumper Button - not the Shoulder triggers are analog
     JOY_A = 12,                    //!&lt; bit 12 value 1,024     The 'A' Button on a standard Xbox Controller
     JOY_B = 13,                    //!&lt; bit 13 value 2,048     The 'B' Button on a standard Xbox Controller
     JOY_X = 14,                    //!&lt; bit 14 value 4,096     The 'X' Button on a standard Xbox Controller
     JOY_Y = 15                 //!&lt; bit 15 value 8,192     The 'Y' Button on a standard Xbox Controller
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in seconds of how long controller's button has been held. Returns 0 if not button is not being pressed. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab23fbc4913986a3d91692e8319cdb812">IVoxieBox</a>.</p>

</div>
</div>
<a id="a80e29e9b674fb64f020ed160bb860a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e29e9b674fb64f020ed160bb860a4d">&#9670;&nbsp;</a></span>getJoyButtonIsDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyButtonIsDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joyButtonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if controller's button is pressed down. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>Which game controller to check (0 - 3) </td></tr>
    <tr><td class="paramname">joyButtonCode</td><td>Which button press to check <pre class="fragment">    JOY_DPAD_UP             = 0,    //!&lt; bit 0 value 1          Digital Dpad Up             
     JOY_DPAD_DOWN          = 1,    //!&lt; bit 1 value 2          Digital Dpad Down 
     JOY_DPAD_LEFT          = 2,    //!&lt; bit 2 value 4          Digital Dpad Left
        JOY_DPAD_RIGHT          = 3,    //!&lt; bit 3 value 8          Digital Dpad Right
     JOY_START              = 4,    //!&lt; bit 4 value 16         Start Button
    JOY_BACK                = 5,    //!&lt; bit 5 value 32         Back Button
    JOY_LEFT_THUMB          = 6,    //!&lt; bit 6 value 64         Left Thumb Stick Button (when you press 'down' on the left analog stick)
    JOY_RIGHT_THUMB         = 7,    //!&lt; bit 7 value 128        Right Thumb Stick Button (when you press 'down' on the right analog stick)
    JOY_LEFT_SHOULDER       = 8,    //!&lt; bit 8 value 256        Left Shoulder Bumper Button - not the Shoulder triggers are analog 
    JOY_RIGHT_SHOULDER      = 9,    //!&lt; bit 9 value 512        Right Shoulder Bumper Button - not the Shoulder triggers are analog 
    JOY_A                   = 12,   //!&lt; bit 12 value 1,024     The 'A' Button on a standard Xbox Controller
    JOY_B                   = 13,   //!&lt; bit 13 value 2,048     The 'B' Button on a standard Xbox Controller
    JOY_X                   = 14,   //!&lt; bit 14 value 4,096     The 'X' Button on a standard Xbox Controller
    JOY_Y                   = 15    //!&lt; bit 15 value 8,192     The 'Y' Button on a standard Xbox Controller
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if controller's button is held down and 0 if not </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aace11059a47d4b20cbfd1f2c3f5b8645">IVoxieBox</a>.</p>

</div>
</div>
<a id="acfc32bcc1084748c3d92576fbf8ce8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc32bcc1084748c3d92576fbf8ce8db">&#9670;&nbsp;</a></span>getJoyButtonOnDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyButtonOnDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joyButtonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if controller's button is just pressed. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>Which game controller to check (0 - 3) </td></tr>
    <tr><td class="paramname">joyButtonCode</td><td>Which button press to check <pre class="fragment">    JOY_DPAD_UP             = 0,    //!&lt; bit 0 value 1          Digital Dpad Up             
     JOY_DPAD_DOWN          = 1,    //!&lt; bit 1 value 2          Digital Dpad Down 
     JOY_DPAD_LEFT          = 2,    //!&lt; bit 2 value 4          Digital Dpad Left
        JOY_DPAD_RIGHT          = 3,    //!&lt; bit 3 value 8          Digital Dpad Right
     JOY_START              = 4,    //!&lt; bit 4 value 16         Start Button
    JOY_BACK                = 5,    //!&lt; bit 5 value 32         Back Button
    JOY_LEFT_THUMB          = 6,    //!&lt; bit 6 value 64         Left Thumb Stick Button (when you press 'down' on the left analog stick)
    JOY_RIGHT_THUMB         = 7,    //!&lt; bit 7 value 128        Right Thumb Stick Button (when you press 'down' on the right analog stick)
    JOY_LEFT_SHOULDER       = 8,    //!&lt; bit 8 value 256        Left Shoulder Bumper Button - not the Shoulder triggers are analog 
    JOY_RIGHT_SHOULDER      = 9,    //!&lt; bit 9 value 512        Right Shoulder Bumper Button - not the Shoulder triggers are analog 
    JOY_A                   = 12,   //!&lt; bit 12 value 1,024     The 'A' Button on a standard Xbox Controller
    JOY_B                   = 13,   //!&lt; bit 13 value 2,048     The 'B' Button on a standard Xbox Controller
    JOY_X                   = 14,   //!&lt; bit 14 value 4,096     The 'X' Button on a standard Xbox Controller
    JOY_Y                   = 15    //!&lt; bit 15 value 8,192     The 'Y' Button on a standard Xbox Controller
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if controller's button is just pressed 0 if not.</dd></dl>
<p>Note : this function works differently to 'IsDown' is down just registers if the button is being pressed while on down is the first instance of the button being pressed before it is released again. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#aa8fb39a3966bfead3a97600029e149ae">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0c0e98814ee28a4b8b18029be43a114e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0e98814ee28a4b8b18029be43a114e">&#9670;&nbsp;</a></span>getJoyButtonOnUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyButtonOnUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joyButtonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if controller's button is just released. See vxInputTypes::JoyButtonCodes for refrence on Joy Button Codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>Which game controller to check (0 - 3) </td></tr>
    <tr><td class="paramname">joyButtonCode</td><td>Which button press to check <pre class="fragment">    JOY_DPAD_UP             = 0,    //!&lt; bit 0 value 1          Digital Dpad Up
     JOY_DPAD_DOWN          = 1,    //!&lt; bit 1 value 2          Digital Dpad Down
     JOY_DPAD_LEFT          = 2,    //!&lt; bit 2 value 4          Digital Dpad Left
        JOY_DPAD_RIGHT          = 3,    //!&lt; bit 3 value 8          Digital Dpad Right
     JOY_START              = 4,    //!&lt; bit 4 value 16         Start Button
    JOY_BACK                = 5,    //!&lt; bit 5 value 32         Back Button
    JOY_LEFT_THUMB          = 6,    //!&lt; bit 6 value 64         Left Thumb Stick Button (when you press 'down' on the left analog stick)
    JOY_RIGHT_THUMB         = 7,    //!&lt; bit 7 value 128        Right Thumb Stick Button (when you press 'down' on the right analog stick)
    JOY_LEFT_SHOULDER       = 8,    //!&lt; bit 8 value 256        Left Shoulder Bumper Button - not the Shoulder triggers are analog
    JOY_RIGHT_SHOULDER      = 9,    //!&lt; bit 9 value 512        Right Shoulder Bumper Button - not the Shoulder triggers are analog
    JOY_A                   = 12,   //!&lt; bit 12 value 1,024     The 'A' Button on a standard Xbox Controller
    JOY_B                   = 13,   //!&lt; bit 13 value 2,048     The 'B' Button on a standard Xbox Controller
    JOY_X                   = 14,   //!&lt; bit 14 value 4,096     The 'X' Button on a standard Xbox Controller
    JOY_Y                   = 15    //!&lt; bit 15 value 8,192     The 'Y' Button on a standard Xbox Controller
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if controller's button is just released 0 if not. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a359456e7efec8f353865921ea184e462">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad6fb680710180b707008854ca5357095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fb680710180b707008854ca5357095">&#9670;&nbsp;</a></span>getJoyButtonState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyButtonState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the game controllers button state. See vxInputTypes::JoyButtonCodes for details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the ID number of the controller to check (0 = 1st, 1 = 2nd, 2 = 3rd, 4th)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the controls button state. Each bit represents a button. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>vxInputTypes::JoyButtonCodes for details. <pre class="fragment">       JOY_DPAD_UP          = 0,    //!&lt; bit 0 value 1          Digital Dpad Up             
       JOY_DPAD_DOWN            = 1,    //!&lt; bit 1 value 2          Digital Dpad Down 
       JOY_DPAD_LEFT            = 2,    //!&lt; bit 2 value 4          Digital Dpad Left
       JOY_DPAD_RIGHT       = 3,    //!&lt; bit 3 value 8          Digital Dpad Right
       JOY_START                = 4,    //!&lt; bit 4 value 16         Start Button
       JOY_BACK             = 5,    //!&lt; bit 5 value 32         Back Button
       JOY_LEFT_THUMB       = 6,    //!&lt; bit 6 value 64         Left Thumb Stick Button (when you press 'down' on the left analog stick)
       JOY_RIGHT_THUMB      = 7,    //!&lt; bit 7 value 128        Right Thumb Stick Button (when you press 'down' on the right analog stick)
       JOY_LEFT_SHOULDER        = 8,    //!&lt; bit 8 value 256        Left Shoulder Bumper Button - not the Shoulder triggers are analog 
       JOY_RIGHT_SHOULDER   = 9,    //!&lt; bit 9 value 512        Right Shoulder Bumper Button - not the Shoulder triggers are analog 
       JOY_A                    = 12,   //!&lt; bit 12 value 1,024     The 'A' Button on a standard Xbox Controller
       JOY_B                    = 13,   //!&lt; bit 13 value 2,048     The 'B' Button on a standard Xbox Controller
       JOY_X                    = 14,   //!&lt; bit 14 value 4,096     The 'X' Button on a standard Xbox Controller
       JOY_Y                    = 15    //!&lt; bit 15 value 8,192     The 'Y' Button on a standard Xbox Controller
</pre> </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a0dae28db8ae89088070d488a28223932">IVoxieBox</a>.</p>

</div>
</div>
<a id="a9d69f900c71fa9c40d4df408ad873b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d69f900c71fa9c40d4df408ad873b77">&#9670;&nbsp;</a></span>getJoyDeadZone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getJoyDeadZone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal gamepad's dead zone value. Default is 0.3. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal gamepad's dead zone value. Default is 0.3 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#abd385e5884adea19af87ae61eb02bca5">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0c0927f2395d4eb7bf55ddf31c355e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0927f2395d4eb7bf55ddf31c355e57">&#9670;&nbsp;</a></span>getJoyNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of USB game controllers detected by the system. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of USB game controllers detected by the system. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a00db5ba27fe1ae9ef43f0eca57759e43">IVoxieBox</a>.</p>

</div>
</div>
<a id="adca965eb57b330aa2cc4f067ee9fcfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca965eb57b330aa2cc4f067ee9fcfb5">&#9670;&nbsp;</a></span>getJoyOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getJoyOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the orientation set for a specific game controller </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the joy's ID of which one you want to return its orientation infomation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = front (normal), 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a407905008c5960fe6d22a6c0d888b3a4">IVoxieBox</a>.</p>

</div>
</div>
<a id="a7ec1b6790e95f3b4db74ebd73100e9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec1b6790e95f3b4db74ebd73100e9d7">&#9670;&nbsp;</a></span>getJoyTriggerValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getJoyTriggerValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>joyTriggerCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a controllers analog trigger value. 0 = 0% pressed ... 1 = 100% pressed. Presented as a float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the ID number of the controller you want to adjust (0 = port 1,1 = port 2, 2 = port 3, 3 = port 4) </td></tr>
    <tr><td class="paramname">joyTriggerCode</td><td>the trigger to check 0 = left, 1 = right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a number between 0 and 1 which represents the analog's trigger value. 0 not pressed, 1 is fully pressed. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8d1be0ad1beaeee84d27aa14a9e38e2d">IVoxieBox</a>.</p>

</div>
</div>
<a id="a368adfcb2a7d29bc794c0a6c672ec862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368adfcb2a7d29bc794c0a6c672ec862">&#9670;&nbsp;</a></span>getKeyDownTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getKeyDownTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scancode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the time (in seconds) The scancode's key has been held down for requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> to be set to false to work </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scancode</td><td>each key has a unique scancode key. For a list scancodes see vxInputTypes.h::Keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in seconds the duration of the key's being held down. Returns -1 if legacyKeyInput is enabled</dd></dl>
<p>Note: <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> to be set to false to work otherwise will always return -1; </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#abee4538a25948743e4774d0003bc458f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a76d73e1715406da5bdb1b4a0296ab9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d73e1715406da5bdb1b4a0296ab9e4">&#9670;&nbsp;</a></span>getKeyIsDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getKeyIsDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scancode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns 1 if the scancode's key is held down (pressed). For scancodes see vxInputTypes.h::Keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scancode</td><td>each key has a unique scancode key. For a list scancodes see vxInputTypes.h::Keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = no press, 1 = is down. Note : Does not return 1 'on down' for the specific on down function </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#ae7783714d972bc677504abd16e91fc53" title="returns a 1 if the scancode&#39;s key is just pressed. Requires VoxieBox::setEnableLegacyKeyInput() set t...">VoxieBox::getKeyOnDown()</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af4db57534bf7b6c85afe59ec145f3bec">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae7783714d972bc677504abd16e91fc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7783714d972bc677504abd16e91fc53">&#9670;&nbsp;</a></span>getKeyOnDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getKeyOnDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scancode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a 1 if the scancode's key is just pressed. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scancode</td><td>each key has a unique scancode key. For a list scancodes see vxInputTypes.h::Keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if key has just been pressed otherwise returns 0</dd></dl>
<dl class="section see"><dt>See also</dt><dd>voxieInputTypes.h::keys </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae8af263a8eee36ef26ff5b8c5aaa31e9">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae67eea4625f9c2df1403f25a108301e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67eea4625f9c2df1403f25a108301e7">&#9670;&nbsp;</a></span>getKeyOnUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getKeyOnUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scancode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a 1 if the scancode's key is just released. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scancode</td><td>each key has a unique scancode key. For a list scancodes see vxInputTypes.h::Keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if key has just been relased otherwise returns 0. Returns -1 if legacyKeyInput is enabled</dd></dl>
<p>Note: <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> to be set to false to work otherwise will always return -1</p>
<dl class="section see"><dt>See also</dt><dd>voxieInputTypes.h::keys </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae0d19e6097e4ad256d848743dd81d3e3">IVoxieBox</a>.</p>

</div>
</div>
<a id="a92f5d41f0d1b3cef1593d959df423238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f5d41f0d1b3cef1593d959df423238">&#9670;&nbsp;</a></span>getKeyState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getKeyState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scancode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a key's input state (0 = no press, 1 = just pressed, 3 = held down) see vxInputTypes.h::Keys for scancodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scancode</td><td>each key has a unique scancode key. For a list scancodes see vxInputTypes.h::Keys</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="vx_input_types_8h.html" title="VX++ input types header contains definitions to do with various input systems.">vxInputTypes.h</a> contains an enum for all the scancodes which all start with the prefix 'KB_' </p><dl class="section return"><dt>Returns</dt><dd>0 = no press, no change, 1 = just pressed, 3 = held down. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a993f8b1d0b93bbb1fccaa7caecd1e98c">IVoxieBox</a>.</p>

</div>
</div>
<a id="a53aa369d7331f1e2680803ea84dd022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53aa369d7331f1e2680803ea84dd022b">&#9670;&nbsp;</a></span>getKeyStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getKeyStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns buffered ASCII keyboard input. </p>
<p>Useful for typing stuff like your name, for example. You may continue to call this function in a while loop until it returns 0. This function only works when <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox libary is freed from memory....">setEnableLegacyKeyInput()</a> is set to true. Otherwise use <a class="el" href="class_voxie_box.html#af139974ac1d2f57c560d3dd269f9d2ac" title="returns internal voxie_keyboard_history_t struct which holds the keyboard input history....">getKeyHistory()</a> instead. </p><dl class="section return"><dt>Returns</dt><dd>0: buffer is empty otherwise bits 7-0: ASCII code ('A'=65,'a'=97,'0'=48,etc..) bits 15-8: Keyboard Scan Code bit 16: Left Shift was down at time of this keypress bit 17: Right Shift was down at time of this keypress bit 18: Left Ctrl was down at time of this keypressdrawSphere bit 19: Right Ctrl was down at time of this keypress bit 20: Left Alt was down at time of this keypress bit 21: Right Alt was down at time of this keypress </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac98ada2a49e635d64803a2869ed30f72">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6e820dbd04614d0a72ee9648de0f72b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e820dbd04614d0a72ee9648de0f72b5">&#9670;&nbsp;</a></span>getMouseButtonDownTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getMouseButtonDownTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mount of time (in seconds) a mouse's button has been pressed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the mouse button code to check (0 = left, 1 = right, 2 = middle)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in seconds the mount of time that button has been pressed. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a6b9dbda70e73dfbb951f63d7d850c6fb">IVoxieBox</a>.</p>

</div>
</div>
<a id="ac65fbb73532b95287a314acf018ebc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65fbb73532b95287a314acf018ebc58">&#9670;&nbsp;</a></span>getMouseButtonIsDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseButtonIsDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the state of mouse's buttonCode. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if currently pressed down and 0 if not being pressed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the buttonCode for the button to check. 0 = Left, 1 = Right, 2 = Centre (mouse wheel button). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a53d04360ec7c5df39ff6a02ba715ec32">IVoxieBox</a>.</p>

</div>
</div>
<a id="a5b70ad6a3746e626b2486f5d09cc2460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b70ad6a3746e626b2486f5d09cc2460">&#9670;&nbsp;</a></span>getMouseButtonOnDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseButtonOnDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the state of mouse's buttonCode. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if button has been pressed during this update frame otherwise 0 if not just pressed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the buttonCode for the button to check. 0 = Left, 1 = Right, 2 = Centre (mouse wheel button). Note : This input check is for the instance of it being just pressed. It will return 0 if you held down a button. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a133bc86d0444e81f01bd6cf4796e16cb">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0c5757b6a7369f171f64c4088cc4ad2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5757b6a7369f171f64c4088cc4ad2d">&#9670;&nbsp;</a></span>getMouseButtonOnUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseButtonOnUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to see if desired MoustButton has been just released ('on up') </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the mouse button code you wish to check for (0 = left, 1 = right, 2 = both) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if just released otherwise false </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#abe03c8bf331d21573f09e64bb197f67e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a9505deb662efbbd9d955158be30575f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9505deb662efbbd9d955158be30575f5">&#9670;&nbsp;</a></span>getMouseButtonState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseButtonState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a698202f5db651e54e4dd5a536d2ee242">IVoxieBox</a>.</p>

</div>
</div>
<a id="a05020085c7aa8fab0d9035b451384285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05020085c7aa8fab0d9035b451384285">&#9670;&nbsp;</a></span>getMouseDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getMouseDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse's X,Y and Z delta movements as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse's X,Y and Z delta movements as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab49dd59c3ffe306e46216d62ec276f7a">IVoxieBox</a>.</p>

</div>
</div>
<a id="af5a19c0708fa54178016751597357bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a19c0708fa54178016751597357bcb">&#9670;&nbsp;</a></span>getMouseDoubleClick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseDoubleClick </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if particular Mouse's buttonCode has been clicked twice within the double click threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the mouse's button code to check (0 = left, 1 = right, 2 = middle)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if double click has been registered otherwise return 0.</dd></dl>
<p>To adjust double click threshold </p><dl class="section see"><dt>See also</dt><dd>setMouseoubleClickThreshold() </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#afb595d29b03560dac44f5915c8b373a9">IVoxieBox</a>.</p>

</div>
</div>
<a id="aea4ffb974a7b7ed79159d281ab053643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4ffb974a7b7ed79159d281ab053643">&#9670;&nbsp;</a></span>getMouseDoubleClickThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getMouseDoubleClickThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mouse double click threshold. (how quickly 2 mouse clicks signify a 'double click'). Presented in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the mouse double click threshold. (how quickly 2 mouse clicks signify a 'double click'). Presented in seconds. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8cac9fde3f7f8948cae3cb5149667b0f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6c9a424af65cf4b24a598bc16ab2ddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9a424af65cf4b24a598bc16ab2ddfc">&#9670;&nbsp;</a></span>getMouseOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the orientation set for the mouse </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the SpaceNav's ID of which one you want to return its orientation infomation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = front (normal), 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a01d967eaa56cf556e4f9b213f98df18b">IVoxieBox</a>.</p>

</div>
</div>
<a id="ac567600c40003e62fbcf9ffe1aaf938b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac567600c40003e62fbcf9ffe1aaf938b">&#9670;&nbsp;</a></span>getMousePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getMousePosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>returns the internal mouse position as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> (x, y, z) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#afea3ed1068bb4472df6c779c1cde6bb4">IVoxieBox</a>.</p>

</div>
</div>
<a id="abb63bd24d7437b0ce407ebe619907e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb63bd24d7437b0ce407ebe619907e79">&#9670;&nbsp;</a></span>getMousePrevButtonState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMousePrevButtonState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse previous button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br  />
 </p>
<p>Could be used to write your own input functions.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse previous button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8e7bba604dae38c3b5ff832f15863d8e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8ec539a88701b8f924728b6c97d5c59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec539a88701b8f924728b6c97d5c59d">&#9670;&nbsp;</a></span>getMouseState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> VoxieBox::getMouseState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the internal (in) voxie_inputs_t struct. </p>
<p>could be useful for users who want access to what the internal mouse inputs varibles are at the internal voxie_inputs_t (which really just hold the mouse input varibles) when updated when <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> is called. <br  />
 you can use setMouseState to override these values.</p>
<dl class="section return"><dt>Returns</dt><dd>the internal mouse state as a voxie_inputs_t </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a535b66c5228f0b90c1b6f9b23f35cb0c">IVoxieBox</a>.</p>

</div>
</div>
<a id="a05bee40c97a178811c285249d31fb19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bee40c97a178811c285249d31fb19d">&#9670;&nbsp;</a></span>getMouseXDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseXDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse's X delta movement. Reads from internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse's X delta movement. Reads from internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a586a6612f5122bbd7b838e49f9f0113e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a722648b0a9d0a393521d25e7f3ba4600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722648b0a9d0a393521d25e7f3ba4600">&#9670;&nbsp;</a></span>getMouseXYSensitivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getMouseXYSensitivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current mouse XY sensitivity. Default is 0.001. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current mouse XY sensitivity. Default is 0.001 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a360635e1e20996231a648ce78e3cf5c6">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad8a8261118e2b077e874eba3d2b32deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a8261118e2b077e874eba3d2b32deb">&#9670;&nbsp;</a></span>getMouseYDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseYDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse's Y delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse's Y delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a535042b523d8ddd4dbc1787ab9e3c6a4">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8bcd3a5457b65f75e0352804b6b5686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcd3a5457b65f75e0352804b6b5686e">&#9670;&nbsp;</a></span>getMouseZDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getMouseZDelta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal mouse's Z delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the internal mouse's Z delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a9ee66fc378abc35f5046953c03d8be36">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad90e6174c6c2c64d157e27b4a10354fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90e6174c6c2c64d157e27b4a10354fa">&#9670;&nbsp;</a></span>getMouseZSensitivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getMouseZSensitivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current mouse Z sensitivity. Default is 0.0005. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the current mouse Z sensitivity. Default is 0.0005 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af69e1e54293c847531f274a6983f377b">IVoxieBox</a>.</p>

</div>
</div>
<a id="adbf26a972aaae97bff81d7e7874f43b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf26a972aaae97bff81d7e7874f43b1">&#9670;&nbsp;</a></span>getNavAngleDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getNavAngleDelta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the Space Nav's angle input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 - 3)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle delta (what angle input has been altered since the last volume update) <br  />
 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af00b9a479453e868fa88cad97656dea4">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6c1d49e5492f701cbf2926daaa464e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1d49e5492f701cbf2926daaa464e8e">&#9670;&nbsp;</a></span>getNavAngleDeltaAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getNavAngleDeltaAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a single axis of a spaceNav's angle delta (range is -1 to 1, 0 is centred). Axis 0 = x, 1 = y, 2 = z </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the space Nav's id to fetch </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to get the angle infomation 0 = x, 1 = y 2 = z;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a single axis of a Space Nav's angle delta (range is -1 to 1, 0 is centred) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a52bc76b72c845126d74ca445d707f34e">IVoxieBox</a>.</p>

</div>
</div>
<a id="a2e4918d2f0e6e2f09d6e32ddafc9ec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4918d2f0e6e2f09d6e32ddafc9ec34">&#9670;&nbsp;</a></span>getNavButtonDownTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getNavButtonDownTime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in seconds how long a Space Nav's button has been held down, otherwise returns a 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc) </td></tr>
    <tr><td class="paramname">buttonCode</td><td>the button code to check based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in seconds how long a Space Nav's button has been held down, otherwise returns a 0. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ad91c67790f893644186c271e3ada27b2">IVoxieBox</a>.</p>

</div>
</div>
<a id="a543e15621a0580a65cf2a88861eb8739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543e15621a0580a65cf2a88861eb8739">&#9670;&nbsp;</a></span>getNavButtonIsDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavButtonIsDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if particular Space Nav's button is being pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc) </td></tr>
    <tr><td class="paramname">buttonCode</td><td>the button code to check based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if particular button is currently being pressed otherwise 0. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a24f40fd3742f104a73bed2b731a4404c">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0a4ee0e4687d8f2fe4278ef65e1294cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4ee0e4687d8f2fe4278ef65e1294cb">&#9670;&nbsp;</a></span>getNavButtonOnDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavButtonOnDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if particular Space Nav's button has just been pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc) </td></tr>
    <tr><td class="paramname">buttonCode</td><td>the button code to check based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if particular button has just been pressed, otherwise 0. This function is 'on pressed' it will call 1 on being pressed and then 0 after the first instance of a press. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ad836a02c1bc474bbebd5cb10e14dbcf9">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8be43475c0e8cf140ae7fac98b79e69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be43475c0e8cf140ae7fac98b79e69e">&#9670;&nbsp;</a></span>getNavButtonOnUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavButtonOnUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if particular Space Nav's button has been just released from being held ('on up'). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc) </td></tr>
    <tr><td class="paramname">buttonCode</td><td>the button code to check based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if button is just released, otherwise 0 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a7c428114dbf322427441ed16b5a6183f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a5e8f3c3618a055cb191b7ccbf8155e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f3c3618a055cb191b7ccbf8155e38">&#9670;&nbsp;</a></span>getNavButtonState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavButtonState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the button values (presented as binary of each button) for the Space Navigator. 0 = none, 1 = left, 2 = right, 3 = both. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bits 0 and 1 are the left and right buttons respectifully, 0 = no button pressed, 1 = left button pressed, 2 = right button pressed, 3 = both buttons pressed </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="aec281a876a0ced290f5936a31a0398ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec281a876a0ced290f5936a31a0398ad">&#9670;&nbsp;</a></span>getNavDirectionDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getNavDirectionDelta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the Space Nav's direction input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 - 3)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the direction delta (what direction input has been altered since the last volume update) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a2f8b06116693a75d70327854035bc24a">IVoxieBox</a>.</p>

</div>
</div>
<a id="a96dbdfe055747aa3f8922acde13aa67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dbdfe055747aa3f8922acde13aa67d">&#9670;&nbsp;</a></span>getNavDirectionDeltaAxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float VoxieBox::getNavDirectionDeltaAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single axis of a Space Nav's direction delta (range is -1 to 1, 0 is centred). Axis 0 = x, 1 = y, 2 = z. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the space Nav's id to fetch </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to get the direction infomation 0 = x, 1 = y 2 = z;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a single axis of a Space Nav's direction delta (range is -1 to 1, 0 is centred) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5377e01ca0b50299b948059cd1d60e05">IVoxieBox</a>.</p>

</div>
</div>
<a id="a5194f3ae9e1e488f13dedc06631b2a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5194f3ae9e1e488f13dedc06631b2a51">&#9670;&nbsp;</a></span>getNavDoubleClick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavDoubleClick </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buttonCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns 1 if particular Space Nav's buttonCode has been clicked twice within the double click threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buttonCode</td><td>the Space Nav's button code to check (0 = left, 1 = right, 2 = both)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if double click has been registered otherwise return 0.</dd></dl>
<p>To adjust click hold threshold </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#a040618235390a1e8457be8bafca4eab3">getNavDoubleClickThreshold()</a> </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ad69e3a32a4351c8ea6ad50f9b3bf6287">IVoxieBox</a>.</p>

</div>
</div>
<a id="a040618235390a1e8457be8bafca4eab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040618235390a1e8457be8bafca4eab3">&#9670;&nbsp;</a></span>getNavDoubleClickThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getNavDoubleClickThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>returns the internal Space Nav double click threshold value. (Used to determine if a 'double click' has been detected) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a31fbadb8a776adfd0b03db9fc9f83148">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8111bba76a21851f4280c09a9f90c332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8111bba76a21851f4280c09a9f90c332">&#9670;&nbsp;</a></span>getNavNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavNum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Note for a SpaceNav to be detected it must be moved (is detecte when any of the SpaceNav's axis movements) </p>
<dl class="section return"><dt>Returns</dt><dd>returns the number of SpaceNavs detected by the system. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a125ed1d2471229df9c12fff00905d061">IVoxieBox</a>.</p>

</div>
</div>
<a id="a27815db90d21bf6e8df80dc19ab88ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27815db90d21bf6e8df80dc19ab88ee1">&#9670;&nbsp;</a></span>getNavOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the orientation set for a specific Space Nav </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the SpaceNav's ID of which one you want to return its orientation infomation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = front (normal), 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ad1253b0f799517c4c88cfc5964f0cca9">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad9440acc297003385583917cf2b60b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9440acc297003385583917cf2b60b8c">&#9670;&nbsp;</a></span>getNavPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpoint3d.html">point3d</a> VoxieBox::getNavPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of the Nav's tracked position. Used primarly when the Space Nav is being used as a cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of the internally tracked Space Nav position </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a242c3a837f6d9f743cbe835cc5f4855c">IVoxieBox</a>.</p>

</div>
</div>
<a id="aecd2282f3ea1faa75500c0c95c6127c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd2282f3ea1faa75500c0c95c6127c1">&#9670;&nbsp;</a></span>getNavPrevButtonState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::getNavPrevButtonState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the previous button values. Used for a legacy way to create your own button functions. Useful if <a class="el" href="class_voxie_box.html#a742aca3dfb890fb71c34bc0910f9483a" title="Set to true to handle Nav input manually. Disables many of the nav input functions....">setEnableLegacyNavInput()</a> is set to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the button values from the previous volume update. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae07bee3c01da9e338ecace0a62f1e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07bee3c01da9e338ecace0a62f1e76a">&#9670;&nbsp;</a></span>getNavSensitivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getNavSensitivity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Returns the current Space Nav internal sensitivity setting</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the current Space Nav internal sensitivity setting. Number between 1 and 0.0001. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a28bf8b9e96a4c0b2777abf9f4936a257">IVoxieBox</a>.</p>

</div>
</div>
<a id="a879b47da9d4fab087667a192cdb2504d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879b47da9d4fab087667a192cdb2504d">&#9670;&nbsp;</a></span>getTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the running time (in seconds) from program execution till present. </p>
<dl class="section return"><dt>Returns</dt><dd>in seconds the running time (in seconds) from program execution till present. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aed88178f4b802a5a6a3c389427059b31">IVoxieBox</a>.</p>

</div>
</div>
<a id="a33ac60796c8cd10a98a2a23cb67107fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac60796c8cd10a98a2a23cb67107fb">&#9670;&nbsp;</a></span>getVPS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double VoxieBox::getVPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the system's current VPS (volumes per second). </p>
<dl class="section return"><dt>Returns</dt><dd>the current VPS value. At least 15 VPS on a Up/Down system and At least 30 VPS for a Spinner is recommended. <br  />
 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5e9a21f1708565167f5995ac774b69f2">IVoxieBox</a>.</p>

</div>
</div>
<a id="afdbb09888096ee6591139e038c4d0cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbb09888096ee6591139e038c4d0cf0">&#9670;&nbsp;</a></span>getVxCppVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__int64 VoxieBox::getVxCppVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a timestamp of the compile date of VxCpp.dll expressed as an __int64. (format: YYYYMMDDHHmmss) </p>
<p>Returns compile date and time of VxCpp.dll as a 64-bit int in this format: year*1e10 + month*1e8 + day*1e6 + hour*1e4 + minute*1e2 + second For example, April 8, 2024 at 16:38:44 would be: 20240408163844 </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac15d22afdc95f90b87c9aa9c1e83ba39">IVoxieBox</a>.</p>

</div>
</div>
<a id="a9df7e95b7c877b5942690affef94d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df7e95b7c877b5942690affef94d4a6">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initalises and updates voxiebox.dll's voxie window (<a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>) </p>
<p>The voxie window is the struct which holds all the settings and values to do with the volumetric display. </p><dl class="section see"><dt>See also</dt><dd>vxDataTypes.h::voxie_wind_t</dd></dl>
<p>This function is called first time by the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> constructor. So there is no need for a developer to initialise it But can be used to update the voxie_window if the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class's vw (<a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>) has been updated. On the first call, this function sets up the window and starts the hardware motor. On later calls, it can be used to override some parameters of the vw (voxie_window_t) structure.</p>
<p>For example: vw.useJoy = 0; voxie_init(&amp;vw); would change the joystick input method to direct input (joyInfoEx) emulation regardless of the setting in voxiebox.ini. if voxie_init returns -1 the function returns an error could not initialise or update </p><dl class="section return"><dt>Returns</dt><dd>0 if Initialization or updating is successful. -1 if an error <br  />
</dd></dl>
<p>Note : This function always passing in the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class's <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> which is known as 'vw' </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a98efc8de5deeb9879275dfe6df935006">IVoxieBox</a>.</p>

</div>
</div>
<a id="a24182daedfd67f13974273f2b2786c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24182daedfd67f13974273f2b2786c86">&#9670;&nbsp;</a></span>menuAddItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::menuAddItem </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startingVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minStepVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>majStepVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add item to a menu tab. </p>
<p>Use this function to add a new menu item to the menu's tab. See the enum from vxInputTypes.h::menuTypes for a list of menu item to add. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>name of text/button/slider </td></tr>
    <tr><td class="paramname">x</td><td>starting x position for menu item </td></tr>
    <tr><td class="paramname">y</td><td>starting y position for menu item </td></tr>
    <tr><td class="paramname">xSize</td><td>horizontal size of item </td></tr>
    <tr><td class="paramname">ySize</td><td>vertical size of item </td></tr>
    <tr><td class="paramname">id</td><td>user-defined low integer (use enum to differentiate easily). Assign a unique number (ID) so the menu item can be recalled by other functions </td></tr>
    <tr><td class="paramname">type</td><td>the type of menu item to create see vxInputTypes.h::menuTypes MENU_TEXT: text (decoration only) MENU_LINE: line (decoration only) MENU_BUTTON+3: push button (single button) MENU_BUTTON+1: push button (first in group - auto-depresses others so only 1 on) MENU_BUTTON : push button (in middle of group) MENU_BUTTON+2: push button (last in group - auto-depresses others so only 1 on) MENU_HSLIDER: horizontal slider MENU_VSLIDER: vertical slider MENU_EDIT: edit text box MENU_EDIT_DO: edit text box, click next item on 'Enter' MENU_TOGGLE: combo box (w/o the drop down). Useful for saving space in dialog. Specify multiple strings in 'st' using \r as separator. MENU_PICKFILE: file selector. Specify type in 2nd string. Ex: "Browse\r*.kv6" </td></tr>
    <tr><td class="paramname">col</td><td>color of item (typically 0xffffff) </td></tr>
    <tr><td class="paramname">startingVal</td><td>the starting value of menu item </td></tr>
    <tr><td class="paramname">minVal</td><td>min value <br  />
 </td></tr>
    <tr><td class="paramname">maxVal</td><td>max value </td></tr>
    <tr><td class="paramname">minStepVal</td><td>minor step in value increase/decrease amount </td></tr>
    <tr><td class="paramname">majStepVal</td><td>major step in value increase/decrease amount </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aac9b1365572a37447494a87fb722aed6">IVoxieBox</a>.</p>

</div>
</div>
<a id="ad0f01b6afc8d26019e504d9154aab915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f01b6afc8d26019e504d9154aab915">&#9670;&nbsp;</a></span>menuAddTab()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::menuAddTab </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add custom menu tab on secondary (touch) screen menu (NOTE: there's only space for 2 more tabs on the 7" 1024x600 LCD screen) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>name of tab </td></tr>
    <tr><td class="paramname">x</td><td>horizontal position for the tab item area </td></tr>
    <tr><td class="paramname">y</td><td>vertical position for tab item area </td></tr>
    <tr><td class="paramname">xs</td><td>width in pixels of the tab item area </td></tr>
    <tr><td class="paramname">ys</td><td>height in pixels of the tab item area</td></tr>
  </table>
  </dd>
</dl>
<p>menu functions only needs to be called once. Not every volume/frame. <br  />
 </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab26d5089fe0eb1422db4df3e66940338">IVoxieBox</a>.</p>

</div>
</div>
<a id="afb5879b3f95704ba0563b3ed33c71cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5879b3f95704ba0563b3ed33c71cea">&#9670;&nbsp;</a></span>menuReset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::menuReset </td>
          <td>(</td>
          <td class="paramtype">int(*)(int id, char *st, double val, int how, void *userdata)&#160;</td>
          <td class="paramname"><em>menu_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bgImageFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function used to reset the voxie menu and set a new custom menu update function (the menu which is on the secondary touch screen) </p>
<p>This function is essential if you want to make your own menu tabs as you'll need to create a function which holds all your menu's logic The menu_update function is where a user makes their own function which manages the menu's input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">menu_update</td><td>callback function to handle interaction updates. See example user function below. </td></tr>
    <tr><td class="paramname">userdata</td><td>a pointer to a user-defined structure (optional / for convenience only). </td></tr>
    <tr><td class="paramname">bgImageFileName</td><td>an image file to be used as background (should be 1024x600 for the LCD display)</td></tr>
  </table>
  </dd>
</dl>
<p>The menu_update( int id, char *st, double val. int how, void * userdata) is called every time a menu button is pressed. each menu item has an id and passes through certain values depending on its item type. </p><pre class="fragment">             Parameters for the menu_update() custom function:
                 id = the id for the menu item which is calling the function.
                 st = the custom pointer char array being passed in from the menu item. (for user edit box (MENU_EDIT))
                 val = the custom val passed in from the menu item this is how slider values are passed in
                how = tells how button or slider was changed: (0:enter, 1:left/right arrow, 2:click button, 3:drag slider, 4:slider arrow)
                userdata = pointer to user-defined structure (helpful to avoid global variables)



       @example Example of custom menu call back function 
      enum {MENU_SPEED_BUTTON_1,MENU_SPEED_BUTTON_2,MENU_SPEED_BUTTON_3,MENU_SPEED_SLIDER,MENU_FILE};
      static int gspeed = 1;
       static int user_menu_update(int id, char *st, double v, int how, void *userdata)
        {
            switch (id)
            {
            case MENU_SPEED_BUTTON_1: gspeed = 1; break; (MENU_SPEED_BUTTON_1 (1) is menuAddItem's id - defined when the menu item was created)
            case MENU_SPEED_BUTTON_2: gspeed = 2; break;
            case MENU_SPEED_BUTTON_3: gspeed = 3; break;
            case MENU_SPEED_SLIDER: gspeed = (int)v; break;
            case MENU_FILE: printf("File:%s\n", st); break; //NOTE:don't use printf in graphical app :P
            }
            return(1);
        }

       At some point in your VX program (usually before your breath() update loop). call menuReset and define your call back function. menuReset(user_menu_update, 0, (char*)"test.png");
</pre><p> Note: call with voxie_menu_reset(0,0); to remove the user menu </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae4804b893c9ae39a2df451a3dd94477d">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6e449e778187eb0964434e2fc6ab08a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e449e778187eb0964434e2fc6ab08a8">&#9670;&nbsp;</a></span>mountZip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::mountZip </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mountZip - extracts and loads a .zip file into memory. </p>
<p>Once a zip has been mounted all file names which are withing the zip folder can be refrenced as if they were in the local directory Example you have a zip file with 'example.png' within it. Once you mount that zip you refer 'example.png' in your program to access that file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the path and filename of the zip file to mount. (path is relative) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a40b471b65893b47e859ff60393ba27fa">IVoxieBox</a>.</p>

</div>
</div>
<a id="aec8968200374c40be26146b163f5d209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8968200374c40be26146b163f5d209">&#9670;&nbsp;</a></span>moveToPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::moveToPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>currentPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>destinationPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>accuracy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates/"moves" a point from the current position towards the destination point. Returns 1 if currentPos collides with destinnationPos otherwise returns a 0. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentPos</td><td><a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> pointer to the current position </td></tr>
    <tr><td class="paramname">currentPos</td><td><a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> to the destination position </td></tr>
    <tr><td class="paramname">speed</td><td>the speed in which the point is traveling </td></tr>
    <tr><td class="paramname">accuracy</td><td>the accuracy to determine if the current position has reached the destination Pos</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if currentPos has arrived at the destinationPos (within the accuracy provided) otherwise 0 </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a4f429fa4b4869ffec1fe68e0096df0da">IVoxieBox</a>.</p>

</div>
</div>
<a id="ace99015ec6f52f91cc0c80f9e8236385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace99015ec6f52f91cc0c80f9e8236385">&#9670;&nbsp;</a></span>playSound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::playSound </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volumeLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volumeRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>playBackSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plays a sound (can be WAV, FLAC, MP3, M4A) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>filename (WAV, FLAC, MP3 or M4A) of sound to play </td></tr>
    <tr><td class="paramname">sourceChannel</td><td>which channel of the audio file extract (0 left, 1 right, -1 stereo, -2 left + right) </td></tr>
    <tr><td class="paramname">volumeLeft</td><td>% of full volume to left channel {0..100, although may exceed 100} </td></tr>
    <tr><td class="paramname">volumeRight</td><td>% of full volume to right channel {0..100, although may exceed 100} </td></tr>
    <tr><td class="paramname">playBackSpeed</td><td>frequency scaling. use 1.0 for default sample rate, 2.0 for 1 octave up, 0.5 for 1 octave down... etc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle int of 0..MAX if success. Use this as a handle passed to voxie_playsound_update(). -1 if file not found or other error related to loading. -2 if none of the MAX audio voice slots were free. New sounds don't play if list is full. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae939bf24c18e16a5db12f00bdefd4434">IVoxieBox</a>.</p>

</div>
</div>
<a id="a77183817f6b5ea5b61542970b1b58d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77183817f6b5ea5b61542970b1b58d5c">&#9670;&nbsp;</a></span>pointSame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::pointSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint2d.html">point2d</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint2d.html">point2d</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint2d.html">point2d</a>&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>{&#160;0.001,&#160;0.001&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy ammount specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>pointer to the 1st <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the 2nd <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> to compare </td></tr>
    <tr><td class="paramname">accuracy</td><td>the accuracy to compare the two points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two points are the same within the accuracy ammount specified </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a32db1238b7d6c4be8cc344072072ad58">IVoxieBox</a>.</p>

</div>
</div>
<a id="a26c394fd79456ebdda335a9493bb5ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c394fd79456ebdda335a9493bb5ee8">&#9670;&nbsp;</a></span>pointSame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::pointSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>{&#160;0.001,&#160;0.001,&#160;0.001&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy ammount specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>pointer to the 1st <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the 2nd <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> to compare </td></tr>
    <tr><td class="paramname">accuracy</td><td>the accuracy to compare the two points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two points are the same within the accuracy ammount specified </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a3faf77c9c4badf73f50b91f8c2993b49">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6e9f69b448fecf7ef2c9e2413d5feb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9f69b448fecf7ef2c9e2413d5feb8c">&#9670;&nbsp;</a></span>quitLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::quitLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this to tell Voxiebox library you want to exit the <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">breath()</a> loop and quit the application. </p>
<p>forces <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">VoxieBox::breath()</a> to return non-zero on its next call.</p>
<p>By default a clean exit is set to true (VoxieBox::setEnsureCleanExitOnQuitLoop()) if VoxieBox::setEnsureCleanExitOnQuitLoop() is set to true. <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">VoxieBox::endFrame()</a> is called and GFX stored in memory is cleared. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ad58e59fff5de3873576a1252d2f9e7d0">IVoxieBox</a>.</p>

</div>
</div>
<a id="aa0eedd380668a3439dbac70f8b9e40f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eedd380668a3439dbac70f8b9e40f4">&#9670;&nbsp;</a></span>reportJoy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportJoy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reports the state of the game controllers on to the secondary (touch) screen </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position to render the report </td></tr>
    <tr><td class="paramname">posY</td><td>the Y position to render the report </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac358588359fe1dcd9d896e36980266b5">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae2e0592fdd5b0ac20f71f1779db9fd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e0592fdd5b0ac20f71f1779db9fd84">&#9670;&nbsp;</a></span>reportKeyboard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportKeyboard </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the state of the keyboard on to the secondary (touch) screen. Used to help with debugging/. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position to render the report </td></tr>
    <tr><td class="paramname">poxY</td><td>the Y position to render the report </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a446554e9de2c673ce05f00207221bd54">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8fc2b7e9e938d61314aaf8c3b23fbae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2b7e9e938d61314aaf8c3b23fbae2">&#9670;&nbsp;</a></span>reportMouse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportMouse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showCursor</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports mouse input state information onto secondary (touch) screen. </p>
<p>This report uses the internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> struct as reference (this could be overwritten with <a class="el" href="class_voxie_box.html#a19870dae738a7c8214ea9d23580b8c19" title="Override the internal voxie_input_t mouse state.">VoxieBox::setMouseState</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the pixel x (horizontal) position to display the report </td></tr>
    <tr><td class="paramname">posY</td><td>the pixel y (vertical) position to display the report </td></tr>
    <tr><td class="paramname">showCursor</td><td>if true shows the mouse cursor on the volumetric display. Set to true by default </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac178722b55c26db15115da7f6432c38f">IVoxieBox</a>.</p>

</div>
</div>
<a id="a8dd0190500f7279e6cd769004cc5a430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0190500f7279e6cd769004cc5a430">&#9670;&nbsp;</a></span>reportNav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportNav </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showCursor</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports all SpaceNav input state onto the secondary (touch screen) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the horiztional position to display the report </td></tr>
    <tr><td class="paramname">posY</td><td>the vertical position to display the report </td></tr>
    <tr><td class="paramname">showCursor</td><td>(true by default) draw the cursor of the position of the SpaceNav</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Space Navs are only detected by the system after an inital movement. </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a14ce7910f40aedcb67884f2701875ed1">IVoxieBox</a>.</p>

</div>
</div>
<a id="a800ccbc5c2a20314f55b29d38030e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800ccbc5c2a20314f55b29d38030e13f">&#9670;&nbsp;</a></span>reportVoxieFrame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportVoxieFrame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exposes some of the variables from the internal <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> onto the secondary (touch) screen. </p>
<p>Intended for debug purposes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position of the report </td></tr>
    <tr><td class="paramname">posY</td><td>the Y position of the report </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a8b6aaafbf8ef7ad3f4dfa45ed07a8368">IVoxieBox</a>.</p>

</div>
</div>
<a id="aca032139f49b25ea1387100013493fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca032139f49b25ea1387100013493fb0">&#9670;&nbsp;</a></span>reportVoxieFrame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportVoxieFrame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxie__frame__t.html">voxie_frame_t</a> *&#160;</td>
          <td class="paramname"><em>VF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exposes some of the variables a <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> struct onto the secondary (touch) screen. </p>
<p>Intended for debug purposes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position of the report </td></tr>
    <tr><td class="paramname">posY</td><td>the Y position of the report </td></tr>
    <tr><td class="paramname">VF</td><td>a pointer for the <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> struct to report on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4b420729da134fccd160090c2a5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4b420729da134fccd160090c2a5701">&#9670;&nbsp;</a></span>reportVoxieWind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportVoxieWind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exposes all the variables from the internal (vw) <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> onto the secondary (touch) screen. </p>
<p>Intended for debug purposes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position of the report </td></tr>
    <tr><td class="paramname">posY</td><td>the Y position of the report </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a15b83b28e4096ec5efc4cedbed095598">IVoxieBox</a>.</p>

</div>
</div>
<a id="a053ccdfa875f9de492ac8dc0ce006bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053ccdfa875f9de492ac8dc0ce006bb5">&#9670;&nbsp;</a></span>reportVoxieWind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::reportVoxieWind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxie__wind__t.html">voxie_wind_t</a> *&#160;</td>
          <td class="paramname"><em>VW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exposes all the variables of a <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct onto the secondary (touch) screen. </p>
<p>Intended for debug purposes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>the X position of the report </td></tr>
    <tr><td class="paramname">posY</td><td>the Y position of the report </td></tr>
    <tr><td class="paramname">VW</td><td>a pointer fo the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct to report on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f58cd3799f8c4146d7c662afc9e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f58cd3799f8c4146d7c662afc9e3ac">&#9670;&nbsp;</a></span>scrollCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::scrollCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offSet</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a scrolling color as an RGB hexidemical value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offSet</td><td>offset (any whole number) to offset the color cycle to a different period in the cycle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>color as an RGB hexidemical value </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a763448fa982dc3ab4a5d9a3c4eaefe61">IVoxieBox</a>.</p>

</div>
</div>
<a id="a6130d995104d6656a06161870e8ea725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6130d995104d6656a06161870e8ea725">&#9670;&nbsp;</a></span>setAspect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAspect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>newAspect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAspect</td><td>the new aspect ratios for the volumetric display. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af296413187cbf4aed4aa1fa98f4464a7">IVoxieBox</a>.</p>

</div>
</div>
<a id="aaf47390b8cd637ea529ee3703760207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf47390b8cd637ea529ee3703760207b">&#9670;&nbsp;</a></span>setAspectX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAspectX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newAspectX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s X aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAspectX</td><td>the new Aspect X value to apply. th </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a20672401eeafeddeed2623bb36f2d5f6">IVoxieBox</a>.</p>

</div>
</div>
<a id="a2c4dd3e7e0e36fe288f37982e0523c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4dd3e7e0e36fe288f37982e0523c1b">&#9670;&nbsp;</a></span>setAspectY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAspectY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newAspectY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s Y aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAspectY</td><td>the new Aspect Y value to apply. th </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a23645e8a469c039394fc920de531db1b">IVoxieBox</a>.</p>

</div>
</div>
<a id="af0beb44d99ce82e52c19033641e3ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0beb44d99ce82e52c19033641e3ee53">&#9670;&nbsp;</a></span>setAspectZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAspectZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newAspectZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s Z aspect ratio value and update the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAspectZ</td><td>the new Aspect Z value to apply. th </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a9abe1bd83adaeed8555af23e663775e3">IVoxieBox</a>.</p>

</div>
</div>
<a id="a46e420ba18c63d86a4577fb5472ec7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e420ba18c63d86a4577fb5472ec7e6">&#9670;&nbsp;</a></span>setAudioPlayCallBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAudioPlayCallBack </td>
          <td>(</td>
          <td class="paramtype">void(*)(int *sampleBuffer, int sampleRate)&#160;</td>
          <td class="paramname"><em>userplayfunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a custom audio callback function to play PCM / raw audio data. </p>
<p>This function is used to play PCM / audio data (not a file).</p>
<p>If used, this function will be called from a separate thread, every 3ms (for Voxiebox mode), or every 20ms (for emulated mode). Format is set by Voxiebox library. To get sample rate and number of channels, read samprate and nchans from the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> structure after the call to voxie_init(). The sample format is always signed 32-bit integers, with the PCM located in the least significant 24 bits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userplayfunc</td><td>the custom call back function </td></tr>
    <tr><td class="paramname">*sampleBuffer</td><td>the sample audio buffer passed in from memory </td></tr>
    <tr><td class="paramname">sampleRate</td><td>the sample rate of the audio (determined by the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> vw.playsamprate) <pre class="fragment">     @example // An example of an custom audio callback.
               // Once called this function will always be called on a seperate thread. Use a global varible to turn it on / off
           static int gPlaySound = -1; // if this is set to 0 it will mute. It will play when set to -1 
           static int frequencyToPlay = 26162; // middle C note
           static void simplemix (int *ibuf, int nsamps)
           {
               static int cnt[2]; 
               int i, c; // c is number of channels to play (vw.playnchans)

                   for(i=0;i&lt;nsamps;i++,ibuf+=vw.playnchans)
                   for(c=min(vw.playnchans,2)-1;c&gt;=0;c--)
                   { ibuf[c] = ((cnt[c]&amp;(1&lt;&lt;20))-(1&lt;&lt;19))&amp;gPlaySound; cnt[c] += frequencyToPlay; }
           }


     Now that a custom audio callback has been defined. Call it within your VX program and it should play. 
</pre> Note : The playback function will continue to be called until stopped. To kill the call back overwrite the user function with a 0 by writing playPCMData(0) in your program. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="a1cd5f1ed65146b38989ae45430ed8a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd5f1ed65146b38989ae45430ed8a52">&#9670;&nbsp;</a></span>setAudioRecordCallBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setAudioRecordCallBack </td>
          <td>(</td>
          <td class="paramtype">void(*)(int *sampleBuffer, int sampleRate)&#160;</td>
          <td class="paramname"><em>userrecfunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a custom audio callback function to record PCM audio data (not a file) </p>
<p>this function is used to capture audio from the device. How to use this function is still being documented important <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> variables to have set before recordng. int recsamprate; //recording sample rate - to use, must write before voxie_init() int recnchans; //number of audio channels in recording callback </p>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="a00690aafd4ba31250980297091bde565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00690aafd4ba31250980297091bde565">&#9670;&nbsp;</a></span>setColScrollSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setColScrollSpeed </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the speed of the internal color scroller default is 0.1. Value is how long in seconds before a color change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>how long in seconds before a color change. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a09483ceacfeaa1b8145402b66be80b39">IVoxieBox</a>.</p>

</div>
</div>
<a id="af71d54273bfe9ded3d64aa44dd03af27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71d54273bfe9ded3d64aa44dd03af27">&#9670;&nbsp;</a></span>setGlobalShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setGlobalShader </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>horizontalAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>verticalAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amplitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>changes the global normal vector (vw.normhax) for shading. </p>
<p>Pass in three 0's to disable. Alters the global normal vector for shading. Shading only works with models which have vertices Pass 3 0's to disable shading. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">horizontalAngle</td><td>the horizontal angle -180 to 180 </td></tr>
    <tr><td class="paramname">verticalAngle</td><td>the vertical angle -90 to 90 </td></tr>
    <tr><td class="paramname">amplitude</td><td>the amplitude (intensity) 0 to 100 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab6e9f374fb93e42c1a94ad11a161c7c2">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0eb8993bdc46f151be65314e05c8ef5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb8993bdc46f151be65314e05c8ef5f">&#9670;&nbsp;</a></span>setJoyDeadZone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setJoyDeadZone </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deadZoneValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the internal dead zone value for game controlers. (dead zone is the area where not input is detected). Value between 0 and 1. 0 = no deadzone. 1 = all deadzone. default is 0.3;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadZoneValue</td><td>the value to set the deadzone threshold a number between 0 and 1 0 no deadzone... 1 deadzone everywhere default is 0.3 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a2012c4add882094b68075d002f3b2aee">IVoxieBox</a>.</p>

</div>
</div>
<a id="a43ff3b5678ba8d2e676fc73e7dd980ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ff3b5678ba8d2e676fc73e7dd980ff">&#9670;&nbsp;</a></span>setJoyOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setJoyOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the orientation of the users intended position when using a game controller. At what side are they facing towards the volumetric display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controllerID</td><td>the ID number of the controller you want to adjust (0,1,2,3) </td></tr>
    <tr><td class="paramname">orientation</td><td>of the controller 0 = front, 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a699e96b98e9b9731a072932a67935e21">IVoxieBox</a>.</p>

</div>
</div>
<a id="a1b196d4bc33271a26c62e140cd300ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b196d4bc33271a26c62e140cd300ea5">&#9670;&nbsp;</a></span>setJoyVibrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setJoyVibrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>leftMotorSpeed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rightMotorSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activates vibration motors in XBox controller. XInput controllers only. To stop Be sure to call again with lmot=0.f, rmot=0.f! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>which controller to set (0-3) </td></tr>
    <tr><td class="paramname">leftMotorSpeed</td><td>left motor speed (0.f-1.f, 0.f=off) </td></tr>
    <tr><td class="paramname">rightMotorSpeed</td><td>right motor speed (0.f-1.f, 0.f=off) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a1c20675ca3c129f2c337a39bda471096">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae999930f0ca537140166cbcfcbd301f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae999930f0ca537140166cbcfcbd301f4">&#9670;&nbsp;</a></span>setLeds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setLeds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dispNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set LEDs values on projector hardware. </p>
<p>WARNING: Be careful not to overheat projector! Range per component: 0:darkest, 255:brightest WARNING: Be careful not to overheat projector! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispNum</td><td>the display's number to adjust </td></tr>
    <tr><td class="paramname">r</td><td>the LED value for the red channel {0..128} (go over 128 at your own risk!) </td></tr>
    <tr><td class="paramname">g</td><td>the LED value for the green channel {0..128} (go over 128 at your own risk!) </td></tr>
    <tr><td class="paramname">b</td><td>the LED value for the blue channel {0..128} (go over 128 at your own risk!) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af2a8dfcdc1f9e3825c5deed335104340">IVoxieBox</a>.</p>

</div>
</div>
<a id="a4c75929ecde4250e3cdec02a4c94be76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c75929ecde4250e3cdec02a4c94be76">&#9670;&nbsp;</a></span>setMaskPlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setMaskPlane </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call after each <a class="el" href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304" title="Set a custom view.">VoxieBox::setView()</a> to mask off a plane of a specified thickness. </p>
<p>Used for viewing a slice of a scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>x point on the center of the mask plane </td></tr>
    <tr><td class="paramname">y0</td><td>y point on the center of the mask plane </td></tr>
    <tr><td class="paramname">z0</td><td>z point on the center of the mask plane </td></tr>
    <tr><td class="paramname">nx</td><td>The normal vector; the magnitude of this vector determines the thickness of the plane. </td></tr>
    <tr><td class="paramname">ny</td><td>The normal vector; the magnitude of this vector determines the thickness of the plane. </td></tr>
    <tr><td class="paramname">nz</td><td>The normal vector; the magnitude of this vector determines the thickness of the plane. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a96bca4d699ede45200e0433f866dad28">IVoxieBox</a>.</p>

</div>
</div>
<a id="af8e9198d489a52c186090f1a1f0589f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e9198d489a52c186090f1a1f0589f1">&#9670;&nbsp;</a></span>setMouseDoubleClickThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setMouseDoubleClickThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time between mouse clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb" title="Returns 1 if particular Mouse&#39;s buttonCode has been clicked twice within the double click threshold.">getMouseDoubleClick()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeThreshold</td><td>the time in seconds for 2 clicks to register as a 'double click' Note use with <a class="el" href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb" title="Returns 1 if particular Mouse&#39;s buttonCode has been clicked twice within the double click threshold.">VoxieBox::getMouseDoubleClick()</a> to register double clicks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#af5a19c0708fa54178016751597357bcb" title="Returns 1 if particular Mouse&#39;s buttonCode has been clicked twice within the double click threshold.">VoxieBox::getMouseDoubleClick()</a> </dd>
<dd>
<a class="el" href="class_voxie_box.html#aea4ffb974a7b7ed79159d281ab053643" title="Returns the mouse double click threshold. (how quickly 2 mouse clicks signify a &#39;double click&#39;)....">VoxieBox::getMouseDoubleClickThreshold()</a> </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a1c627addffc2d9d14e4483fcac080536">IVoxieBox</a>.</p>

</div>
</div>
<a id="a9a99b13f647843d26d5a2ac773120698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a99b13f647843d26d5a2ac773120698">&#9670;&nbsp;</a></span>setMouseOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setMouseOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the orientation of the user's intended position when using the mouse </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>the orientation of the controller 0 = front, 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5fb98b15f6632fd78d9847d9668e1ec8">IVoxieBox</a>.</p>

</div>
</div>
<a id="abdb94038629b4f11362e2c09981f1168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb94038629b4f11362e2c09981f1168">&#9670;&nbsp;</a></span>setMousePosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setMousePosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>newPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides internal mouse position with a new <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> position. </p>
<p>Useful to jump / move the mouse cursor to a specific part of the display.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPos</td><td>(x, y, z) positional information of where to set new mouse position </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a04a9d805f040772ae5ad94d1a40ecf41">IVoxieBox</a>.</p>

</div>
</div>
<a id="a19870dae738a7c8214ea9d23580b8c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19870dae738a7c8214ea9d23580b8c19">&#9670;&nbsp;</a></span>setMouseState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setMouseState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a>&#160;</td>
          <td class="paramname"><em>newMouse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override the internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> mouse state. </p>
<p>Probably not that useful but its here for some advanced usecase see voxie_inputs_t to understand the mouse structure*</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newMouse</td><td>the new mouse settings to pass in (pass in a full voxie_inputs_t struct) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aa7de3e291b17820de8ffba7e59898a70">IVoxieBox</a>.</p>

</div>
</div>
<a id="a64e5853eae6ad4f8da0048fc9fae2913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e5853eae6ad4f8da0048fc9fae2913">&#9670;&nbsp;</a></span>setNavDeadZone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setNavDeadZone </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deadZoneValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the internal deadzone for Space Navigators. (dead zone is the area where not input is detected) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadZoneValue</td><td>new value to set deadzone. For Space Navigators between 0 and 350. default is 0.1 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a6188af660d3a0b20f4b5933e7fd3b04d">IVoxieBox</a>.</p>

</div>
</div>
<a id="a33485d39d396339de3d3be5241886c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33485d39d396339de3d3be5241886c8b">&#9670;&nbsp;</a></span>setNavDoubleClickThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setNavDoubleClickThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeThreshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the time between Space Nav clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51" title="Returns 1 if particular Space Nav&#39;s buttonCode has been clicked twice within the double click thresho...">getNavDoubleClick()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeThreshold</td><td>the time in seconds for 2 clicks to register as a 'double click' Note use with <a class="el" href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51" title="Returns 1 if particular Space Nav&#39;s buttonCode has been clicked twice within the double click thresho...">VoxieBox::getNavDoubleClick()</a> to register double clicks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html#a5194f3ae9e1e488f13dedc06631b2a51" title="Returns 1 if particular Space Nav&#39;s buttonCode has been clicked twice within the double click thresho...">VoxieBox::getNavDoubleClick()</a> </dd>
<dd>
<a class="el" href="class_voxie_box.html#a040618235390a1e8457be8bafca4eab3">VoxieBox::getNavDoubleClickThreshold()</a> </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ac422e15001ee6e8a5b5ae76aa7496e75">IVoxieBox</a>.</p>

</div>
</div>
<a id="af2be6e36f3e52ae33ef46b1d281196a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2be6e36f3e52ae33ef46b1d281196a0">&#9670;&nbsp;</a></span>setNavOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setNavOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the orientation of the user's intended position when using a Space Nav </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the spaceNav you want to edit (0,1,2,3) </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the controller 0 = front, 1 = 180 ' (behind), 2 = 90 ' CCW (right side), 3 = 90 ' CW (left side) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#aa50e4728e2e2597217859c93b58bd5d5">IVoxieBox</a>.</p>

</div>
</div>
<a id="acdc0196ee995635d7b1c6b955456f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc0196ee995635d7b1c6b955456f9a9">&#9670;&nbsp;</a></span>setNavSensitivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setNavSensitivity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Space Nav's sensitivity. Used to manage the Space Nav being used as a cursor. 0.0025 is default. Higher values increase sensitivity <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNavID</td><td>the ID number of the Space Nav to check (0 = 1st detected, 1 = 2nd detected etc) </td></tr>
    <tr><td class="paramname">newAmount</td><td>the new sensitivity amount. 0.0025 is default. Higher values increase sensitivity </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a19452403f70dbf2b559ace0a015d2a51">IVoxieBox</a>.</p>

</div>
</div>
<a id="ab9f84d5dea8b5861ee9f31101b7374c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f84d5dea8b5861ee9f31101b7374c1">&#9670;&nbsp;</a></span>setProject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setProject </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dispNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>yo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advanced utility function for keystone calibration (used by graphcalc and keystone calibration in voxiedemo) see the source code for voxiedemo.c for an understanding of how this works. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disp</td><td>display number: {0..vw.dispnum-1} </td></tr>
    <tr><td class="paramname">dir</td><td>direction. 1=forward, -1=inverse </td></tr>
    <tr><td class="paramname">x</td><td>x input point; {-1.f .. +1.f} </td></tr>
    <tr><td class="paramname">y</td><td>y input point; {-1.f .. +1.f} </td></tr>
    <tr><td class="paramname">z</td><td>input plane: {0 .. vw.framepervol*24-1} </td></tr>
    <tr><td class="paramname">xo</td><td>xo keystone adjusted output point </td></tr>
    <tr><td class="paramname">yo</td><td>yo keystone adjusted output point </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a1a677a4d66dd2df77b923cb37f7f7d58">IVoxieBox</a>.</p>

</div>
</div>
<a id="ab04a95bae0c856c9d1b22f1902673304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04a95bae0c856c9d1b22f1902673304">&#9670;&nbsp;</a></span>setView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setView </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a custom view. </p>
<p>Usually you'll pass in the voxie windows's (<a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>) aspect values but it can be used like 'camera' and be moved around by passing in different values.</p>
<p>You may call this function any number of times during rendering. This function is called automatically during the <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">VoxieBox::startFrame()</a> function. it is passed with internal vw voxie_window_t aspect ratio values.</p>
<p>Checks to see if invertZAxis is enabled and applies swap if needed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xMin</td><td>minimum x resolution (left) </td></tr>
    <tr><td class="paramname">yMin</td><td>minimum y resolution (up) </td></tr>
    <tr><td class="paramname">zMin</td><td>minimum z resolution (top) </td></tr>
    <tr><td class="paramname">xMax</td><td>maximum x resolution (right) </td></tr>
    <tr><td class="paramname">yMax</td><td>maximum y resolution (down) </td></tr>
    <tr><td class="paramname">zMax</td><td>maximum z resolution (bottom) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a36b4ee4d822f845faf8173ff8de2a010">IVoxieBox</a>.</p>

</div>
</div>
<a id="ae4a65f94d8985cbfc3f1520f5660c2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a65f94d8985cbfc3f1520f5660c2fc">&#9670;&nbsp;</a></span>setView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::setView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>LUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a>&#160;</td>
          <td class="paramname"><em>RDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same <a class="el" href="class_voxie_box.html#ab04a95bae0c856c9d1b22f1902673304" title="Set a custom view.">setView()</a> but using point3D for coordinates instead of 6 floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUT</td><td>the Left, Upper, Top position </td></tr>
    <tr><td class="paramname">RDB</td><td>the Right, Down, Bottom position </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#af55810cc08843c3e0604ed9e05d33e46">IVoxieBox</a>.</p>

</div>
</div>
<a id="a472d7b26a2a8ae7b80a50d378ee79d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472d7b26a2a8ae7b80a50d378ee79d9e">&#9670;&nbsp;</a></span>showVPS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::showVPS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Displays volumes per second (volumetric equivalent of 'FPS') and version info on the secondary (touch) screen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posX</td><td>X position for output </td></tr>
    <tr><td class="paramname">posY</td><td>Y position for output </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a35f80b0f5ccae394bf27e80d8f2cae55">IVoxieBox</a>.</p>

</div>
</div>
<a id="aad425b1e77b65a3a1131fc281d85a546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad425b1e77b65a3a1131fc281d85a546">&#9670;&nbsp;</a></span>sphereCollideChk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::sphereCollideChk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>sphereAPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphereARadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpoint3d.html">point3d</a> *&#160;</td>
          <td class="paramname"><em>sphereBPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sphereBRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showCollisionBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sphere collision check. Check if two spheres are touching. Returns 1 if collision is found otherwise returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphereAPos</td><td>pointer of first sphere's position </td></tr>
    <tr><td class="paramname">sphereARadius</td><td>first sphere's radius </td></tr>
    <tr><td class="paramname">sphereBPos</td><td>pointer of second sphere's position </td></tr>
    <tr><td class="paramname">sphereBRadius</td><td>second sphere's radius </td></tr>
    <tr><td class="paramname">showCollisionBox</td><td>For debugging set to false by default. Set to true to render the collision box onto the volumetric display. (Note : The collision check must be called within the start and end frame)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a collision and 0 if not </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ab72d6b411561d8a2f23efb42e8e33687">IVoxieBox</a>.</p>

</div>
</div>
<a id="a54b4793427d2d728cea01e1daa8893f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b4793427d2d728cea01e1daa8893f3">&#9670;&nbsp;</a></span>startFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::startFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start building the frame buffer. </p>
<p>All volumetric and secondary (touch) screen draw calls need to happen between <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">VoxieBox::startFrame()</a> and <a class="el" href="class_voxie_box.html#a72d9b0954c410adf2323473e0ececcd2" title="function to signify the end of a volumetric frame.">VoxieBox::endFrame()</a> the startframe() function prepares the vxTypes::voxie_frame_t struct to start a new frame and empty out the voxel buffer. any draw call used after this point is loaded into the voxel buffer. the <a class="el" href="class_voxie_box.html#a54b4793427d2d728cea01e1daa8893f3" title="start building the frame buffer.">startFrame()</a> function uses the internal vf <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> to manage its voxel data. It is possible for a developer to write directly to the vf for their own low-level drawing.</p>
<p>The startFrame function also sets the view to the correct aspect ration (traditionally a user would call 'voxie_setview()' after the frame to set the views dimentions) the startFrame function also draws a border around the display (if <a class="el" href="class_voxie_box.html#adfb378549c1bf96b3b3594425f4a1bfa" title="toggles a white border around the perimeter of the volumetric display.">VoxieBox::setBorder()</a> has been set to true) </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9">IVoxieBox</a>.</p>

</div>
</div>
<a id="a0698a2ecfef631c2e021b3b8fe8ddee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0698a2ecfef631c2e021b3b8fe8ddee7">&#9670;&nbsp;</a></span>touchAddCustomLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::touchAddCustomLayout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtouchkey__t.html">touchkey_t</a> *&#160;</td>
          <td class="paramname"><em>touchkey</em> = <code><a class="el" href="vx_input_types_8h.html#a9cd8ea1ad292fb3d042f2436b6b6e276">default_touchkey</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfArray</em> = <code>sizeof(<a class="el" href="vx_input_types_8h.html#a9cd8ea1ad292fb3d042f2436b6b6e276">default_touchkey</a>)&#160;/&#160;sizeof(<a class="el" href="structtouchkey__t.html">touchkey_t</a>)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add custom touch keys. (enable touch keyboard under 'Misc' menu tab) </p>
<pre class="fragment">pass through an array of const touchkey_t setup your own custom touch screen layout
Make sure 'touch controls' are enabled via on the misc. tab on the VoxieMenu
@params const touchkey_t * touchkey     pointer to an array of const touchkey_t structs with definitions. 
@params int  sizeOfArray                size of how many touch buttons in the array to add

Note : call touchAddCustomLayout(NULL,NULL) to return to default layout
each touchkey_t struct contains one key the params are

            char*   title       - the title of the key
            int     xpos        - the x position of where to draw the touch button
            int     ypos        - the y position of where to draw the touch button
            int     xsize       - the size or the horizontal length of the button written as pixels
            int     ysize       - the size or the horizontal length of the button written as pixels
            int     frontColor  - the hexadecimal color value for the button
            int     backColor   - the hexadecimal color value for the button's background. -1 for transparent
            int     scanCode    - the scancode / keyboard scan code * 256 + ASCII code (0 if N/A).

            Note special keycodes for mouse: Mouse:0x0000, LBut:0x0001, RBut:0x0002, MBut:0x0003
</pre><p> To make a custom function callback link the <a class="el" href="structtouchkey__t.html" title="Manages custom touch keys displayed on the 2D secondary (touch) screen.">touchkey_t</a> struct to a scancode that isn't being used for example (0x8080, 0x8181) Scan codes used: ASCII codes used: 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 . . . . 08 09 . . . 0d . . 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f . . . . . . . . . . . 1b . . . . 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 20 . . . . . . 27 . . 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 30 31 32 33 34 35 36 37 38 39 . 3b . 3d . . 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f . . . . . . . . . . . . . . . . 50 51 52 53 . . . 57 58 . . . . . . . . . . . . . . . . . . 5b 5c 5d . . &lt;&ndash;0x54..0x56 (3), 0x59..0x5a (2), 0x5e..0x5f (2) . . . . . . . . . . . . . . . . 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f . . . . . . . . . . . . . . . . 70 71 72 73 74 75 76 77 78 79 7a . . . . . &lt;&ndash;0x7b..0x9b (33) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9c 9d . . . . . . . . . . . . . . . . . . &lt;&ndash;0x9e..0xb4 (23) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . b5 . b7 b8 . . . . . . . . . . . . . . . . . . . . . . . &lt;&ndash;0xb9..0xc4 (12) . . . . . c5 . c7 c8 c9 . cb . cd . cf . . . . . . . . . . . . . . . . d0 d1 d2 d3 . . . . . . . . . dd . . . . . . . . . . . . . . . . . . &lt;&ndash;0xd4..0xdc (9), 0xde..0xff (34) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . </p><pre class="fragment">            example: 
            touchkey_t = { "Touch\nonly\nFunc0", 80,100,200,200,0x405060,-1,0x8080 };
            voxie-&gt;getKeyIsDown(0x80) { ... your custom function here ... }
</pre><p>to actually see the custom touch controls you need to have TOUCH CONTROLLS ENABLED by default they are turned off - they can be turned on by pressing the button in the 'misc' menu or adding 'touchcontrols=1' to voxiebox.ini </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#af32547c7364d319179680868189879e1">IVoxieBox</a>.</p>

</div>
</div>
<a id="a7fcbfb676db6668d6f3da9139b5382dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcbfb676db6668d6f3da9139b5382dc">&#9670;&nbsp;</a></span>tweenCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::tweenCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destcolor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tweens a color to the destination color. good for fade outs or tweens. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>the color value to tween. </td></tr>
    <tr><td class="paramname">speed</td><td>the speed or rate of the color change </td></tr>
    <tr><td class="paramname">destcolor</td><td>the destination color. The color to tween to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a new color value that is one step closer to the destination color. </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#ae08bd1dd4231ff500b57bd79b5875aef">IVoxieBox</a>.</p>

</div>
</div>
<a id="a88ab69387e02516d39dcb21c0bc2d34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ab69387e02516d39dcb21c0bc2d34d">&#9670;&nbsp;</a></span>updateJoyState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::updateJoyState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>controllerID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxie__xbox__t.html">voxie_xbox_t</a> *&#160;</td>
          <td class="paramname"><em>vx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the game controller's input state. Used to manage game controller inputs when <a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> is set to true. </p>
<p>Use this function to manually update gamepad inputs. The return state is designed to be used within a for loop. This function is only needed when <a class="el" href="class_voxie_box.html#adedb5dc6e4d9d0109b5ae999d933457d" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> is set to true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>which controller to query (0-3) </td></tr>
    <tr><td class="paramname"><a class="el" href="structvoxie__xbox__t.html" title="USB game controller input state struct. Used to manage USB game controller input.">voxie_xbox_t</a></td><td>structure to be filled in by function (if successful) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 = success (safe to check next controller (id+1)) , 0=fail </dd></dl>

<p>Implements <a class="el" href="class_i_voxie_box.html">IVoxieBox</a>.</p>

</div>
</div>
<a id="abbb7fb316be13efd98f26e623aeb03b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb7fb316be13efd98f26e623aeb03b3">&#9670;&nbsp;</a></span>updateMenu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::updateMenu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Once the menu is created, use this function to update a string, button status, or slider value. </p>
<p>In the menu item. It will change the menu items for any id values that match. If st is null, it will be left alone. 'state' is the status of a menu button (0=up, 1=down), and 'v' is the value for sliders. If a field is not applicable, just pass a 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the menu item </td></tr>
    <tr><td class="paramname">st</td><td>changing the text (if applicable) </td></tr>
    <tr><td class="paramname">state</td><td>the state of the item (if applicable) </td></tr>
    <tr><td class="paramname">v</td><td>the value (if applicable) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a5b5075aa133b8e42a69b4c9c3d26af57">IVoxieBox</a>.</p>

</div>
</div>
<a id="a70a760d5670b3588aa95f97f831200bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a760d5670b3588aa95f97f831200bd">&#9670;&nbsp;</a></span>updateNavState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int VoxieBox::updateNavState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxie__nav__t.html">voxie_nav_t</a> *&#160;</td>
          <td class="paramname"><em>nav</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies 3DConnexion Space Navigator controller state to <a class="el" href="structvoxie__nav__t.html" title="3D SpaceMouse / Space Navigator by 3DConnexion input state struct. Used to manage SpaceNav input">voxie_nav_t</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>which controller to query (ignored for now) </td></tr>
    <tr><td class="paramname">nav</td><td>structure to be filled in by function (if successful) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1=success (safe to check next controller (id+1)), 0=fail</dd></dl>
<p>Works similar to <a class="el" href="class_voxie_box.html#a88ab69387e02516d39dcb21c0bc2d34d" title="Updates the game controller&#39;s input state. Used to manage game controller inputs when setEnableLegacy...">VoxieBox::updateJoyState()</a> use if <a class="el" href="class_voxie_box.html#a742aca3dfb890fb71c34bc0910f9483a" title="Set to true to handle Nav input manually. Disables many of the nav input functions....">setEnableLegacyNavInput()</a> is set to true. Otherwise Nav updates are maintained by VxCpp.dll </p>

<p>Implements <a class="el" href="class_i_voxie_box.html#a038123df60149d6367a0da9903de1517">IVoxieBox</a>.</p>

</div>
</div>
<a id="a059069f0ecf2a149bbd8775e52613397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059069f0ecf2a149bbd8775e52613397">&#9670;&nbsp;</a></span>updateSound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VoxieBox::updateSound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volumeLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volumeRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>playBackSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update a currently playing sound. </p>
<p>Use a returned voxie::playSound value as the handle (an int that is assigned to that specific sound) update a sound is great for fades or adjusting volumes set the volperc0, or volperc1 use to a negative number to turn off the sound and free it from memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>the current sound to handleID to effect (use the int that gets returned when using <a class="el" href="class_voxie_box.html#ace99015ec6f52f91cc0c80f9e8236385" title="Plays a sound (can be WAV, FLAC, MP3, M4A)">VoxieBox::playSound()</a> ) </td></tr>
    <tr><td class="paramname">sourceChannel</td><td>which channel of WAV or FLAC to extract (0 left, 1 right, -1 stereo, -2 left + right) </td></tr>
    <tr><td class="paramname">volumeLeft</td><td>% of full volume to left channel {0..100, although may exceed 100} set to -1 to turn off </td></tr>
    <tr><td class="paramname">volumeRight</td><td>% of full volume to right channel {0..100, although may exceed 100} set to -1 to turn off </td></tr>
    <tr><td class="paramname">playBackSpeed</td><td>frequency scaling. use 1.0 for default sample rate, 2.0 for 1 octave up, 0.5 for 1 octave down... etc </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_i_voxie_box.html#a1d10e13ce4ce1596eda1ded2b9e3a6d6">IVoxieBox</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vx_c_p_p_8h_source.html">vxCPP.h</a></li>
<li>VoxieBox.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
