<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VX++ Framework (VxCpp.dll): IVoxieBox Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="vx++ logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VX++ Framework (VxCpp.dll)
   </div>
   <div id="projectbrief">Friendly Voxon development with classes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_voxie_box-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IVoxieBox Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class.  
 <a href="class_i_voxie_box.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vx_c_p_p_8h_source.html">vxCPP.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IVoxieBox:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_voxie_box.png" usemap="#IVoxieBox_map" alt=""/>
  <map id="IVoxieBox_map" name="IVoxieBox_map">
<area href="class_voxie_box.html" title="VoxieBox class." alt="VoxieBox" shape="rect" coords="0,56,68,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0814d9392e461322f177e41026754e8"><td class="memItemLeft" align="right" valign="top"><a id="af0814d9392e461322f177e41026754e8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af0814d9392e461322f177e41026754e8">breath</a> ()=0</td></tr>
<tr class="memdesc:af0814d9392e461322f177e41026754e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 'breath' is the 'update loop' for a VX application. A single breath is a single volume. <a class="el" href="class_i_voxie_box.html#af0814d9392e461322f177e41026754e8" title="A &#39;breath&#39; is the &#39;update loop&#39; for a VX application. A single breath is a single volume....">breath()</a> passes in the default voxie_window and input. <br /></td></tr>
<tr class="separator:af0814d9392e461322f177e41026754e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd2a46b41c146060e1c8e3a9f265af"><td class="memItemLeft" align="right" valign="top"><a id="abadd2a46b41c146060e1c8e3a9f265af"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#abadd2a46b41c146060e1c8e3a9f265af">breath</a> (<a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> *input)=0</td></tr>
<tr class="memdesc:abadd2a46b41c146060e1c8e3a9f265af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breath() function which can be used with customised input struct. <br  />
 <br /></td></tr>
<tr class="separator:abadd2a46b41c146060e1c8e3a9f265af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7dedd2c220cf2f62470697d760cef9"><td class="memItemLeft" align="right" valign="top"><a id="ace7dedd2c220cf2f62470697d760cef9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9">startFrame</a> ()=0</td></tr>
<tr class="memdesc:ace7dedd2c220cf2f62470697d760cef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies the start of the volumetric frame. Call this once before all draw calls. Prepares the internal vf <a class="el" href="vx_data_types_8h.html#aff14bc4149a64fdde65553db5e3df451" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t()</a> voxel buffer to receive volumetric content. <br  />
 <br /></td></tr>
<tr class="separator:ace7dedd2c220cf2f62470697d760cef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78f083e60d771b7885bd65f5b78d22c"><td class="memItemLeft" align="right" valign="top"><a id="ae78f083e60d771b7885bd65f5b78d22c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c">endFrame</a> ()=0</td></tr>
<tr class="memdesc:ae78f083e60d771b7885bd65f5b78d22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer to the volumetric and secondary screen. <br /></td></tr>
<tr class="separator:ae78f083e60d771b7885bd65f5b78d22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58e59fff5de3873576a1252d2f9e7d0"><td class="memItemLeft" align="right" valign="top"><a id="ad58e59fff5de3873576a1252d2f9e7d0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad58e59fff5de3873576a1252d2f9e7d0">quitLoop</a> ()=0</td></tr>
<tr class="memdesc:ad58e59fff5de3873576a1252d2f9e7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces <a class="el" href="class_voxie_box.html#a0cd2ee2048f4b560910621c693709270" title="The &#39;update loop&#39; for a VX application also updates voxie_input_t struct.">VoxieBox::breath()</a> to return non-zero on its next call. Usually called when you want the program to quit. <br /></td></tr>
<tr class="separator:ad58e59fff5de3873576a1252d2f9e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c3a0665d45721b1a55546a7b83432"><td class="memItemLeft" align="right" valign="top"><a id="a4e0c3a0665d45721b1a55546a7b83432"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4e0c3a0665d45721b1a55546a7b83432">shutdown</a> ()=0</td></tr>
<tr class="memdesc:a4e0c3a0665d45721b1a55546a7b83432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the VoxieBox.DLL from memory and allows the file to be accessed by other processes. <br /></td></tr>
<tr class="separator:a4e0c3a0665d45721b1a55546a7b83432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98efc8de5deeb9879275dfe6df935006"><td class="memItemLeft" align="right" valign="top"><a id="a98efc8de5deeb9879275dfe6df935006"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a98efc8de5deeb9879275dfe6df935006">init</a> ()=0</td></tr>
<tr class="memdesc:a98efc8de5deeb9879275dfe6df935006"><td class="mdescLeft">&#160;</td><td class="mdescRight">First time it is called it initialise the <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>. Subsequent calls updates the VoxieBox.dll's voxie window struct. <br /></td></tr>
<tr class="separator:a98efc8de5deeb9879275dfe6df935006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9633fb5e93bf01195d820d386737695b"><td class="memItemLeft" align="right" valign="top"><a id="a9633fb5e93bf01195d820d386737695b"></a>
virtual <a class="el" href="structvoxie__wind__t.html">voxie_wind_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9633fb5e93bf01195d820d386737695b">getVoxieWindow</a> ()=0</td></tr>
<tr class="memdesc:a9633fb5e93bf01195d820d386737695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> struct <br /></td></tr>
<tr class="separator:a9633fb5e93bf01195d820d386737695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04988c3b5c3c89c401cf14f638646f6f"><td class="memItemLeft" align="right" valign="top"><a id="a04988c3b5c3c89c401cf14f638646f6f"></a>
virtual <a class="el" href="structvoxie__frame__t.html">voxie_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a04988c3b5c3c89c401cf14f638646f6f">getVoxieFrame</a> ()=0</td></tr>
<tr class="memdesc:a04988c3b5c3c89c401cf14f638646f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the internal <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> struct <br /></td></tr>
<tr class="separator:a04988c3b5c3c89c401cf14f638646f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ed204a01e9d41183e39095c34e6c7"><td class="memItemLeft" align="right" valign="top"><a id="adb2ed204a01e9d41183e39095c34e6c7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#adb2ed204a01e9d41183e39095c34e6c7">setBorder</a> (bool option, int color=0xffffff)=0</td></tr>
<tr class="memdesc:adb2ed204a01e9d41183e39095c34e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles a white border around the perimeter of the volumetric display. Set to false by default. <br /></td></tr>
<tr class="separator:adb2ed204a01e9d41183e39095c34e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab250d5079c5302d783d96bccfed4bd"><td class="memItemLeft" align="right" valign="top"><a id="acab250d5079c5302d783d96bccfed4bd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#acab250d5079c5302d783d96bccfed4bd">setEnableExitOnEsc</a> (bool option)=0</td></tr>
<tr class="memdesc:acab250d5079c5302d783d96bccfed4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles the use of the 'esc' key to escape a Voxon program (by calling <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop()</a>). Set to true by default. <br /></td></tr>
<tr class="separator:acab250d5079c5302d783d96bccfed4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c8a9abfb0edb855b327f2f5c7df608"><td class="memItemLeft" align="right" valign="top"><a id="a44c8a9abfb0edb855b327f2f5c7df608"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a44c8a9abfb0edb855b327f2f5c7df608">setEnableMouseClipping</a> (bool option)=0</td></tr>
<tr class="memdesc:a44c8a9abfb0edb855b327f2f5c7df608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles mouse clipping (cursor / position is always inside the volume) when using the <a class="el" href="class_voxie_box.html#ac567600c40003e62fbcf9ffe1aaf938b">VoxieBox::getMousePosition</a> or the <a class="el" href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839" title="draws a cursor unto the volumetric display at the position specified.">VoxieBox::drawCursor()</a> functions. Set to false by default. <br /></td></tr>
<tr class="separator:a44c8a9abfb0edb855b327f2f5c7df608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c686c003bc5dfc3aa9fdec3859fbcc4"><td class="memItemLeft" align="right" valign="top"><a id="a5c686c003bc5dfc3aa9fdec3859fbcc4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5c686c003bc5dfc3aa9fdec3859fbcc4">setEnableNavClipping</a> (bool option)=0</td></tr>
<tr class="memdesc:a5c686c003bc5dfc3aa9fdec3859fbcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles nav clipping (cursor / position is always inside the volume) when using the <a class="el" href="class_voxie_box.html#ad9440acc297003385583917cf2b60b8c" title="Return a point3d of the Nav&#39;s tracked position. Used primary when the Space Nav is being used as a cu...">VoxieBox::getNavPosition</a> or the <a class="el" href="class_voxie_box.html#aa1a30340112a8c0b2096209367d3a839" title="draws a cursor unto the volumetric display at the position specified.">VoxieBox::drawCursor()</a> functions. Set to false by default. <br /></td></tr>
<tr class="separator:a5c686c003bc5dfc3aa9fdec3859fbcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2ff5f0dd2bab02849e1f1461dfa12d"><td class="memItemLeft" align="right" valign="top"><a id="ade2ff5f0dd2bab02849e1f1461dfa12d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ade2ff5f0dd2bab02849e1f1461dfa12d">setCleanExitOnQuitLoop</a> (bool option)=0</td></tr>
<tr class="memdesc:ade2ff5f0dd2bab02849e1f1461dfa12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles when enabled and <a class="el" href="class_voxie_box.html#a6e9f69b448fecf7ef2c9e2413d5feb8c" title="Call this to tell Voxiebox library you want to exit the breath() loop and quit the application.">VoxieBox::quitLoop()</a> is called the Voxiebox library is freed from memory. Set to true by default. <br /></td></tr>
<tr class="separator:ade2ff5f0dd2bab02849e1f1461dfa12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af567af199a6e9ad14e2e63f2750dfac0"><td class="memItemLeft" align="right" valign="top"><a id="af567af199a6e9ad14e2e63f2750dfac0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af567af199a6e9ad14e2e63f2750dfac0">setJoyInputToXInput</a> ()=0</td></tr>
<tr class="memdesc:af567af199a6e9ad14e2e63f2750dfac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class to use the XInput API to read joystick inputs (for modern game controllers). <br /></td></tr>
<tr class="separator:af567af199a6e9ad14e2e63f2750dfac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ebffbdc4b5cf6e3cad6b472b54258"><td class="memItemLeft" align="right" valign="top"><a id="a6e9ebffbdc4b5cf6e3cad6b472b54258"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6e9ebffbdc4b5cf6e3cad6b472b54258">setJoyInputToDirectInput</a> ()=0</td></tr>
<tr class="memdesc:a6e9ebffbdc4b5cf6e3cad6b472b54258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class to use the DirectInput API to read joystick inputs (for older game controllers). Uses joyGetPosEx function. <br /></td></tr>
<tr class="separator:a6e9ebffbdc4b5cf6e3cad6b472b54258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b42c55a3d07f8c8fa458206c92f6f8"><td class="memItemLeft" align="right" valign="top"><a id="a42b42c55a3d07f8c8fa458206c92f6f8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a42b42c55a3d07f8c8fa458206c92f6f8">setEnableLegacyJoyInput</a> (bool option)=0</td></tr>
<tr class="memdesc:a42b42c55a3d07f8c8fa458206c92f6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to handle Joy input manually. Disables many of the joy input functions. Set to false by default. <br /></td></tr>
<tr class="separator:a42b42c55a3d07f8c8fa458206c92f6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610096748ee003388e308da1a9b56271"><td class="memItemLeft" align="right" valign="top"><a id="a610096748ee003388e308da1a9b56271"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a610096748ee003388e308da1a9b56271">setEnableLegacyTouchInput</a> (bool option)=0</td></tr>
<tr class="memdesc:a610096748ee003388e308da1a9b56271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to handle Touch input manually. Disables many of the touch input functions. Set to false by default. <br /></td></tr>
<tr class="separator:a610096748ee003388e308da1a9b56271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84837c998430ffe4177fda44c7926aef"><td class="memItemLeft" align="right" valign="top"><a id="a84837c998430ffe4177fda44c7926aef"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a84837c998430ffe4177fda44c7926aef">setEnableJoyDeadZone</a> (bool option)=0</td></tr>
<tr class="memdesc:a84837c998430ffe4177fda44c7926aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to give access to the touch screen (if disabled touching the screen will always bring up the Voxie Menu) <br /></td></tr>
<tr class="separator:a84837c998430ffe4177fda44c7926aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa10105e84a9f97b1348397737922f6"><td class="memItemLeft" align="right" valign="top"><a id="a1fa10105e84a9f97b1348397737922f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1fa10105e84a9f97b1348397737922f6">setEnableNavDeadZone</a> (bool option)=0</td></tr>
<tr class="memdesc:a1fa10105e84a9f97b1348397737922f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles a dead zone for Space Navigator. Set to true by default. <br /></td></tr>
<tr class="separator:a1fa10105e84a9f97b1348397737922f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb6a0cee9155fa29d381c8d87a09245"><td class="memItemLeft" align="right" valign="top"><a id="a1cb6a0cee9155fa29d381c8d87a09245"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1cb6a0cee9155fa29d381c8d87a09245">setEnableLegacyNavInput</a> (bool option)=0</td></tr>
<tr class="memdesc:a1cb6a0cee9155fa29d381c8d87a09245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to true to handle Nav input manually. Disables many of the nav input functions. Set to false by default. <br /></td></tr>
<tr class="separator:a1cb6a0cee9155fa29d381c8d87a09245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f111394f7fd4c77fd652986a146bcb3"><td class="memItemLeft" align="right" valign="top"><a id="a4f111394f7fd4c77fd652986a146bcb3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4f111394f7fd4c77fd652986a146bcb3">setEnableLegacyKeyInput</a> (bool option)=0</td></tr>
<tr class="memdesc:a4f111394f7fd4c77fd652986a146bcb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to false to disable the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class / VxCpp.dll to from managing gamepad / joy input handling. Set to false by default. <br /></td></tr>
<tr class="separator:a4f111394f7fd4c77fd652986a146bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0039e268ac3a4a84cac4410cdb5ea7"><td class="memItemLeft" align="right" valign="top"><a id="a6f0039e268ac3a4a84cac4410cdb5ea7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6f0039e268ac3a4a84cac4410cdb5ea7">setInvertZAxis</a> (bool option)=0</td></tr>
<tr class="memdesc:a6f0039e268ac3a4a84cac4410cdb5ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the Z axis. (by default - values are at the top of the screen and + values are below). Set to false by default. <br /></td></tr>
<tr class="separator:a6f0039e268ac3a4a84cac4410cdb5ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6a7fe0548aa9527155cd0f6d91b1ad"><td class="memItemLeft" align="right" valign="top"><a id="a2f6a7fe0548aa9527155cd0f6d91b1ad"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a2f6a7fe0548aa9527155cd0f6d91b1ad">getDeltaTime</a> ()=0</td></tr>
<tr class="memdesc:a2f6a7fe0548aa9527155cd0f6d91b1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in seconds the delta time(time between volumes) delta time is CPU speed dependent and can be used to make ensure timing is consistent between various computers / systems. <br /></td></tr>
<tr class="separator:a2f6a7fe0548aa9527155cd0f6d91b1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed88178f4b802a5a6a3c389427059b31"><td class="memItemLeft" align="right" valign="top"><a id="aed88178f4b802a5a6a3c389427059b31"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aed88178f4b802a5a6a3c389427059b31">getTime</a> ()=0</td></tr>
<tr class="memdesc:aed88178f4b802a5a6a3c389427059b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time (in seconds) from program execution till present. <br /></td></tr>
<tr class="separator:aed88178f4b802a5a6a3c389427059b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a21f1708565167f5995ac774b69f2"><td class="memItemLeft" align="right" valign="top"><a id="a5e9a21f1708565167f5995ac774b69f2"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5e9a21f1708565167f5995ac774b69f2">getVPS</a> ()=0</td></tr>
<tr class="memdesc:a5e9a21f1708565167f5995ac774b69f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the system's current VPS (volumes per second) - need to be +15 VPS for a up/down display to run smoothly. <br /></td></tr>
<tr class="separator:a5e9a21f1708565167f5995ac774b69f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d03c32956dfacd485319d2d42be03f9"><td class="memItemLeft" align="right" valign="top"><a id="a6d03c32956dfacd485319d2d42be03f9"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6d03c32956dfacd485319d2d42be03f9">getAspectX</a> ()=0</td></tr>
<tr class="memdesc:a6d03c32956dfacd485319d2d42be03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect X ratio. <br /></td></tr>
<tr class="separator:a6d03c32956dfacd485319d2d42be03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6097ac6cf301b39a51e6eaaf1b9d4ee"><td class="memItemLeft" align="right" valign="top"><a id="af6097ac6cf301b39a51e6eaaf1b9d4ee"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af6097ac6cf301b39a51e6eaaf1b9d4ee">getAspectY</a> ()=0</td></tr>
<tr class="memdesc:af6097ac6cf301b39a51e6eaaf1b9d4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Y ratio <br /></td></tr>
<tr class="separator:af6097ac6cf301b39a51e6eaaf1b9d4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af449963d7adc67b2de74129520029e92"><td class="memItemLeft" align="right" valign="top"><a id="af449963d7adc67b2de74129520029e92"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af449963d7adc67b2de74129520029e92">getAspectZ</a> ()=0</td></tr>
<tr class="memdesc:af449963d7adc67b2de74129520029e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Z ratio <br /></td></tr>
<tr class="separator:af449963d7adc67b2de74129520029e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd459c25d00473a9c3e02de521276a7"><td class="memItemLeft" align="right" valign="top"><a id="a5dd459c25d00473a9c3e02de521276a7"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5dd459c25d00473a9c3e02de521276a7">getAspect</a> ()=0</td></tr>
<tr class="memdesc:a5dd459c25d00473a9c3e02de521276a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values data as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> <br /></td></tr>
<tr class="separator:a5dd459c25d00473a9c3e02de521276a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20672401eeafeddeed2623bb36f2d5f6"><td class="memItemLeft" align="right" valign="top"><a id="a20672401eeafeddeed2623bb36f2d5f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a20672401eeafeddeed2623bb36f2d5f6">setAspectX</a> (float newAspectX)=0</td></tr>
<tr class="memdesc:a20672401eeafeddeed2623bb36f2d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect X ratio <br /></td></tr>
<tr class="separator:a20672401eeafeddeed2623bb36f2d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23645e8a469c039394fc920de531db1b"><td class="memItemLeft" align="right" valign="top"><a id="a23645e8a469c039394fc920de531db1b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a23645e8a469c039394fc920de531db1b">setAspectY</a> (float newAspectY)=0</td></tr>
<tr class="memdesc:a23645e8a469c039394fc920de531db1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Y ratio <br /></td></tr>
<tr class="separator:a23645e8a469c039394fc920de531db1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abe1bd83adaeed8555af23e663775e3"><td class="memItemLeft" align="right" valign="top"><a id="a9abe1bd83adaeed8555af23e663775e3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9abe1bd83adaeed8555af23e663775e3">setAspectZ</a> (float newAspectZ)=0</td></tr>
<tr class="memdesc:a9abe1bd83adaeed8555af23e663775e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect Z ratio <br /></td></tr>
<tr class="separator:a9abe1bd83adaeed8555af23e663775e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296413187cbf4aed4aa1fa98f4464a7"><td class="memItemLeft" align="right" valign="top"><a id="af296413187cbf4aed4aa1fa98f4464a7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af296413187cbf4aed4aa1fa98f4464a7">setAspect</a> (<a class="el" href="structpoint3d.html">point3d</a> newAspect)=0</td></tr>
<tr class="memdesc:af296413187cbf4aed4aa1fa98f4464a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the internal <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a>'s aspect ratio values data as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> <br /></td></tr>
<tr class="separator:af296413187cbf4aed4aa1fa98f4464a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf4881117f5dc17fa2ab42e85c4c70"><td class="memItemLeft" align="right" valign="top"><a id="ab3bf4881117f5dc17fa2ab42e85c4c70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab3bf4881117f5dc17fa2ab42e85c4c70">setDisplay2D</a> ()=0</td></tr>
<tr class="memdesc:ab3bf4881117f5dc17fa2ab42e85c4c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off the reciprocating screen and effectively makes the display a '2D' screen. (Works on Voxon hardware only) <br /></td></tr>
<tr class="separator:ab3bf4881117f5dc17fa2ab42e85c4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b3f83f2a2bf2236bc3c19482a70ea1"><td class="memItemLeft" align="right" valign="top"><a id="ae1b3f83f2a2bf2236bc3c19482a70ea1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae1b3f83f2a2bf2236bc3c19482a70ea1">setDisplay3D</a> ()=0</td></tr>
<tr class="memdesc:ae1b3f83f2a2bf2236bc3c19482a70ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on the reciprocating screen / activates the volumetric display. (Works on Voxon hardware only) <br /></td></tr>
<tr class="separator:ae1b3f83f2a2bf2236bc3c19482a70ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b4ee4d822f845faf8173ff8de2a010"><td class="memItemLeft" align="right" valign="top"><a id="a36b4ee4d822f845faf8173ff8de2a010"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a36b4ee4d822f845faf8173ff8de2a010">setView</a> (float xMin, float yMin, float zMin, float xMax, float yMax, float zMax)=0</td></tr>
<tr class="memdesc:a36b4ee4d822f845faf8173ff8de2a010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'view' for the volumetric display by default it is the aspect ratio of the voxie window but can be overridden. <br /></td></tr>
<tr class="separator:a36b4ee4d822f845faf8173ff8de2a010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55810cc08843c3e0604ed9e05d33e46"><td class="memItemLeft" align="right" valign="top"><a id="af55810cc08843c3e0604ed9e05d33e46"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af55810cc08843c3e0604ed9e05d33e46">setView</a> (<a class="el" href="structpoint3d.html">point3d</a> LUT, <a class="el" href="structpoint3d.html">point3d</a> RDB)=0</td></tr>
<tr class="memdesc:af55810cc08843c3e0604ed9e05d33e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="class_i_voxie_box.html#a36b4ee4d822f845faf8173ff8de2a010" title="Sets the &#39;view&#39; for the volumetric display by default it is the aspect ratio of the voxie window but ...">setView()</a> but using two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates instead of 6 floats. (LUT = left, up, top value, RDB = right, down, bottom value) <br /></td></tr>
<tr class="separator:af55810cc08843c3e0604ed9e05d33e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bca4d699ede45200e0433f866dad28"><td class="memItemLeft" align="right" valign="top"><a id="a96bca4d699ede45200e0433f866dad28"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a96bca4d699ede45200e0433f866dad28">setMaskPlane</a> (float x0, float y0, float z0, float normVx, float normVy, float normVz)=0</td></tr>
<tr class="memdesc:a96bca4d699ede45200e0433f866dad28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call after each <a class="el" href="class_i_voxie_box.html#a36b4ee4d822f845faf8173ff8de2a010" title="Sets the &#39;view&#39; for the volumetric display by default it is the aspect ratio of the voxie window but ...">setView()</a> to mask off a plane of a specified thickness. Used for viewing a 'slice' of a scene. <br /></td></tr>
<tr class="separator:a96bca4d699ede45200e0433f866dad28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e9f374fb93e42c1a94ad11a161c7c2"><td class="memItemLeft" align="right" valign="top"><a id="ab6e9f374fb93e42c1a94ad11a161c7c2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab6e9f374fb93e42c1a94ad11a161c7c2">setGlobalShader</a> (float horizontalAngle, float verticalAngle, float amplitude)=0</td></tr>
<tr class="memdesc:ab6e9f374fb93e42c1a94ad11a161c7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the global normal vector (vw.normhax) for shading. Pass in three 0's to disable. <br /></td></tr>
<tr class="separator:ab6e9f374fb93e42c1a94ad11a161c7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae278a85705ab4b72799149f66a25d9c6"><td class="memItemLeft" align="right" valign="top"><a id="ae278a85705ab4b72799149f66a25d9c6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae278a85705ab4b72799149f66a25d9c6">flushGfx</a> (void)=0</td></tr>
<tr class="memdesc:ae278a85705ab4b72799149f66a25d9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all graphics commands on internal buffer, causing all graphics commands execute and complete. <br /></td></tr>
<tr class="separator:ae278a85705ab4b72799149f66a25d9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f27146d212e0f9381fee3876d996c7"><td class="memItemLeft" align="right" valign="top"><a id="a54f27146d212e0f9381fee3876d996c7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a54f27146d212e0f9381fee3876d996c7">freeGfx</a> (char *fileName)=0</td></tr>
<tr class="memdesc:a54f27146d212e0f9381fee3876d996c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a filename from VoxieBox.dll internal cache (any filename passed to voxie_drawmeshtex(), voxie_drawheimap(), voxie_drawspr()) <br /></td></tr>
<tr class="separator:a54f27146d212e0f9381fee3876d996c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a677a4d66dd2df77b923cb37f7f7d58"><td class="memItemLeft" align="right" valign="top"><a id="a1a677a4d66dd2df77b923cb37f7f7d58"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1a677a4d66dd2df77b923cb37f7f7d58">setProject</a> (int dispNum, int dir, float x, float y, int z, float *xo, float *yo)=0</td></tr>
<tr class="memdesc:a1a677a4d66dd2df77b923cb37f7f7d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced utility function for keystone calibration (used by graphcalc and keystone calibration in voxiedemo) <br /></td></tr>
<tr class="separator:a1a677a4d66dd2df77b923cb37f7f7d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a8dfcdc1f9e3825c5deed335104340"><td class="memItemLeft" align="right" valign="top"><a id="af2a8dfcdc1f9e3825c5deed335104340"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af2a8dfcdc1f9e3825c5deed335104340">setLeds</a> (int dispNum, int r, int g, int b)=0</td></tr>
<tr class="memdesc:af2a8dfcdc1f9e3825c5deed335104340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set LEDs values on projector hardware. WARNING: Be careful not to overheat projector! Sending over 160 can be risky! <br /></td></tr>
<tr class="separator:af2a8dfcdc1f9e3825c5deed335104340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b83b28e4096ec5efc4cedbed095598"><td class="memItemLeft" align="right" valign="top"><a id="a15b83b28e4096ec5efc4cedbed095598"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a15b83b28e4096ec5efc4cedbed095598">reportVoxieWind</a> (int posX, int posY)=0</td></tr>
<tr class="memdesc:a15b83b28e4096ec5efc4cedbed095598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes all the variables from the internal vw <a class="el" href="structvoxie__wind__t.html" title="Voxie Window Struct - Configuration for the Voxon Window. This struct manages all the settings to do ...">voxie_wind_t</a> onto the secondary (touch) screen. For debugging. <br /></td></tr>
<tr class="separator:a15b83b28e4096ec5efc4cedbed095598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6aaafbf8ef7ad3f4dfa45ed07a8368"><td class="memItemLeft" align="right" valign="top"><a id="a8b6aaafbf8ef7ad3f4dfa45ed07a8368"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8b6aaafbf8ef7ad3f4dfa45ed07a8368">reportVoxieFrame</a> (int posX, int posY)=0</td></tr>
<tr class="memdesc:a8b6aaafbf8ef7ad3f4dfa45ed07a8368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes all the variables from the internal vf <a class="el" href="structvoxie__frame__t.html" title="Struct which holds all the frame data (frame is a 2D slice of the volumetric image) which gets loaded...">voxie_frame_t</a> onto the secondary (touch) screen. For debugging. <br /></td></tr>
<tr class="separator:a8b6aaafbf8ef7ad3f4dfa45ed07a8368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b422c7e3d78991b25d875b52e13e27"><td class="memItemLeft" align="right" valign="top"><a id="a74b422c7e3d78991b25d875b52e13e27"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a74b422c7e3d78991b25d875b52e13e27">debugText</a> (int posX, int posY, int forgroundCol, int backgroundCol, const char *fmt,...)=0</td></tr>
<tr class="memdesc:a74b422c7e3d78991b25d875b52e13e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display text unto the secondary (touch) screen. Must be called within start and end frame functions. backgroundCol = -1 for transparent. <br /></td></tr>
<tr class="separator:a74b422c7e3d78991b25d875b52e13e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54467a9435d9213382bd1b08ee3537f2"><td class="memItemLeft" align="right" valign="top"><a id="a54467a9435d9213382bd1b08ee3537f2"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a54467a9435d9213382bd1b08ee3537f2">debugBar</a> (int posX, int posY, double currentVal, double maxVal, double minVal, char *text, int type)=0</td></tr>
<tr class="memdesc:a54467a9435d9213382bd1b08ee3537f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertical bar for help tracking variables onto the secondary (touch) screen. Must be called within the <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a54467a9435d9213382bd1b08ee3537f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb05c98e59bf16143b4d5053821034a"><td class="memItemLeft" align="right" valign="top"><a id="aabb05c98e59bf16143b4d5053821034a"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aabb05c98e59bf16143b4d5053821034a">showVPS</a> (int posX=15, int posY=525)=0</td></tr>
<tr class="memdesc:aabb05c98e59bf16143b4d5053821034a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays volumes per second (volumetric equivalent of 'FPS') and version info on the secondary (touch) screen. Must be called within the <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. Returns VPS value. <br /></td></tr>
<tr class="separator:aabb05c98e59bf16143b4d5053821034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9281d2937cda6c6e193cb8ad8493a"><td class="memItemLeft" align="right" valign="top"><a id="a75d9281d2937cda6c6e193cb8ad8493a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a75d9281d2937cda6c6e193cb8ad8493a">debugDrawPix</a> (int x, int y, int col)=0</td></tr>
<tr class="memdesc:a75d9281d2937cda6c6e193cb8ad8493a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws single pixel on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a75d9281d2937cda6c6e193cb8ad8493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2257f7413272cdb6ade0f7e62886b62"><td class="memItemLeft" align="right" valign="top"><a id="ae2257f7413272cdb6ade0f7e62886b62"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae2257f7413272cdb6ade0f7e62886b62">debugDrawHLine</a> (int xStartPos, int xEndPos, int y, int col)=0</td></tr>
<tr class="memdesc:ae2257f7413272cdb6ade0f7e62886b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws horizontal line on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:ae2257f7413272cdb6ade0f7e62886b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba4f6c944b21722d247b89a7c6f36f"><td class="memItemLeft" align="right" valign="top"><a id="a20ba4f6c944b21722d247b89a7c6f36f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a20ba4f6c944b21722d247b89a7c6f36f">debugDrawLine</a> (float xStartPos, float yStartPos, float xEndPos, float yEndPos, int col)=0</td></tr>
<tr class="memdesc:a20ba4f6c944b21722d247b89a7c6f36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a20ba4f6c944b21722d247b89a7c6f36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f50d77e22fbaf7261869504388931e"><td class="memItemLeft" align="right" valign="top"><a id="af1f50d77e22fbaf7261869504388931e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af1f50d77e22fbaf7261869504388931e">debugDrawCircle</a> (int xCenterPos, int yCenterPos, int radius, int col)=0</td></tr>
<tr class="memdesc:af1f50d77e22fbaf7261869504388931e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw circle on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:af1f50d77e22fbaf7261869504388931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dd8950c07fb19ea767125d724d924f"><td class="memItemLeft" align="right" valign="top"><a id="a70dd8950c07fb19ea767125d724d924f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a70dd8950c07fb19ea767125d724d924f">debugDrawBoxFill</a> (int xStartPos, int yStartPos, int xEndPos, int yEndPos, int col)=0</td></tr>
<tr class="memdesc:a70dd8950c07fb19ea767125d724d924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw filled rectangle on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a70dd8950c07fb19ea767125d724d924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24dd42295b886eb9e576eb5813fe6f5"><td class="memItemLeft" align="right" valign="top"><a id="aa24dd42295b886eb9e576eb5813fe6f5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa24dd42295b886eb9e576eb5813fe6f5">debugDrawCircFill</a> (int xCenterPos, int yCenterPos, int radius, int col)=0</td></tr>
<tr class="memdesc:aa24dd42295b886eb9e576eb5813fe6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw filled circle on the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:aa24dd42295b886eb9e576eb5813fe6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e32860cfac14a5a124dda8b4ec44e"><td class="memItemLeft" align="right" valign="top"><a id="ad79e32860cfac14a5a124dda8b4ec44e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad79e32860cfac14a5a124dda8b4ec44e">debugDrawTile</a> (<a class="el" href="structtiletype.html">tiletype</a> *source, int xpos, int ypos)=0</td></tr>
<tr class="memdesc:ad79e32860cfac14a5a124dda8b4ec44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 2D texture to the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. Sent through a tiletype_t pointer. <br /></td></tr>
<tr class="separator:ad79e32860cfac14a5a124dda8b4ec44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab420036b8879fda7abd6e51e28d0283d"><td class="memItemLeft" align="right" valign="top"><a id="ab420036b8879fda7abd6e51e28d0283d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab420036b8879fda7abd6e51e28d0283d">debugCustomFontSet</a> (const char *fileName, int index=-1)=0</td></tr>
<tr class="memdesc:ab420036b8879fda7abd6e51e28d0283d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom font to be used as an internal tile type to be written to the secondary (touch) screen. <br /></td></tr>
<tr class="separator:ab420036b8879fda7abd6e51e28d0283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988579f7c0c8c7a872d0a420e892de24"><td class="memItemLeft" align="right" valign="top"><a id="a988579f7c0c8c7a872d0a420e892de24"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a988579f7c0c8c7a872d0a420e892de24">debugCustomFont</a> (int xpos, int ypos, int customFontIndex, const char *fmt,...)=0</td></tr>
<tr class="memdesc:a988579f7c0c8c7a872d0a420e892de24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the custom bitmap font to the secondary (touch) screen. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a988579f7c0c8c7a872d0a420e892de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a86e311b962c310f85287a9f5de8550"><td class="memItemLeft" align="right" valign="top"><a id="a8a86e311b962c310f85287a9f5de8550"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8a86e311b962c310f85287a9f5de8550">drawVox</a> (float x, float y, float z, int col)=0</td></tr>
<tr class="memdesc:a8a86e311b962c310f85287a9f5de8550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a single voxel onto the volumetric using a 3 floats for coordinates. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a8a86e311b962c310f85287a9f5de8550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fe8c4b4024b2c41e25563ef0773d1"><td class="memItemLeft" align="right" valign="top"><a id="a3c7fe8c4b4024b2c41e25563ef0773d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a3c7fe8c4b4024b2c41e25563ef0773d1">drawVox</a> (<a class="el" href="structpoint3d.html">point3d</a> pos, int col)=0</td></tr>
<tr class="memdesc:a3c7fe8c4b4024b2c41e25563ef0773d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a single voxel onto the volumetric using a single <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a3c7fe8c4b4024b2c41e25563ef0773d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d942a7f260cc979a6ece8f0ea39de5"><td class="memItemLeft" align="right" valign="top"><a id="a28d942a7f260cc979a6ece8f0ea39de5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a28d942a7f260cc979a6ece8f0ea39de5">drawBox</a> (float x0, float y0, float z0, float x1, float y1, float z1, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a28d942a7f260cc979a6ece8f0ea39de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a rectangle / box on the volumetric display using 3 floats for coordinates. 0 position is LEFT, UP, TOP, 1 position is RIGHT, DOWN, BOTTOM. fillmode = 0 dots, 1 lines, 2 surfaces, 3 solid. <br /></td></tr>
<tr class="separator:a28d942a7f260cc979a6ece8f0ea39de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d4968628a24bafafedc4908433a351"><td class="memItemLeft" align="right" valign="top"><a id="a03d4968628a24bafafedc4908433a351"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a03d4968628a24bafafedc4908433a351">drawBox</a> (<a class="el" href="structpoint3d.html">point3d</a> posLeftUpTop, <a class="el" href="structpoint3d.html">point3d</a> posRightDownBottom, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a03d4968628a24bafafedc4908433a351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a rectangle / box on the volumetric display using 2 point3ds for coordinates. fillmode = 0 dots, 1 lines, 2 surfaces, 3 solid. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a03d4968628a24bafafedc4908433a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f0cd3a5b55e11b31551fa8ac4fcc5"><td class="memItemLeft" align="right" valign="top"><a id="a864f0cd3a5b55e11b31551fa8ac4fcc5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a864f0cd3a5b55e11b31551fa8ac4fcc5">drawCube</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a864f0cd3a5b55e11b31551fa8ac4fcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cube onto the volumetric display using specified vectors. fillmode = 0 dots, 1 lines, 2 surfaces, 3 solid. <br /></td></tr>
<tr class="separator:a864f0cd3a5b55e11b31551fa8ac4fcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b2874018085bbf077a6b4eff015a94"><td class="memItemLeft" align="right" valign="top"><a id="a77b2874018085bbf077a6b4eff015a94"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a77b2874018085bbf077a6b4eff015a94">drawSphere</a> (<a class="el" href="structpoint3d.html">point3d</a> pos, float radius, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a77b2874018085bbf077a6b4eff015a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a sphere on the volumetric display using 3 floats. fillmode = 0 surface, 1 filled. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a77b2874018085bbf077a6b4eff015a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efd69105c342b088db2ae2c313450b1"><td class="memItemLeft" align="right" valign="top"><a id="a4efd69105c342b088db2ae2c313450b1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4efd69105c342b088db2ae2c313450b1">drawSphere</a> (float x, float y, float z, float radius, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a4efd69105c342b088db2ae2c313450b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a sphere on the volumetric display using 3 floats. fillmode = 0 surface, 1 filled. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a4efd69105c342b088db2ae2c313450b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35934307729ad81b2871ee342f7031c5"><td class="memItemLeft" align="right" valign="top"><a id="a35934307729ad81b2871ee342f7031c5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a35934307729ad81b2871ee342f7031c5">drawLine</a> (float xStartPos, float yStartPos, float zStartPos, float xEndPos, float yEndPos, float zEndPos, int col)=0</td></tr>
<tr class="memdesc:a35934307729ad81b2871ee342f7031c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a line on the volumetric display using 6 floats for coordinates. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a35934307729ad81b2871ee342f7031c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ea84e318c1e5178abac5c66f883d70"><td class="memItemLeft" align="right" valign="top"><a id="a83ea84e318c1e5178abac5c66f883d70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a83ea84e318c1e5178abac5c66f883d70">drawLine</a> (<a class="el" href="structpoint3d.html">point3d</a> startPos, <a class="el" href="structpoint3d.html">point3d</a> endPos, int col)=0</td></tr>
<tr class="memdesc:a83ea84e318c1e5178abac5c66f883d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a line on the volumetric display using <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> for coordinates. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a83ea84e318c1e5178abac5c66f883d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ebdbb54ba68da8ff10557775d7575"><td class="memItemLeft" align="right" valign="top"><a id="aaa3ebdbb54ba68da8ff10557775d7575"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aaa3ebdbb54ba68da8ff10557775d7575">drawPoly</a> (<a class="el" href="structpol__t.html">pol_t</a> *polArray, int ptCount, int col)=0</td></tr>
<tr class="memdesc:aaa3ebdbb54ba68da8ff10557775d7575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a filled polygon. Assumes points are in loop order and coplanar. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:aaa3ebdbb54ba68da8ff10557775d7575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3117fc00bdda31f169586de339d336d"><td class="memItemLeft" align="right" valign="top"><a id="af3117fc00bdda31f169586de339d336d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af3117fc00bdda31f169586de339d336d">drawMesh</a> (char *fileName, <a class="el" href="structpoltex__t.html">poltex_t</a> *verticeList, int verticeNum, int *meshList, int meshNum, int flags, int col)=0</td></tr>
<tr class="memdesc:af3117fc00bdda31f169586de339d336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a mesh from a list of vertices can render in as dots, lines, polygons, or filled mesh. <br /></td></tr>
<tr class="separator:af3117fc00bdda31f169586de339d336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7642a7a9e61f0eab8c906d1862ac67e4"><td class="memItemLeft" align="right" valign="top"><a id="a7642a7a9e61f0eab8c906d1862ac67e4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7642a7a9e61f0eab8c906d1862ac67e4">drawCone</a> (float xStartPos, float yStartPos, float zStartPos, float startRadius, float xEndPos, float yEndPos, float zEndPos, float endRadius, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a7642a7a9e61f0eab8c906d1862ac67e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 6 floats for coordinates. <br /></td></tr>
<tr class="separator:a7642a7a9e61f0eab8c906d1862ac67e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2583f5a4cc4cc56b3dd26e2bf1d044a1"><td class="memItemLeft" align="right" valign="top"><a id="a2583f5a4cc4cc56b3dd26e2bf1d044a1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a2583f5a4cc4cc56b3dd26e2bf1d044a1">drawCone</a> (<a class="el" href="structpoint3d.html">point3d</a> startPos, float startRadius, <a class="el" href="structpoint3d.html">point3d</a> endPos, float endRadius, int fillmode, int col)=0</td></tr>
<tr class="memdesc:a2583f5a4cc4cc56b3dd26e2bf1d044a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a cone shape on the volumetric display with rounded ends (also capable of rendering a cylinder/sphere) using 2 point3ds for coordinates. <br /></td></tr>
<tr class="separator:a2583f5a4cc4cc56b3dd26e2bf1d044a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323fe437c563e47f755bd953ce376e01"><td class="memItemLeft" align="right" valign="top"><a id="a323fe437c563e47f755bd953ce376e01"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a323fe437c563e47f755bd953ce376e01">drawModel</a> (const char *fileName, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int col)=0</td></tr>
<tr class="memdesc:a323fe437c563e47f755bd953ce376e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display. <br /></td></tr>
<tr class="separator:a323fe437c563e47f755bd953ce376e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0529ac97dbdad46ae0f5b2d5b3b1ba1"><td class="memItemLeft" align="right" valign="top"><a id="ae0529ac97dbdad46ae0f5b2d5b3b1ba1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae0529ac97dbdad46ae0f5b2d5b3b1ba1">drawModelGetExtents</a> (const char *charbuff, <a class="el" href="structextents__t.html">extents_t</a> *extentsPtr, int flags)=0</td></tr>
<tr class="memdesc:ae0529ac97dbdad46ae0f5b2d5b3b1ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extents of a 3D model (.obj, .kv6, .stl etc...) <br /></td></tr>
<tr class="separator:ae0529ac97dbdad46ae0f5b2d5b3b1ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac423496589210300b8b1375e6611b9a5"><td class="memItemLeft" align="right" valign="top"><a id="ac423496589210300b8b1375e6611b9a5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac423496589210300b8b1375e6611b9a5">drawModelExt</a> (const char *fileName, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int col, float forcescale, float fdrawratio, int flags)=0</td></tr>
<tr class="memdesc:ac423496589210300b8b1375e6611b9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders 3D model (.obj, .ply, .stl, .kv6) Displays a filename mesh onto the volumetric display. Extended from <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a>:drawModel. <br /></td></tr>
<tr class="separator:ac423496589210300b8b1375e6611b9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313435cdb69eb055de94a918c4335875"><td class="memItemLeft" align="right" valign="top"><a id="a313435cdb69eb055de94a918c4335875"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a313435cdb69eb055de94a918c4335875">drawQuad</a> (char *filename, <a class="el" href="structpoint3d.html">point3d</a> *pos, float width, float height, float hAng, float vAng, float twist, int col, float uValue, float vValue)=0</td></tr>
<tr class="memdesc:a313435cdb69eb055de94a918c4335875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a 2D textured (.png, .jpg... most image formats) quad (plane) onto the volumetric display. Useful to rendering 2D textures. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a313435cdb69eb055de94a918c4335875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b200f89ba0ec2c92a1a7e10c761d83"><td class="memItemLeft" align="right" valign="top"><a id="a34b200f89ba0ec2c92a1a7e10c761d83"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a34b200f89ba0ec2c92a1a7e10c761d83">drawHeightMap</a> (char *fileName, <a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, <a class="el" href="structpoint3d.html">point3d</a> *fVector, int colorKey, int reserved, int flags)=0</td></tr>
<tr class="memdesc:a34b200f89ba0ec2c92a1a7e10c761d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a heightmap (.jpg, .png or tiletype data) onto the volumetric display. <br /></td></tr>
<tr class="separator:a34b200f89ba0ec2c92a1a7e10c761d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5400e4b60902e40463a30a978a1e48a3"><td class="memItemLeft" align="right" valign="top"><a id="a5400e4b60902e40463a30a978a1e48a3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5400e4b60902e40463a30a978a1e48a3">drawText</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, int col, const char *fmt,...)=0</td></tr>
<tr class="memdesc:a5400e4b60902e40463a30a978a1e48a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string (printf-style) unto the volumetric display. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:a5400e4b60902e40463a30a978a1e48a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc39f1f85c06482a847f6fee13c6790"><td class="memItemLeft" align="right" valign="top"><a id="aabc39f1f85c06482a847f6fee13c6790"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aabc39f1f85c06482a847f6fee13c6790">drawTextExt</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, <a class="el" href="structpoint3d.html">point3d</a> *rVector, <a class="el" href="structpoint3d.html">point3d</a> *dVector, float size, int col, const char *fmt,...)=0</td></tr>
<tr class="memdesc:aabc39f1f85c06482a847f6fee13c6790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string (printf-style) unto the volumetric display additional parameter for font width. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:aabc39f1f85c06482a847f6fee13c6790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1fdbd6e069500def6e45f63de1a07e"><td class="memItemLeft" align="right" valign="top"><a id="aca1fdbd6e069500def6e45f63de1a07e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aca1fdbd6e069500def6e45f63de1a07e">drawTextSimp</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, float textWidth, float textHeight, float hang, float vang, float tilt, int col, char *fmt,...)=0</td></tr>
<tr class="memdesc:aca1fdbd6e069500def6e45f63de1a07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple version to render a string (printf-style) unto the volumetric display. Must be called between <a class="el" href="class_i_voxie_box.html#ace7dedd2c220cf2f62470697d760cef9" title="Signifies the start of the volumetric frame. Call this once before all draw calls....">startFrame()</a> &amp; <a class="el" href="class_i_voxie_box.html#ae78f083e60d771b7885bd65f5b78d22c" title="Signifies the end of a volumetric frame. Call this once after all draw calls. Sends the voxel buffer ...">endFrame()</a> functions. <br /></td></tr>
<tr class="separator:aca1fdbd6e069500def6e45f63de1a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c1f4bc985d70a4bd1a8b95c9008968"><td class="memItemLeft" align="right" valign="top"><a id="ac8c1f4bc985d70a4bd1a8b95c9008968"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac8c1f4bc985d70a4bd1a8b95c9008968">drawDicom</a> (<a class="el" href="structvoxie__dicom__t.html">voxie_dicom_t</a> *vd, const char *gfilnam, <a class="el" href="structpoint3d.html">point3d</a> *gp, <a class="el" href="structpoint3d.html">point3d</a> *gr, <a class="el" href="structpoint3d.html">point3d</a> *gd, <a class="el" href="structpoint3d.html">point3d</a> *gf, int *animn, int *loaddone)=0</td></tr>
<tr class="memdesc:ac8c1f4bc985d70a4bd1a8b95c9008968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a DICOM file unto the volumetric display. <br /></td></tr>
<tr class="separator:ac8c1f4bc985d70a4bd1a8b95c9008968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993f8b1d0b93bbb1fccaa7caecd1e98c"><td class="memItemLeft" align="right" valign="top"><a id="a993f8b1d0b93bbb1fccaa7caecd1e98c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a993f8b1d0b93bbb1fccaa7caecd1e98c">getKeyState</a> (int scancode)=0</td></tr>
<tr class="memdesc:a993f8b1d0b93bbb1fccaa7caecd1e98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a key's input state (0 = no press, 1 = just pressed, 3 = held down) see vxInputTypes.h::Keys for scancodes. <br /></td></tr>
<tr class="separator:a993f8b1d0b93bbb1fccaa7caecd1e98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db57534bf7b6c85afe59ec145f3bec"><td class="memItemLeft" align="right" valign="top"><a id="af4db57534bf7b6c85afe59ec145f3bec"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af4db57534bf7b6c85afe59ec145f3bec">getKeyIsDown</a> (int scancode)=0</td></tr>
<tr class="memdesc:af4db57534bf7b6c85afe59ec145f3bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the scancode's key is held down (pressed). For scancodes see vxInputTypes.h::Keys. <br /></td></tr>
<tr class="separator:af4db57534bf7b6c85afe59ec145f3bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af263a8eee36ef26ff5b8c5aaa31e9"><td class="memItemLeft" align="right" valign="top"><a id="ae8af263a8eee36ef26ff5b8c5aaa31e9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae8af263a8eee36ef26ff5b8c5aaa31e9">getKeyOnDown</a> (int scancode)=0</td></tr>
<tr class="memdesc:ae8af263a8eee36ef26ff5b8c5aaa31e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the scancode's key is just pressed. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox library is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys. <br /></td></tr>
<tr class="separator:ae8af263a8eee36ef26ff5b8c5aaa31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d19e6097e4ad256d848743dd81d3e3"><td class="memItemLeft" align="right" valign="top"><a id="ae0d19e6097e4ad256d848743dd81d3e3"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae0d19e6097e4ad256d848743dd81d3e3">getKeyOnUp</a> (int scancode)=0</td></tr>
<tr class="memdesc:ae0d19e6097e4ad256d848743dd81d3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the scancode's key is just released. Requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox library is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> set to false to work. For scancodes see vxInputTypes.h::Keys. <br /></td></tr>
<tr class="separator:ae0d19e6097e4ad256d848743dd81d3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4538a25948743e4774d0003bc458f"><td class="memItemLeft" align="right" valign="top"><a id="abee4538a25948743e4774d0003bc458f"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#abee4538a25948743e4774d0003bc458f">getKeyDownTime</a> (int scancode)=0</td></tr>
<tr class="memdesc:abee4538a25948743e4774d0003bc458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time (in seconds) The scancode's key has been held down for requires <a class="el" href="class_voxie_box.html#a48963e610a6a5d5aa6e3fc06506f7272" title="toggles when enabled and VoxieBox::quitLoop() is called the Voxiebox library is freed from memory....">VoxieBox::setEnableLegacyKeyInput()</a> to be set to false to work. <br /></td></tr>
<tr class="separator:abee4538a25948743e4774d0003bc458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98ada2a49e635d64803a2869ed30f72"><td class="memItemLeft" align="right" valign="top"><a id="ac98ada2a49e635d64803a2869ed30f72"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac98ada2a49e635d64803a2869ed30f72">getKeyStream</a> ()=0</td></tr>
<tr class="memdesc:ac98ada2a49e635d64803a2869ed30f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns buffered ASCII keyboard input. Requires setEnableLegacyKeyInput is set to true. <br /></td></tr>
<tr class="separator:ac98ada2a49e635d64803a2869ed30f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00aa2e97890bdf5f5cd352a6eb84c084"><td class="memItemLeft" align="right" valign="top"><a id="a00aa2e97890bdf5f5cd352a6eb84c084"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a00aa2e97890bdf5f5cd352a6eb84c084">getKeyStreamScanCode</a> ()=0</td></tr>
<tr class="memdesc:a00aa2e97890bdf5f5cd352a6eb84c084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="class_i_voxie_box.html#ac98ada2a49e635d64803a2869ed30f72" title="Returns buffered ASCII keyboard input. Requires setEnableLegacyKeyInput is set to true.">getKeyStream()</a> but returns only the scancode of the keystate of a streaming state. Returns 0 if no more keys are in the stream. Requires setEnableLegacyKeyInput is set to true. <br /></td></tr>
<tr class="separator:a00aa2e97890bdf5f5cd352a6eb84c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec28b292e254ac9fddf57853eb677e3"><td class="memItemLeft" align="right" valign="top"><a id="a7ec28b292e254ac9fddf57853eb677e3"></a>
virtual <a class="el" href="structvoxie__keyboard__history__t.html">voxie_keyboard_history_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7ec28b292e254ac9fddf57853eb677e3">getKeyHistory</a> ()=0</td></tr>
<tr class="memdesc:a7ec28b292e254ac9fddf57853eb677e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns internal <a class="el" href="structvoxie__keyboard__history__t.html" title="used internally by VoxieBox to log various keyboard button inputs this struct allows you to view the ...">voxie_keyboard_history_t</a> struct which holds the keyboard input history. <br  />
 <br /></td></tr>
<tr class="separator:a7ec28b292e254ac9fddf57853eb677e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446554e9de2c673ce05f00207221bd54"><td class="memItemLeft" align="right" valign="top"><a id="a446554e9de2c673ce05f00207221bd54"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a446554e9de2c673ce05f00207221bd54">reportKeyboard</a> (int posX, int posY)=0</td></tr>
<tr class="memdesc:a446554e9de2c673ce05f00207221bd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of the keyboard on to the secondary (touch) screen. Used to help with debugging. <br /></td></tr>
<tr class="separator:a446554e9de2c673ce05f00207221bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a6612f5122bbd7b838e49f9f0113e"><td class="memItemLeft" align="right" valign="top"><a id="a586a6612f5122bbd7b838e49f9f0113e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a586a6612f5122bbd7b838e49f9f0113e">getMouseXDelta</a> ()=0</td></tr>
<tr class="memdesc:a586a6612f5122bbd7b838e49f9f0113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's X delta movement. Reads from internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:a586a6612f5122bbd7b838e49f9f0113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535042b523d8ddd4dbc1787ab9e3c6a4"><td class="memItemLeft" align="right" valign="top"><a id="a535042b523d8ddd4dbc1787ab9e3c6a4"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a535042b523d8ddd4dbc1787ab9e3c6a4">getMouseYDelta</a> ()=0</td></tr>
<tr class="memdesc:a535042b523d8ddd4dbc1787ab9e3c6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's Y delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:a535042b523d8ddd4dbc1787ab9e3c6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee66fc378abc35f5046953c03d8be36"><td class="memItemLeft" align="right" valign="top"><a id="a9ee66fc378abc35f5046953c03d8be36"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9ee66fc378abc35f5046953c03d8be36">getMouseZDelta</a> ()=0</td></tr>
<tr class="memdesc:a9ee66fc378abc35f5046953c03d8be36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's Z delta movement. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:a9ee66fc378abc35f5046953c03d8be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49dd59c3ffe306e46216d62ec276f7a"><td class="memItemLeft" align="right" valign="top"><a id="ab49dd59c3ffe306e46216d62ec276f7a"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab49dd59c3ffe306e46216d62ec276f7a">getMouseDelta</a> ()=0</td></tr>
<tr class="memdesc:ab49dd59c3ffe306e46216d62ec276f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's X,Y and Z delta movements as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:ab49dd59c3ffe306e46216d62ec276f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea3ed1068bb4472df6c779c1cde6bb4"><td class="memItemLeft" align="right" valign="top"><a id="afea3ed1068bb4472df6c779c1cde6bb4"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#afea3ed1068bb4472df6c779c1cde6bb4">getMousePosition</a> ()=0</td></tr>
<tr class="memdesc:afea3ed1068bb4472df6c779c1cde6bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse's X,Y and Z position as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. <br /></td></tr>
<tr class="separator:afea3ed1068bb4472df6c779c1cde6bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a9d805f040772ae5ad94d1a40ecf41"><td class="memItemLeft" align="right" valign="top"><a id="a04a9d805f040772ae5ad94d1a40ecf41"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a04a9d805f040772ae5ad94d1a40ecf41">setMousePosition</a> (<a class="el" href="structpoint3d.html">point3d</a> newPos)=0</td></tr>
<tr class="memdesc:a04a9d805f040772ae5ad94d1a40ecf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides internal mouse position with a new <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> position. <br /></td></tr>
<tr class="separator:a04a9d805f040772ae5ad94d1a40ecf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6fdbe2ab656d19e93548a2a86de8db"><td class="memItemLeft" align="right" valign="top"><a id="afb6fdbe2ab656d19e93548a2a86de8db"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#afb6fdbe2ab656d19e93548a2a86de8db">setMouseXYSensitivity</a> (float newAmount)=0</td></tr>
<tr class="memdesc:afb6fdbe2ab656d19e93548a2a86de8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Mouse's X and Y sensitivity. 0.001 is default. (0.0001 = low sensitive, 0.9 = extremely sensitive) Mouse movements work in integers the amount is scaled down. <br /></td></tr>
<tr class="separator:afb6fdbe2ab656d19e93548a2a86de8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f752bd5be48bf67b1fd86238af4782"><td class="memItemLeft" align="right" valign="top"><a id="ad9f752bd5be48bf67b1fd86238af4782"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad9f752bd5be48bf67b1fd86238af4782">setMouseZSensitivity</a> (float newAmount)=0</td></tr>
<tr class="memdesc:ad9f752bd5be48bf67b1fd86238af4782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Mouse's Z sensitivity. 0.0005 is default. (0.0001 = low sensitive, 0.9 = extremely sensitive) Mouse movements work in integers the amount is scaled down. <br /></td></tr>
<tr class="separator:ad9f752bd5be48bf67b1fd86238af4782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c627addffc2d9d14e4483fcac080536"><td class="memItemLeft" align="right" valign="top"><a id="a1c627addffc2d9d14e4483fcac080536"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1c627addffc2d9d14e4483fcac080536">setMouseDoubleClickThreshold</a> (double timeThreshold)=0</td></tr>
<tr class="memdesc:a1c627addffc2d9d14e4483fcac080536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time between mouse clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_i_voxie_box.html#afb595d29b03560dac44f5915c8b373a9" title="Returns true if particular buttonCode has been clicked twice within the double click threshold.">getMouseDoubleClick()</a>) <br /></td></tr>
<tr class="separator:a1c627addffc2d9d14e4483fcac080536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cac9fde3f7f8948cae3cb5149667b0f"><td class="memItemLeft" align="right" valign="top"><a id="a8cac9fde3f7f8948cae3cb5149667b0f"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8cac9fde3f7f8948cae3cb5149667b0f">getMouseDoubleClickThreshold</a> ()=0</td></tr>
<tr class="memdesc:a8cac9fde3f7f8948cae3cb5149667b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mouse double click threshold. (how quickly 2 mouse clicks signify a 'double click'). Presented in seconds. <br /></td></tr>
<tr class="separator:a8cac9fde3f7f8948cae3cb5149667b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360635e1e20996231a648ce78e3cf5c6"><td class="memItemLeft" align="right" valign="top"><a id="a360635e1e20996231a648ce78e3cf5c6"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a360635e1e20996231a648ce78e3cf5c6">getMouseXYSensitivity</a> ()=0</td></tr>
<tr class="memdesc:a360635e1e20996231a648ce78e3cf5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mouse XY sensitivity. <br /></td></tr>
<tr class="separator:a360635e1e20996231a648ce78e3cf5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e1e54293c847531f274a6983f377b"><td class="memItemLeft" align="right" valign="top"><a id="af69e1e54293c847531f274a6983f377b"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af69e1e54293c847531f274a6983f377b">getMouseZSensitivity</a> ()=0</td></tr>
<tr class="memdesc:af69e1e54293c847531f274a6983f377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current mouse Z sensitivity. <br /></td></tr>
<tr class="separator:af69e1e54293c847531f274a6983f377b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698202f5db651e54e4dd5a536d2ee242"><td class="memItemLeft" align="right" valign="top"><a id="a698202f5db651e54e4dd5a536d2ee242"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a698202f5db651e54e4dd5a536d2ee242">getMouseButtonState</a> ()=0</td></tr>
<tr class="memdesc:a698202f5db651e54e4dd5a536d2ee242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:a698202f5db651e54e4dd5a536d2ee242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7bba604dae38c3b5ff832f15863d8e"><td class="memItemLeft" align="right" valign="top"><a id="a8e7bba604dae38c3b5ff832f15863d8e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8e7bba604dae38c3b5ff832f15863d8e">getMousePrevButtonState</a> ()=0</td></tr>
<tr class="memdesc:a8e7bba604dae38c3b5ff832f15863d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal mouse previous button state. Reads from the internal (in) <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a>. <br /></td></tr>
<tr class="separator:a8e7bba604dae38c3b5ff832f15863d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d04360ec7c5df39ff6a02ba715ec32"><td class="memItemLeft" align="right" valign="top"><a id="a53d04360ec7c5df39ff6a02ba715ec32"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a53d04360ec7c5df39ff6a02ba715ec32">getMouseButtonIsDown</a> (int buttonCode)=0</td></tr>
<tr class="memdesc:a53d04360ec7c5df39ff6a02ba715ec32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of mouse's buttonCode. 1 if currently pressed down and 0 if not being pressed. (buttonCodes are 0 for left, 1 for right, 2 for center buttons) <br /></td></tr>
<tr class="separator:a53d04360ec7c5df39ff6a02ba715ec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133bc86d0444e81f01bd6cf4796e16cb"><td class="memItemLeft" align="right" valign="top"><a id="a133bc86d0444e81f01bd6cf4796e16cb"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a133bc86d0444e81f01bd6cf4796e16cb">getMouseButtonOnDown</a> (int buttonCode)=0</td></tr>
<tr class="memdesc:a133bc86d0444e81f01bd6cf4796e16cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of mouse's buttonCode. returns 1 if button has been pressed during this update frame otherwise 0 if not just pressed. (buttonCodes are 0 for left, 1 for right, 2 for centre buttons) <br /></td></tr>
<tr class="separator:a133bc86d0444e81f01bd6cf4796e16cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe03c8bf331d21573f09e64bb197f67e"><td class="memItemLeft" align="right" valign="top"><a id="abe03c8bf331d21573f09e64bb197f67e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#abe03c8bf331d21573f09e64bb197f67e">getMouseButtonOnUp</a> (int buttonCode)=0</td></tr>
<tr class="memdesc:abe03c8bf331d21573f09e64bb197f67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks to see if desired MoustButton has been just released ('on up'). (buttonCodes are 0 for left, 1 for right, 2 for center buttons) <br /></td></tr>
<tr class="separator:abe03c8bf331d21573f09e64bb197f67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9dbda70e73dfbb951f63d7d850c6fb"><td class="memItemLeft" align="right" valign="top"><a id="a6b9dbda70e73dfbb951f63d7d850c6fb"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6b9dbda70e73dfbb951f63d7d850c6fb">getMouseButtonDownTime</a> (int buttonCode)=0</td></tr>
<tr class="memdesc:a6b9dbda70e73dfbb951f63d7d850c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mount of time (in seconds) a mouse's button has been pressed. (buttonCodes are 0 for left, 1 for right, 2 for center buttons) <br  />
 <br /></td></tr>
<tr class="separator:a6b9dbda70e73dfbb951f63d7d850c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb595d29b03560dac44f5915c8b373a9"><td class="memItemLeft" align="right" valign="top"><a id="afb595d29b03560dac44f5915c8b373a9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#afb595d29b03560dac44f5915c8b373a9">getMouseDoubleClick</a> (int buttonCode)=0</td></tr>
<tr class="memdesc:afb595d29b03560dac44f5915c8b373a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if particular buttonCode has been clicked twice within the double click threshold. <br /></td></tr>
<tr class="separator:afb595d29b03560dac44f5915c8b373a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac178722b55c26db15115da7f6432c38f"><td class="memItemLeft" align="right" valign="top"><a id="ac178722b55c26db15115da7f6432c38f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac178722b55c26db15115da7f6432c38f">reportMouse</a> (int posX, int posY, bool showCursor=true)=0</td></tr>
<tr class="memdesc:ac178722b55c26db15115da7f6432c38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports mouse input state information onto secondary (touch) screen. <br /></td></tr>
<tr class="separator:ac178722b55c26db15115da7f6432c38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535b66c5228f0b90c1b6f9b23f35cb0c"><td class="memItemLeft" align="right" valign="top"><a id="a535b66c5228f0b90c1b6f9b23f35cb0c"></a>
virtual <a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a535b66c5228f0b90c1b6f9b23f35cb0c">getMouseState</a> ()=0</td></tr>
<tr class="memdesc:a535b66c5228f0b90c1b6f9b23f35cb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal (in) voxie_inputs_t struct. <br /></td></tr>
<tr class="separator:a535b66c5228f0b90c1b6f9b23f35cb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7de3e291b17820de8ffba7e59898a70"><td class="memItemLeft" align="right" valign="top"><a id="aa7de3e291b17820de8ffba7e59898a70"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa7de3e291b17820de8ffba7e59898a70">setMouseState</a> (<a class="el" href="vx_data_types_8h.html#abb63eb12182f49fb7e8375792dd34d76">voxie_inputs_t</a> newMouse)=0</td></tr>
<tr class="memdesc:aa7de3e291b17820de8ffba7e59898a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the internal <a class="el" href="structvoxie__input__t.html" title="Struct to manage mouse inputs. Mouse state is updated when VoxieBox::breath() is called.">voxie_input_t</a> mouse state. <br /></td></tr>
<tr class="separator:aa7de3e291b17820de8ffba7e59898a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1ddebc86b80d60b74cd5613bb1a88c"><td class="memItemLeft" align="right" valign="top"><a id="a8a1ddebc86b80d60b74cd5613bb1a88c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8a1ddebc86b80d60b74cd5613bb1a88c">drawCursor</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, int inputType, int inputID, int col)=0</td></tr>
<tr class="memdesc:a8a1ddebc86b80d60b74cd5613bb1a88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a cursor unto the volumetric display at the position specified. <br  />
 <br /></td></tr>
<tr class="separator:a8a1ddebc86b80d60b74cd5613bb1a88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb98b15f6632fd78d9847d9668e1ec8"><td class="memItemLeft" align="right" valign="top"><a id="a5fb98b15f6632fd78d9847d9668e1ec8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5fb98b15f6632fd78d9847d9668e1ec8">setMouseOrientation</a> (int orientation)=0</td></tr>
<tr class="memdesc:a5fb98b15f6632fd78d9847d9668e1ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the orientation of the users intended position when using the mouse. At what side are they facing towards the volumetric display? <br /></td></tr>
<tr class="separator:a5fb98b15f6632fd78d9847d9668e1ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d967eaa56cf556e4f9b213f98df18b"><td class="memItemLeft" align="right" valign="top"><a id="a01d967eaa56cf556e4f9b213f98df18b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a01d967eaa56cf556e4f9b213f98df18b">getMouseOrientation</a> ()=0</td></tr>
<tr class="memdesc:a01d967eaa56cf556e4f9b213f98df18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation set for the mouse. <br /></td></tr>
<tr class="separator:a01d967eaa56cf556e4f9b213f98df18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c06d2788bd011e5e9787ae1e65ce4b7"><td class="memItemLeft" align="right" valign="top"><a id="a4c06d2788bd011e5e9787ae1e65ce4b7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4c06d2788bd011e5e9787ae1e65ce4b7">AddTouchKeyboardLayout</a> (const <a class="el" href="structtouchkey__t.html">touchkey_t</a> *touchkey, int sizeOfArray)=0</td></tr>
<tr class="memdesc:a4c06d2788bd011e5e9787ae1e65ce4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add custom touch keys. (enable touch keyboard under 'Misc' menu tab) <br /></td></tr>
<tr class="separator:a4c06d2788bd011e5e9787ae1e65ce4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a751ef7630dad8e5811f2b307d7e2bf"><td class="memItemLeft" align="right" valign="top"><a id="a2a751ef7630dad8e5811f2b307d7e2bf"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a2a751ef7630dad8e5811f2b307d7e2bf">touchManualRead</a> (int *touchIndex, int *xVal, int *yVal, int *packetState)=0</td></tr>
<tr class="memdesc:a2a751ef7630dad8e5811f2b307d7e2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read touch inputs - This function should be called in a while loop until 0 is returned. <br /></td></tr>
<tr class="separator:a2a751ef7630dad8e5811f2b307d7e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6707d62b7c43150a7bf6be6b1943899d"><td class="memItemLeft" align="right" valign="top"><a id="a6707d62b7c43150a7bf6be6b1943899d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6707d62b7c43150a7bf6be6b1943899d">setEnableTouchInput</a> (bool option)=0</td></tr>
<tr class="memdesc:a6707d62b7c43150a7bf6be6b1943899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the touch screen to be used as a input device. Set this to true if you want to use the touch screen in your own VX applications. <br /></td></tr>
<tr class="separator:a6707d62b7c43150a7bf6be6b1943899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0a430b03e78bd5d21d77c1b4e1665e"><td class="memItemLeft" align="right" valign="top"><a id="a7c0a430b03e78bd5d21d77c1b4e1665e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7c0a430b03e78bd5d21d77c1b4e1665e">getTouchDeltaX</a> (int index)=0</td></tr>
<tr class="memdesc:a7c0a430b03e78bd5d21d77c1b4e1665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch movement delta of the X position by index register. Use index register -1 for global delta. <br /></td></tr>
<tr class="separator:a7c0a430b03e78bd5d21d77c1b4e1665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f9dd73d1115d608fe8fbc9ae7fe227"><td class="memItemLeft" align="right" valign="top"><a id="a72f9dd73d1115d608fe8fbc9ae7fe227"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a72f9dd73d1115d608fe8fbc9ae7fe227">getTouchDeltaY</a> (int index)=0</td></tr>
<tr class="memdesc:a72f9dd73d1115d608fe8fbc9ae7fe227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch movement delta of the Y position by index register. Use index register -1 for global delta. <br /></td></tr>
<tr class="separator:a72f9dd73d1115d608fe8fbc9ae7fe227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8aa6cf55ced1b753e8f2a2df769ec6"><td class="memItemLeft" align="right" valign="top"><a id="aac8aa6cf55ced1b753e8f2a2df769ec6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aac8aa6cf55ced1b753e8f2a2df769ec6">getTouchPosX</a> (int index)=0</td></tr>
<tr class="memdesc:aac8aa6cf55ced1b753e8f2a2df769ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch X position by index register. Run using a for loop with TOUCH_MAX_INPUT to check all inputs. <br /></td></tr>
<tr class="separator:aac8aa6cf55ced1b753e8f2a2df769ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db64f8621625731166ec557fb9a4953"><td class="memItemLeft" align="right" valign="top"><a id="a0db64f8621625731166ec557fb9a4953"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a0db64f8621625731166ec557fb9a4953">getTouchPosY</a> (int index)=0</td></tr>
<tr class="memdesc:a0db64f8621625731166ec557fb9a4953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch Y position by index register. Run using a for loop with TOUCH_MAX_INPUT to check all inputs. <br /></td></tr>
<tr class="separator:a0db64f8621625731166ec557fb9a4953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ad1e67519846c85ad38d943bd9fa1"><td class="memItemLeft" align="right" valign="top"><a id="a4c4ad1e67519846c85ad38d943bd9fa1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4c4ad1e67519846c85ad38d943bd9fa1">getTouchState</a> (int index)=0</td></tr>
<tr class="memdesc:a4c4ad1e67519846c85ad38d943bd9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch state requires the touch point index number. (0 = no touch, 1 = touch is down, 2 = is held, 3 = just pressed, 4 = on up) <br /></td></tr>
<tr class="separator:a4c4ad1e67519846c85ad38d943bd9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996863fc20ffd0bfcdccb4ed65ef4368"><td class="memItemLeft" align="right" valign="top"><a id="a996863fc20ffd0bfcdccb4ed65ef4368"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a996863fc20ffd0bfcdccb4ed65ef4368">getTouchRotationDelta</a> ()=0</td></tr>
<tr class="memdesc:a996863fc20ffd0bfcdccb4ed65ef4368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in radians the touch rotation delta when a pinch is active range is usually 0.2 and 0.01. <br /></td></tr>
<tr class="separator:a996863fc20ffd0bfcdccb4ed65ef4368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340902ffb45e6303bc3b3e9a30cbf30"><td class="memItemLeft" align="right" valign="top"><a id="aa340902ffb45e6303bc3b3e9a30cbf30"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa340902ffb45e6303bc3b3e9a30cbf30">getTouchDistanceDelta</a> ()=0</td></tr>
<tr class="memdesc:aa340902ffb45e6303bc3b3e9a30cbf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch rotation delta when a pinch is active range is usually 0.2 and 0.01. <br /></td></tr>
<tr class="separator:aa340902ffb45e6303bc3b3e9a30cbf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d3ed2d2797e9ba5378226721a1b260"><td class="memItemLeft" align="right" valign="top"><a id="aa2d3ed2d2797e9ba5378226721a1b260"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa2d3ed2d2797e9ba5378226721a1b260">getTouchPressState</a> (<a class="el" href="structpoint2d.html">point2d</a> TLpos, <a class="el" href="structpoint2d.html">point2d</a> BRpos, bool drawCollision=false)=0</td></tr>
<tr class="memdesc:aa2d3ed2d2797e9ba5378226721a1b260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positive number if a touch event happens within the collision box (0 = no touch, 1 = touch is down, 2 = is held, 3 = just pressed, 4 = on up) <br /></td></tr>
<tr class="separator:aa2d3ed2d2797e9ba5378226721a1b260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6591e3dc281dd04bf48dc05b874efcbc"><td class="memItemLeft" align="right" valign="top"><a id="a6591e3dc281dd04bf48dc05b874efcbc"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6591e3dc281dd04bf48dc05b874efcbc">getTouchPressStateCir</a> (<a class="el" href="structpoint2d.html">point2d</a> CirPos, float radius, bool drawCollision=false)=0</td></tr>
<tr class="memdesc:a6591e3dc281dd04bf48dc05b874efcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a positive number if a touch event happens within the collision circle (0 = no touch, 1 = touch is down, 2 = is held, 3 = just pressed, 4 = on up) <br /></td></tr>
<tr class="separator:a6591e3dc281dd04bf48dc05b874efcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc654768e05df6dd3ea50dc8a758ed"><td class="memItemLeft" align="right" valign="top"><a id="a32bc654768e05df6dd3ea50dc8a758ed"></a>
virtual <a class="el" href="structtouch_input__t.html">touchInput_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a32bc654768e05df6dd3ea50dc8a758ed">getTouchInputStruct</a> ()=0</td></tr>
<tr class="memdesc:a32bc654768e05df6dd3ea50dc8a758ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a the internal <a class="el" href="structtouch_input__t.html" title="touch input struct holds all the touch input data. Used for advanced touchscreen use.">touchInput_t</a> pointer <br  />
 <br /></td></tr>
<tr class="separator:a32bc654768e05df6dd3ea50dc8a758ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae643bac8f6fccd5f9dd7e45914c3e160"><td class="memItemLeft" align="right" valign="top"><a id="ae643bac8f6fccd5f9dd7e45914c3e160"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae643bac8f6fccd5f9dd7e45914c3e160">setTouchInputStruct</a> (<a class="el" href="structtouch_input__t.html">touchInput_t</a> *newTouchInput)=0</td></tr>
<tr class="memdesc:ae643bac8f6fccd5f9dd7e45914c3e160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the internal <a class="el" href="structtouch_input__t.html" title="touch input struct holds all the touch input data. Used for advanced touchscreen use.">touchInput_t</a> struct. <br /></td></tr>
<tr class="separator:ae643bac8f6fccd5f9dd7e45914c3e160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dfa9ed858b86f61688bd200703c737"><td class="memItemLeft" align="right" valign="top"><a id="ac6dfa9ed858b86f61688bd200703c737"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac6dfa9ed858b86f61688bd200703c737">setTouchSensitivity</a> (float newSensitivityValue)=0</td></tr>
<tr class="memdesc:ac6dfa9ed858b86f61688bd200703c737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the touch sensitivity value 1 is default. the higher the value the more sensitive. <br  />
 <br /></td></tr>
<tr class="separator:ac6dfa9ed858b86f61688bd200703c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5858815c98e91633a6057e23809f1814"><td class="memItemLeft" align="right" valign="top"><a id="a5858815c98e91633a6057e23809f1814"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5858815c98e91633a6057e23809f1814">getTouchSensitivity</a> ()=0</td></tr>
<tr class="memdesc:a5858815c98e91633a6057e23809f1814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch sensitivity setting/. <br /></td></tr>
<tr class="separator:a5858815c98e91633a6057e23809f1814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4ebd1f0cb69377ab9215a2d2bb136c"><td class="memItemLeft" align="right" valign="top"><a id="a5c4ebd1f0cb69377ab9215a2d2bb136c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5c4ebd1f0cb69377ab9215a2d2bb136c">enableTouchFocusPinch</a> (bool choice)=0</td></tr>
<tr class="memdesc:a5c4ebd1f0cb69377ab9215a2d2bb136c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables / enables the touches focus pinch. <br /></td></tr>
<tr class="separator:a5c4ebd1f0cb69377ab9215a2d2bb136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153aee77af0b33274ba8d14ea230d81d"><td class="memItemLeft" align="right" valign="top"><a id="a153aee77af0b33274ba8d14ea230d81d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a153aee77af0b33274ba8d14ea230d81d">getTouchPressIndex</a> (<a class="el" href="structpoint2d.html">point2d</a> TLpos, <a class="el" href="structpoint2d.html">point2d</a> BRpos, bool drawCollision=false)=0</td></tr>
<tr class="memdesc:a153aee77af0b33274ba8d14ea230d81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch point index if a touch event happens within the collision box. <br /></td></tr>
<tr class="separator:a153aee77af0b33274ba8d14ea230d81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c95d0c4d0f76236b9f066d74ab0d79"><td class="memItemLeft" align="right" valign="top"><a id="a20c95d0c4d0f76236b9f066d74ab0d79"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a20c95d0c4d0f76236b9f066d74ab0d79">getTouchPressIndexCir</a> (<a class="el" href="structpoint2d.html">point2d</a> CirPos, float radius, bool drawCollision=false)=0</td></tr>
<tr class="memdesc:a20c95d0c4d0f76236b9f066d74ab0d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the touch point index if a touch event happens within the collision circle. <br /></td></tr>
<tr class="separator:a20c95d0c4d0f76236b9f066d74ab0d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bbb5774747ded85c6d04557d962617"><td class="memItemLeft" align="right" valign="top"><a id="a72bbb5774747ded85c6d04557d962617"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a72bbb5774747ded85c6d04557d962617">getTouchCurrentNoPress</a> ()=0</td></tr>
<tr class="memdesc:a72bbb5774747ded85c6d04557d962617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of current touch presses / points. <br /></td></tr>
<tr class="separator:a72bbb5774747ded85c6d04557d962617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c5035292c6a1c324bafd61b86357ee"><td class="memItemLeft" align="right" valign="top"><a id="a20c5035292c6a1c324bafd61b86357ee"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a20c5035292c6a1c324bafd61b86357ee">reportTouch</a> (int posX, int posY)=0</td></tr>
<tr class="memdesc:a20c5035292c6a1c324bafd61b86357ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of the touch input on to the secondary (touch) screen. <br /></td></tr>
<tr class="separator:a20c5035292c6a1c324bafd61b86357ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b44d45ac83f6a0c23957593fb21d5a"><td class="memItemLeft" align="right" valign="top"><a id="a85b44d45ac83f6a0c23957593fb21d5a"></a>
virtual <a class="el" href="structvoxie__xbox__t.html">voxie_xbox_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a85b44d45ac83f6a0c23957593fb21d5a">getJoyStateRaw</a> (int controllerID)=0</td></tr>
<tr class="memdesc:a85b44d45ac83f6a0c23957593fb21d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns theg ame controller's input state as <a class="el" href="structvoxie__xbox__t.html" title="USB game controller input state struct. Used to manage USB game controller input.">voxie_xbox_t</a> structure. Use the controllerID to determine which one (0 = 1st, 1 = 2nd etc...) <br /></td></tr>
<tr class="separator:a85b44d45ac83f6a0c23957593fb21d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee103dd30ee89c8a6c8295e5e26f439d"><td class="memItemLeft" align="right" valign="top"><a id="aee103dd30ee89c8a6c8295e5e26f439d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>updateJoyStateRaw</b> (int controllerID, <a class="el" href="structvoxie__xbox__t.html">voxie_xbox_t</a> *vx)=0</td></tr>
<tr class="separator:aee103dd30ee89c8a6c8295e5e26f439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dae28db8ae89088070d488a28223932"><td class="memItemLeft" align="right" valign="top"><a id="a0dae28db8ae89088070d488a28223932"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a0dae28db8ae89088070d488a28223932">getJoyButtonState</a> (int controllerID)=0</td></tr>
<tr class="memdesc:a0dae28db8ae89088070d488a28223932"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the game controllers button state. See vxInputTypes::JoyButtonCodes for details. <br /></td></tr>
<tr class="separator:a0dae28db8ae89088070d488a28223932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c20675ca3c129f2c337a39bda471096"><td class="memItemLeft" align="right" valign="top"><a id="a1c20675ca3c129f2c337a39bda471096"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1c20675ca3c129f2c337a39bda471096">setJoyVibrate</a> (int controllerID, float leftMotorSpeed, float rightMotorSpeed)=0</td></tr>
<tr class="memdesc:a1c20675ca3c129f2c337a39bda471096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates vibration motors in XBox controller. XInput controllers only. To stop Be sure to call again with leftMotorSpeed=0.f, rightMotorSpeed=0.f! <br /></td></tr>
<tr class="separator:a1c20675ca3c129f2c337a39bda471096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace11059a47d4b20cbfd1f2c3f5b8645"><td class="memItemLeft" align="right" valign="top"><a id="aace11059a47d4b20cbfd1f2c3f5b8645"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aace11059a47d4b20cbfd1f2c3f5b8645">getJoyButtonIsDown</a> (int controllerID, int joyButtonCode)=0</td></tr>
<tr class="memdesc:aace11059a47d4b20cbfd1f2c3f5b8645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is pressed down. See vxInputTypes::JoyButtonCodes for reference on Joy Button Codes <br  />
 <br /></td></tr>
<tr class="separator:aace11059a47d4b20cbfd1f2c3f5b8645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359456e7efec8f353865921ea184e462"><td class="memItemLeft" align="right" valign="top"><a id="a359456e7efec8f353865921ea184e462"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a359456e7efec8f353865921ea184e462">getJoyButtonOnUp</a> (int controllerID, int joyButtonCode)=0</td></tr>
<tr class="memdesc:a359456e7efec8f353865921ea184e462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is just released. See vxInputTypes::JoyButtonCodes for reference on Joy Button Codes. <br /></td></tr>
<tr class="separator:a359456e7efec8f353865921ea184e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fb39a3966bfead3a97600029e149ae"><td class="memItemLeft" align="right" valign="top"><a id="aa8fb39a3966bfead3a97600029e149ae"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa8fb39a3966bfead3a97600029e149ae">getJoyButtonOnDown</a> (int controllerID, int joyButtonCode)=0</td></tr>
<tr class="memdesc:aa8fb39a3966bfead3a97600029e149ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if controller's button is just pressed. See vxInputTypes::JoyButtonCodes for reference on Joy Button Codes. <br /></td></tr>
<tr class="separator:aa8fb39a3966bfead3a97600029e149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23fbc4913986a3d91692e8319cdb812"><td class="memItemLeft" align="right" valign="top"><a id="ab23fbc4913986a3d91692e8319cdb812"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab23fbc4913986a3d91692e8319cdb812">getJoyButtonDownTime</a> (int controllerID, int joyButtonCode)=0</td></tr>
<tr class="memdesc:ab23fbc4913986a3d91692e8319cdb812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value in seconds of how long a controller's button has been held down for. Requires <a class="el" href="class_i_voxie_box.html#a42b42c55a3d07f8c8fa458206c92f6f8" title="Set to true to handle Joy input manually. Disables many of the joy input functions....">setEnableLegacyJoyInput()</a> to be set to false to work. <br  />
 <br /></td></tr>
<tr class="separator:ab23fbc4913986a3d91692e8319cdb812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c2c098f8230ae8c51af959e98662f3"><td class="memItemLeft" align="right" valign="top"><a id="a71c2c098f8230ae8c51af959e98662f3"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a71c2c098f8230ae8c51af959e98662f3">getJoyAnalogAxisValue</a> (int controllerID, int axis)=0</td></tr>
<tr class="memdesc:a71c2c098f8230ae8c51af959e98662f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single analog axis (control stick) from a game controller. Value as an float range between -1 and 1, 0 is centered. <br /></td></tr>
<tr class="separator:a71c2c098f8230ae8c51af959e98662f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad10211c95357357171eafd939e86261"><td class="memItemLeft" align="right" valign="top"><a id="aad10211c95357357171eafd939e86261"></a>
virtual <a class="el" href="structpoint2d.html">point2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aad10211c95357357171eafd939e86261">getJoyAnalogAxisValueP2D</a> (int controllerID, int stick)=0</td></tr>
<tr class="memdesc:aad10211c95357357171eafd939e86261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the analog axis (control stick) from a game controller. Value as an Point2d range between -1 and 1, 0 is centered. <br /></td></tr>
<tr class="separator:aad10211c95357357171eafd939e86261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1be0ad1beaeee84d27aa14a9e38e2d"><td class="memItemLeft" align="right" valign="top"><a id="a8d1be0ad1beaeee84d27aa14a9e38e2d"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8d1be0ad1beaeee84d27aa14a9e38e2d">getJoyTriggerValue</a> (int controllerID, int joyTriggerCode)=0</td></tr>
<tr class="memdesc:a8d1be0ad1beaeee84d27aa14a9e38e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a controllers analog trigger value. 0 = 0% pressed ... 1 = 100% pressed. Presented as a float. <br /></td></tr>
<tr class="separator:a8d1be0ad1beaeee84d27aa14a9e38e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00db5ba27fe1ae9ef43f0eca57759e43"><td class="memItemLeft" align="right" valign="top"><a id="a00db5ba27fe1ae9ef43f0eca57759e43"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a00db5ba27fe1ae9ef43f0eca57759e43">getJoyNum</a> ()=0</td></tr>
<tr class="memdesc:a00db5ba27fe1ae9ef43f0eca57759e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of USB game controllers detected by the system. <br /></td></tr>
<tr class="separator:a00db5ba27fe1ae9ef43f0eca57759e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac358588359fe1dcd9d896e36980266b5"><td class="memItemLeft" align="right" valign="top"><a id="ac358588359fe1dcd9d896e36980266b5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac358588359fe1dcd9d896e36980266b5">reportJoy</a> (int posX, int posY)=0</td></tr>
<tr class="memdesc:ac358588359fe1dcd9d896e36980266b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of the game controllers on to the secondary (touch) screen. <br /></td></tr>
<tr class="separator:ac358588359fe1dcd9d896e36980266b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c4add882094b68075d002f3b2aee"><td class="memItemLeft" align="right" valign="top"><a id="a2012c4add882094b68075d002f3b2aee"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a2012c4add882094b68075d002f3b2aee">setJoyDeadZone</a> (double deadZoneValue)=0</td></tr>
<tr class="memdesc:a2012c4add882094b68075d002f3b2aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal dead zone value for game controllers. (dead zone is the area where not input is detected). Value between 0 and 1. 0 = no deadzone. 1 = all deadzone. default is 0.3;. <br /></td></tr>
<tr class="separator:a2012c4add882094b68075d002f3b2aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd385e5884adea19af87ae61eb02bca5"><td class="memItemLeft" align="right" valign="top"><a id="abd385e5884adea19af87ae61eb02bca5"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#abd385e5884adea19af87ae61eb02bca5">getJoyDeadZone</a> ()=0</td></tr>
<tr class="memdesc:abd385e5884adea19af87ae61eb02bca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal gamepad's dead zone value. <br /></td></tr>
<tr class="separator:abd385e5884adea19af87ae61eb02bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699e96b98e9b9731a072932a67935e21"><td class="memItemLeft" align="right" valign="top"><a id="a699e96b98e9b9731a072932a67935e21"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a699e96b98e9b9731a072932a67935e21">setJoyOrientation</a> (int controllerID, int orientation)=0</td></tr>
<tr class="memdesc:a699e96b98e9b9731a072932a67935e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the orientation of the users intended position when using a game controller. At what side are they facing towards the volumetric display. <br /></td></tr>
<tr class="separator:a699e96b98e9b9731a072932a67935e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407905008c5960fe6d22a6c0d888b3a4"><td class="memItemLeft" align="right" valign="top"><a id="a407905008c5960fe6d22a6c0d888b3a4"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a407905008c5960fe6d22a6c0d888b3a4">getJoyOrientation</a> (int controllerID)=0</td></tr>
<tr class="memdesc:a407905008c5960fe6d22a6c0d888b3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation set for a specific game controller. <br /></td></tr>
<tr class="separator:a407905008c5960fe6d22a6c0d888b3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d88ec18c0bba83481ffeef37a61df01"><td class="memItemLeft" align="right" valign="top"><a id="a8d88ec18c0bba83481ffeef37a61df01"></a>
virtual <a class="el" href="structvoxie__nav__t.html">voxie_nav_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8d88ec18c0bba83481ffeef37a61df01">getNavStateRaw</a> (int spaceNavID)=0</td></tr>
<tr class="memdesc:a8d88ec18c0bba83481ffeef37a61df01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3DConnexion Space Navigator controller state as <a class="el" href="structvoxie__nav__t.html" title="3D SpaceMouse / Space Navigator by 3DConnexion input state struct. Used to manage SpaceNav input">voxie_nav_t</a> structure. Use the SpaceNavID to determine which one (0 = 1st, 1 = 2nd etc...) <br /></td></tr>
<tr class="separator:a8d88ec18c0bba83481ffeef37a61df01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fd43e54abc995155c61ae3d97d0b6d"><td class="memItemLeft" align="right" valign="top"><a id="ac2fd43e54abc995155c61ae3d97d0b6d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac2fd43e54abc995155c61ae3d97d0b6d">updateNavStateRaw</a> (int spaceNavID, <a class="el" href="structvoxie__nav__t.html">voxie_nav_t</a> *nav)=0</td></tr>
<tr class="memdesc:ac2fd43e54abc995155c61ae3d97d0b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies 3DConnexion Space Navigator controller state to <a class="el" href="structvoxie__nav__t.html" title="3D SpaceMouse / Space Navigator by 3DConnexion input state struct. Used to manage SpaceNav input">voxie_nav_t</a> structure. Used to updated SpaceNavs if <a class="el" href="class_i_voxie_box.html#a1cb6a0cee9155fa29d381c8d87a09245" title="Set to true to handle Nav input manually. Disables many of the nav input functions....">setEnableLegacyNavInput()</a> is set to true. <br /></td></tr>
<tr class="separator:ac2fd43e54abc995155c61ae3d97d0b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed1d2471229df9c12fff00905d061"><td class="memItemLeft" align="right" valign="top"><a id="a125ed1d2471229df9c12fff00905d061"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a125ed1d2471229df9c12fff00905d061">getNavNum</a> ()=0</td></tr>
<tr class="memdesc:a125ed1d2471229df9c12fff00905d061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of SpaceNavs detected by the system. Note : SpaceNavs are only detected after first movement. <br /></td></tr>
<tr class="separator:a125ed1d2471229df9c12fff00905d061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce7910f40aedcb67884f2701875ed1"><td class="memItemLeft" align="right" valign="top"><a id="a14ce7910f40aedcb67884f2701875ed1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a14ce7910f40aedcb67884f2701875ed1">reportNav</a> (int posX, int posY, bool showCursor=true)=0</td></tr>
<tr class="memdesc:a14ce7910f40aedcb67884f2701875ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all SpaceNav input state onto the secondary (touch screen) <br /></td></tr>
<tr class="separator:a14ce7910f40aedcb67884f2701875ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd2fd0c75295a600add752d08d0d8e0"><td class="memItemLeft" align="right" valign="top"><a id="a0bd2fd0c75295a600add752d08d0d8e0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNavButtonState</b> (int spaceNavID)=0</td></tr>
<tr class="separator:a0bd2fd0c75295a600add752d08d0d8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad143148746303819c77873e007634a20"><td class="memItemLeft" align="right" valign="top"><a id="ad143148746303819c77873e007634a20"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNavPrevButtonState</b> (int spaceNavID)=0</td></tr>
<tr class="separator:ad143148746303819c77873e007634a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00b9a479453e868fa88cad97656dea4"><td class="memItemLeft" align="right" valign="top"><a id="af00b9a479453e868fa88cad97656dea4"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af00b9a479453e868fa88cad97656dea4">getNavAngleDelta</a> (int spaceNavID)=0</td></tr>
<tr class="memdesc:af00b9a479453e868fa88cad97656dea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Space Nav's angle input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change. <br /></td></tr>
<tr class="separator:af00b9a479453e868fa88cad97656dea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b06116693a75d70327854035bc24a"><td class="memItemLeft" align="right" valign="top"><a id="a2f8b06116693a75d70327854035bc24a"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a2f8b06116693a75d70327854035bc24a">getNavDirectionDelta</a> (int spaceNavID)=0</td></tr>
<tr class="memdesc:a2f8b06116693a75d70327854035bc24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Space Nav's direction input delta as a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a>. Range between -1 and 1. 0 being no change. <br /></td></tr>
<tr class="separator:a2f8b06116693a75d70327854035bc24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242c3a837f6d9f743cbe835cc5f4855c"><td class="memItemLeft" align="right" valign="top"><a id="a242c3a837f6d9f743cbe835cc5f4855c"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a242c3a837f6d9f743cbe835cc5f4855c">getNavPosition</a> (int spaceNavID)=0</td></tr>
<tr class="memdesc:a242c3a837f6d9f743cbe835cc5f4855c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> of the Nav's tracked position. Used primary when the Space Nav is being used as a cursor. <br /></td></tr>
<tr class="separator:a242c3a837f6d9f743cbe835cc5f4855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5377e01ca0b50299b948059cd1d60e05"><td class="memItemLeft" align="right" valign="top"><a id="a5377e01ca0b50299b948059cd1d60e05"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5377e01ca0b50299b948059cd1d60e05">getNavDirectionDeltaAxis</a> (int spaceNavID, int axis)=0</td></tr>
<tr class="memdesc:a5377e01ca0b50299b948059cd1d60e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single axis of a Space Nav's direction delta (range is -1 to 1, 0 is centered). Axis 0 = x, 1 = y, 2 = z. <br /></td></tr>
<tr class="separator:a5377e01ca0b50299b948059cd1d60e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc76b72c845126d74ca445d707f34e"><td class="memItemLeft" align="right" valign="top"><a id="a52bc76b72c845126d74ca445d707f34e"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a52bc76b72c845126d74ca445d707f34e">getNavAngleDeltaAxis</a> (int spaceNavID, int axis)=0</td></tr>
<tr class="memdesc:a52bc76b72c845126d74ca445d707f34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single axis of a spaceNav's angle delta (range is -1 to 1, 0 is centered). Axis 0 = x, 1 = y, 2 = z. <br /></td></tr>
<tr class="separator:a52bc76b72c845126d74ca445d707f34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f40fd3742f104a73bed2b731a4404c"><td class="memItemLeft" align="right" valign="top"><a id="a24f40fd3742f104a73bed2b731a4404c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a24f40fd3742f104a73bed2b731a4404c">getNavButtonIsDown</a> (int spaceNavID, int buttonCode)=0</td></tr>
<tr class="memdesc:a24f40fd3742f104a73bed2b731a4404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button is being pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button. <br /></td></tr>
<tr class="separator:a24f40fd3742f104a73bed2b731a4404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c428114dbf322427441ed16b5a6183f"><td class="memItemLeft" align="right" valign="top"><a id="a7c428114dbf322427441ed16b5a6183f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7c428114dbf322427441ed16b5a6183f">getNavButtonOnUp</a> (int spaceNavID, int buttonCode)=0</td></tr>
<tr class="memdesc:a7c428114dbf322427441ed16b5a6183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button has been just released from being held ('on up'). <br /></td></tr>
<tr class="separator:a7c428114dbf322427441ed16b5a6183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836a02c1bc474bbebd5cb10e14dbcf9"><td class="memItemLeft" align="right" valign="top"><a id="ad836a02c1bc474bbebd5cb10e14dbcf9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad836a02c1bc474bbebd5cb10e14dbcf9">getNavButtonOnDown</a> (int spaceNavID, int buttonCode)=0</td></tr>
<tr class="memdesc:ad836a02c1bc474bbebd5cb10e14dbcf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's button has just been pressed. Button codes are based on vxInputTypes.h::NavButton(). 0 = left button, 1 = right button. <br /></td></tr>
<tr class="separator:ad836a02c1bc474bbebd5cb10e14dbcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c67790f893644186c271e3ada27b2"><td class="memItemLeft" align="right" valign="top"><a id="ad91c67790f893644186c271e3ada27b2"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad91c67790f893644186c271e3ada27b2">getNavButtonDownTime</a> (int spaceNavID, int buttonCode)=0</td></tr>
<tr class="memdesc:ad91c67790f893644186c271e3ada27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in seconds how long a Space Nav's button has been held down, otherwise returns a 0. <br /></td></tr>
<tr class="separator:ad91c67790f893644186c271e3ada27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac422e15001ee6e8a5b5ae76aa7496e75"><td class="memItemLeft" align="right" valign="top"><a id="ac422e15001ee6e8a5b5ae76aa7496e75"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac422e15001ee6e8a5b5ae76aa7496e75">setNavDoubleClickThreshold</a> (double timeThreshold)=0</td></tr>
<tr class="memdesc:ac422e15001ee6e8a5b5ae76aa7496e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the time between Space Nav clicks to register a 'double click' (which triggers a true setting for <a class="el" href="class_i_voxie_box.html#ad69e3a32a4351c8ea6ad50f9b3bf6287" title="Returns 1 if particular Space Nav&#39;s buttonCode has been clicked twice within the double click thresho...">getNavDoubleClick()</a>) <br /></td></tr>
<tr class="separator:ac422e15001ee6e8a5b5ae76aa7496e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fbadb8a776adfd0b03db9fc9f83148"><td class="memItemLeft" align="right" valign="top"><a id="a31fbadb8a776adfd0b03db9fc9f83148"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a31fbadb8a776adfd0b03db9fc9f83148">getNavDoubleClickThreshold</a> ()=0</td></tr>
<tr class="memdesc:a31fbadb8a776adfd0b03db9fc9f83148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal Space Nav double click threshold value. (Used to determine if a 'double click' has been detected) <br /></td></tr>
<tr class="separator:a31fbadb8a776adfd0b03db9fc9f83148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69e3a32a4351c8ea6ad50f9b3bf6287"><td class="memItemLeft" align="right" valign="top"><a id="ad69e3a32a4351c8ea6ad50f9b3bf6287"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad69e3a32a4351c8ea6ad50f9b3bf6287">getNavDoubleClick</a> (int spaceNavID, int buttonCode)=0</td></tr>
<tr class="memdesc:ad69e3a32a4351c8ea6ad50f9b3bf6287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if particular Space Nav's buttonCode has been clicked twice within the double click threshold. <br /></td></tr>
<tr class="separator:ad69e3a32a4351c8ea6ad50f9b3bf6287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6188af660d3a0b20f4b5933e7fd3b04d"><td class="memItemLeft" align="right" valign="top"><a id="a6188af660d3a0b20f4b5933e7fd3b04d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6188af660d3a0b20f4b5933e7fd3b04d">setNavDeadZone</a> (double deadZoneValue)=0</td></tr>
<tr class="memdesc:a6188af660d3a0b20f4b5933e7fd3b04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal deadZone for Space Navigators. <br /></td></tr>
<tr class="separator:a6188af660d3a0b20f4b5933e7fd3b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19452403f70dbf2b559ace0a015d2a51"><td class="memItemLeft" align="right" valign="top"><a id="a19452403f70dbf2b559ace0a015d2a51"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a19452403f70dbf2b559ace0a015d2a51">setNavSensitivity</a> (int spaceNavID, double newAmount)=0</td></tr>
<tr class="memdesc:a19452403f70dbf2b559ace0a015d2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Space Nav's sensitivity. Used to manage the Space Nav being used as a cursor. 0.0025 is default. Higher values increase sensitivity <br  />
 <br /></td></tr>
<tr class="separator:a19452403f70dbf2b559ace0a015d2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bf8b9e96a4c0b2777abf9f4936a257"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a28bf8b9e96a4c0b2777abf9f4936a257">getNavSensitivity</a> (int spaceNavID)=0</td></tr>
<tr class="separator:a28bf8b9e96a4c0b2777abf9f4936a257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d24bcea88df6c2a8df9f42a39abba9"><td class="memItemLeft" align="right" valign="top"><a id="a24d24bcea88df6c2a8df9f42a39abba9"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a24d24bcea88df6c2a8df9f42a39abba9">getNavDeadZone</a> ()=0</td></tr>
<tr class="memdesc:a24d24bcea88df6c2a8df9f42a39abba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the internal dead one value for the Space Navigator <br /></td></tr>
<tr class="separator:a24d24bcea88df6c2a8df9f42a39abba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50e4728e2e2597217859c93b58bd5d5"><td class="memItemLeft" align="right" valign="top"><a id="aa50e4728e2e2597217859c93b58bd5d5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aa50e4728e2e2597217859c93b58bd5d5">setNavOrientation</a> (int spaceNavID, int orientation)=0</td></tr>
<tr class="memdesc:aa50e4728e2e2597217859c93b58bd5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the orientation of the user's intended position when using a Space Nav <br /></td></tr>
<tr class="separator:aa50e4728e2e2597217859c93b58bd5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1253b0f799517c4c88cfc5964f0cca9"><td class="memItemLeft" align="right" valign="top"><a id="ad1253b0f799517c4c88cfc5964f0cca9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ad1253b0f799517c4c88cfc5964f0cca9">getNavOrientation</a> (int spaceNavID)=0</td></tr>
<tr class="memdesc:ad1253b0f799517c4c88cfc5964f0cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the orientation set for a specific Space Nav <br /></td></tr>
<tr class="separator:ad1253b0f799517c4c88cfc5964f0cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4804b893c9ae39a2df451a3dd94477d"><td class="memItemLeft" align="right" valign="top"><a id="ae4804b893c9ae39a2df451a3dd94477d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae4804b893c9ae39a2df451a3dd94477d">menuReset</a> (int(*menu_update)(int id, char *st, double val, int how, void *userdata), void *userdata, char *bgImageFileName)=0</td></tr>
<tr class="memdesc:ae4804b893c9ae39a2df451a3dd94477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function used to reset the voxie menu and set a new custom menu update function (the menu which is on the secondary touch screen) <br /></td></tr>
<tr class="separator:ae4804b893c9ae39a2df451a3dd94477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26d5089fe0eb1422db4df3e66940338"><td class="memItemLeft" align="right" valign="top"><a id="ab26d5089fe0eb1422db4df3e66940338"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab26d5089fe0eb1422db4df3e66940338">menuAddTab</a> (char *st, int x, int y, int xs, int ys)=0</td></tr>
<tr class="memdesc:ab26d5089fe0eb1422db4df3e66940338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom menu tab on secondary (touch) screen menu (NOTE: there's only space for 2 more tabs on the 7" 1024x600 LCD screen) <br /></td></tr>
<tr class="separator:ab26d5089fe0eb1422db4df3e66940338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b1365572a37447494a87fb722aed6"><td class="memItemLeft" align="right" valign="top"><a id="aac9b1365572a37447494a87fb722aed6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aac9b1365572a37447494a87fb722aed6">menuAddItem</a> (char *st, int x, int y, int xSize, int ySize, int id, int type, int state, int col, double startingVal, double minVal, double maxVal1, double minStepVal, double majStepVal)=0</td></tr>
<tr class="memdesc:aac9b1365572a37447494a87fb722aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an item to a menu tab. <br /></td></tr>
<tr class="separator:aac9b1365572a37447494a87fb722aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5075aa133b8e42a69b4c9c3d26af57"><td class="memItemLeft" align="right" valign="top"><a id="a5b5075aa133b8e42a69b4c9c3d26af57"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5b5075aa133b8e42a69b4c9c3d26af57">updateMenu</a> (int id, char *st, int state, double v)=0</td></tr>
<tr class="memdesc:a5b5075aa133b8e42a69b4c9c3d26af57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once the menu is created, use this function to update a string, button status, or slider value. <br /></td></tr>
<tr class="separator:a5b5075aa133b8e42a69b4c9c3d26af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae939bf24c18e16a5db12f00bdefd4434"><td class="memItemLeft" align="right" valign="top"><a id="ae939bf24c18e16a5db12f00bdefd4434"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae939bf24c18e16a5db12f00bdefd4434">playSound</a> (const char *fileName, int sourceChannel, int volumeLeft, int volumeRight, float playBackSpeed)=0</td></tr>
<tr class="memdesc:ae939bf24c18e16a5db12f00bdefd4434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plays a sound (can be WAV, FLAC, MP3, M4A) <br /></td></tr>
<tr class="separator:ae939bf24c18e16a5db12f00bdefd4434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d10e13ce4ce1596eda1ded2b9e3a6d6"><td class="memItemLeft" align="right" valign="top"><a id="a1d10e13ce4ce1596eda1ded2b9e3a6d6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a1d10e13ce4ce1596eda1ded2b9e3a6d6">updateSound</a> (int handleID, int sourceChannel, int volumeLeft, int volumeRight, float playBackSpeed)=0</td></tr>
<tr class="memdesc:a1d10e13ce4ce1596eda1ded2b9e3a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates or adjusts a currently playing sound. Used for muting a current sound or adjusting settings. <br  />
 <br /></td></tr>
<tr class="separator:a1d10e13ce4ce1596eda1ded2b9e3a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae426132df0fb167a56684de9f3b751c3"><td class="memItemLeft" align="right" valign="top"><a id="ae426132df0fb167a56684de9f3b751c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae426132df0fb167a56684de9f3b751c3">updateSoundPosition</a> (int handleID, double second, int seekType=SEEK_SET)=0</td></tr>
<tr class="memdesc:ae426132df0fb167a56684de9f3b751c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates or currently playing sound. to a new position. Seek types are SEEK_SET (0), SEEK_CUR (1) &amp; SEEK_END (2) - values based on fseek() <br  />
 <br /></td></tr>
<tr class="separator:ae426132df0fb167a56684de9f3b751c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b6353856cdbbdda3c3a848eb03f777"><td class="memItemLeft" align="right" valign="top"><a id="ae7b6353856cdbbdda3c3a848eb03f777"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae7b6353856cdbbdda3c3a848eb03f777">setAudioPlayCallBack</a> (void(*userplayfunc)(int *sampleBuffer, int sampleRate))=0</td></tr>
<tr class="memdesc:ae7b6353856cdbbdda3c3a848eb03f777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a custom audio callback function to play PCM raw audio data. <br /></td></tr>
<tr class="separator:ae7b6353856cdbbdda3c3a848eb03f777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0567413353f15205bb6f14b13fe4f9"><td class="memItemLeft" align="right" valign="top"><a id="a7b0567413353f15205bb6f14b13fe4f9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7b0567413353f15205bb6f14b13fe4f9">setAudioRecordCallBack</a> (void(*userrecfunc)(int *sampleBuffer, int sampleRate))=0</td></tr>
<tr class="memdesc:a7b0567413353f15205bb6f14b13fe4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a custom audio callback function to record PCM audio data - see VXBeeper demo (under modules) for a demo on how to use this function. <br /></td></tr>
<tr class="separator:a7b0567413353f15205bb6f14b13fe4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b471b65893b47e859ff60393ba27fa"><td class="memItemLeft" align="right" valign="top"><a id="a40b471b65893b47e859ff60393ba27fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a40b471b65893b47e859ff60393ba27fa">mountZip</a> (char *fileName)=0</td></tr>
<tr class="memdesc:a40b471b65893b47e859ff60393ba27fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and loads a .zip file into memory. <br /></td></tr>
<tr class="separator:a40b471b65893b47e859ff60393ba27fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9587e0673776b7c76fac23724a518110"><td class="memItemLeft" align="right" valign="top"><a id="a9587e0673776b7c76fac23724a518110"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9587e0673776b7c76fac23724a518110">captureVolumeAsPly</a> ()=0</td></tr>
<tr class="memdesc:a9587e0673776b7c76fac23724a518110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PLY file. <br /></td></tr>
<tr class="separator:a9587e0673776b7c76fac23724a518110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc8d74514430fe346055b6bf1a84055"><td class="memItemLeft" align="right" valign="top"><a id="a9bc8d74514430fe346055b6bf1a84055"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9bc8d74514430fe346055b6bf1a84055">captureVolumeAsPng</a> ()=0</td></tr>
<tr class="memdesc:a9bc8d74514430fe346055b6bf1a84055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a screen capture of the volumetric buffer to occur on the next frame. Captured as a PNG file. <br /></td></tr>
<tr class="separator:a9bc8d74514430fe346055b6bf1a84055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d60ee7b816a989268ad51acde83678"><td class="memItemLeft" align="right" valign="top"><a id="ab4d60ee7b816a989268ad51acde83678"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab4d60ee7b816a989268ad51acde83678">captureVolume</a> (const char *filnam, int volcap_mode, int target_vps)=0</td></tr>
<tr class="memdesc:ab4d60ee7b816a989268ad51acde83678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows capture and recording of volumetric screen. a screen capture of the volumetric buffer to occur on the next frame. Captures. <br /></td></tr>
<tr class="separator:ab4d60ee7b816a989268ad51acde83678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15d22afdc95f90b87c9aa9c1e83ba39"><td class="memItemLeft" align="right" valign="top"><a id="ac15d22afdc95f90b87c9aa9c1e83ba39"></a>
virtual __int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac15d22afdc95f90b87c9aa9c1e83ba39">getVxCppVersion</a> ()=0</td></tr>
<tr class="memdesc:ac15d22afdc95f90b87c9aa9c1e83ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a time stamp of the compile date of VxCpp.dll expressed as an __int64. (format: YYYYMMDDHHmmss) <br /></td></tr>
<tr class="separator:ac15d22afdc95f90b87c9aa9c1e83ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac20b2db2c03a6eaef11e623ef03656a"><td class="memItemLeft" align="right" valign="top"><a id="aac20b2db2c03a6eaef11e623ef03656a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aac20b2db2c03a6eaef11e623ef03656a">scrollCol</a> (int offSet=0)=0</td></tr>
<tr class="memdesc:aac20b2db2c03a6eaef11e623ef03656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scrolling color as an RGB hexadecimal value. <br /></td></tr>
<tr class="separator:aac20b2db2c03a6eaef11e623ef03656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09483ceacfeaa1b8145402b66be80b39"><td class="memItemLeft" align="right" valign="top"><a id="a09483ceacfeaa1b8145402b66be80b39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a09483ceacfeaa1b8145402b66be80b39">setColScrollSpeed</a> (double speed)=0</td></tr>
<tr class="memdesc:a09483ceacfeaa1b8145402b66be80b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the speed of the internal color scroller default is 0.1. Value is how long in seconds before a color change. <br /></td></tr>
<tr class="separator:a09483ceacfeaa1b8145402b66be80b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4dc27ae10877c6aaacd55bce7b825e"><td class="memItemLeft" align="right" valign="top"><a id="a9b4dc27ae10877c6aaacd55bce7b825e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9b4dc27ae10877c6aaacd55bce7b825e">clipInsideVolume</a> (<a class="el" href="structpoint3d.html">point3d</a> *pos, float radius=0)=0</td></tr>
<tr class="memdesc:a9b4dc27ae10877c6aaacd55bce7b825e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clips a point to ensures it is within the volumes display's bounds. <br /></td></tr>
<tr class="separator:a9b4dc27ae10877c6aaacd55bce7b825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faf77c9c4badf73f50b91f8c2993b49"><td class="memItemLeft" align="right" valign="top"><a id="a3faf77c9c4badf73f50b91f8c2993b49"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a3faf77c9c4badf73f50b91f8c2993b49">pointSame</a> (<a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b, <a class="el" href="structpoint3d.html">point3d</a> accuracy)=0</td></tr>
<tr class="memdesc:a3faf77c9c4badf73f50b91f8c2993b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy amount specified. <br /></td></tr>
<tr class="separator:a3faf77c9c4badf73f50b91f8c2993b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32db1238b7d6c4be8cc344072072ad58"><td class="memItemLeft" align="right" valign="top"><a id="a32db1238b7d6c4be8cc344072072ad58"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a32db1238b7d6c4be8cc344072072ad58">pointSame</a> (<a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b, <a class="el" href="structpoint2d.html">point2d</a> accuracy)=0</td></tr>
<tr class="memdesc:a32db1238b7d6c4be8cc344072072ad58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> with a degree of accuracy. returns true if the two points are the same within the accuracy amount specified. <br /></td></tr>
<tr class="separator:a32db1238b7d6c4be8cc344072072ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adc7e9b3038b5e2259f2acd39232e98"><td class="memItemLeft" align="right" valign="top"><a id="a0adc7e9b3038b5e2259f2acd39232e98"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a0adc7e9b3038b5e2259f2acd39232e98">colorHexDivide</a> (int color, float divideAmount)=0</td></tr>
<tr class="memdesc:a0adc7e9b3038b5e2259f2acd39232e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a RGB hexadecimal color value by a division number (use this as when using <a class="el" href="class_i_voxie_box.html#a323fe437c563e47f755bd953ce376e01" title="Renders 3D model (.obj, .ply, .stl, .kv6). Displays a filename mesh onto the volumetric display.">drawModel()</a> the color values are a 4th of the range) <br /></td></tr>
<tr class="separator:a0adc7e9b3038b5e2259f2acd39232e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08bd1dd4231ff500b57bd79b5875aef"><td class="memItemLeft" align="right" valign="top"><a id="ae08bd1dd4231ff500b57bd79b5875aef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ae08bd1dd4231ff500b57bd79b5875aef">tweenCol</a> (int color, int speed, int destcolor)=0</td></tr>
<tr class="memdesc:ae08bd1dd4231ff500b57bd79b5875aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tweens a color to the destination color. good for fade outs or tweens. <br /></td></tr>
<tr class="separator:ae08bd1dd4231ff500b57bd79b5875aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e6c12f5c840c5a31e32dc46993f554"><td class="memItemLeft" align="right" valign="top"><a id="a33e6c12f5c840c5a31e32dc46993f554"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>brightenCol</b> (int color, int amount)=0</td></tr>
<tr class="separator:a33e6c12f5c840c5a31e32dc46993f554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade780b443759853c523a9992d9c83bfe"><td class="memItemLeft" align="right" valign="top"><a id="ade780b443759853c523a9992d9c83bfe"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ade780b443759853c523a9992d9c83bfe">randomCol</a> ()=0</td></tr>
<tr class="memdesc:ade780b443759853c523a9992d9c83bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random color based on the RANDOM_COLOR defined in <a class="el" href="vx_data_types_8h.html" title="VX++ data types header contains definitions of all Voxon related structs and types.">vxDataTypes.h</a>. <br /></td></tr>
<tr class="separator:ade780b443759853c523a9992d9c83bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ed5ad8b9a15bd8abae833d10d018dc"><td class="memItemLeft" align="right" valign="top"><a id="a81ed5ad8b9a15bd8abae833d10d018dc"></a>
virtual <a class="el" href="structpoint3d.html">point3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a81ed5ad8b9a15bd8abae833d10d018dc">randomPos</a> ()=0</td></tr>
<tr class="memdesc:a81ed5ad8b9a15bd8abae833d10d018dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random position within the VX display. <br /></td></tr>
<tr class="separator:a81ed5ad8b9a15bd8abae833d10d018dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72d6b411561d8a2f23efb42e8e33687"><td class="memItemLeft" align="right" valign="top"><a id="ab72d6b411561d8a2f23efb42e8e33687"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab72d6b411561d8a2f23efb42e8e33687">sphereCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *sphereAPos, double sphereARadius, <a class="el" href="structpoint3d.html">point3d</a> *sphereBPos, double sphereBRadius, bool showCollisionBox=false)=0</td></tr>
<tr class="memdesc:ab72d6b411561d8a2f23efb42e8e33687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sphere collision check. Check if two spheres are touching. Returns 1 if collision is found otherwise returns 0. <br /></td></tr>
<tr class="separator:ab72d6b411561d8a2f23efb42e8e33687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b52b0cb7031a909535a7ace7e581fa"><td class="memItemLeft" align="right" valign="top"><a id="a84b52b0cb7031a909535a7ace7e581fa"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a84b52b0cb7031a909535a7ace7e581fa">boxInsideCollideChk2D</a> (<a class="el" href="structpoint2d.html">point2d</a> *TLpos, <a class="el" href="structpoint2d.html">point2d</a> *BRpos, <a class="el" href="structpoint2d.html">point2d</a> *collisionPos, bool showCollisionBox=false)=0</td></tr>
<tr class="memdesc:a84b52b0cb7031a909535a7ace7e581fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within box collision check 2D. Checks if a X Y position is within a collision box. two boxes are touching. Returns 1 if collision is found otherwise returns 0. <br /></td></tr>
<tr class="separator:a84b52b0cb7031a909535a7ace7e581fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6770c0826e853800e4b1c218ac29c58f"><td class="memItemLeft" align="right" valign="top"><a id="a6770c0826e853800e4b1c218ac29c58f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a6770c0826e853800e4b1c218ac29c58f">boxCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *LUTpos1, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos1, <a class="el" href="structpoint3d.html">point3d</a> *LUTpos2, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos2, bool showCollisionBox=false)=0</td></tr>
<tr class="memdesc:a6770c0826e853800e4b1c218ac29c58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Box collision check. Check if two boxes are touching. Returns 1 if collision is found otherwise returns 0. <br /></td></tr>
<tr class="separator:a6770c0826e853800e4b1c218ac29c58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687f3274f6f8c7ff2b875ea45b1d136"><td class="memItemLeft" align="right" valign="top"><a id="a7687f3274f6f8c7ff2b875ea45b1d136"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7687f3274f6f8c7ff2b875ea45b1d136">boxInsideCollideChk</a> (<a class="el" href="structpoint3d.html">point3d</a> *LUTpos, <a class="el" href="structpoint3d.html">point3d</a> *RDBpos, <a class="el" href="structpoint3d.html">point3d</a> collisionPos, bool showCollisionBox=false)=0</td></tr>
<tr class="memdesc:a7687f3274f6f8c7ff2b875ea45b1d136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within box collision check. Check if a position is inside a collision box. boxTLU = Top, Left, Up, boxBRD = bottom, right, down. <br /></td></tr>
<tr class="separator:a7687f3274f6f8c7ff2b875ea45b1d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fd4a68dfb0ac2eef4cbebee9a0185c"><td class="memItemLeft" align="right" valign="top"><a id="a20fd4a68dfb0ac2eef4cbebee9a0185c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a20fd4a68dfb0ac2eef4cbebee9a0185c">ciricle2DChk</a> (<a class="el" href="structpoint2d.html">point2d</a> *circlePos, float radius, <a class="el" href="structpoint2d.html">point2d</a> *collisionPos, int showCollisionBox=0)=0</td></tr>
<tr class="memdesc:a20fd4a68dfb0ac2eef4cbebee9a0185c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Within circle collision check. Check if a position is inside a collision circle. <br /></td></tr>
<tr class="separator:a20fd4a68dfb0ac2eef4cbebee9a0185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f429fa4b4869ffec1fe68e0096df0da"><td class="memItemLeft" align="right" valign="top"><a id="a4f429fa4b4869ffec1fe68e0096df0da"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4f429fa4b4869ffec1fe68e0096df0da">moveToPos</a> (<a class="el" href="structpoint3d.html">point3d</a> *currentPos, <a class="el" href="structpoint3d.html">point3d</a> destinationPos, float speed, float accuracy)=0</td></tr>
<tr class="memdesc:a4f429fa4b4869ffec1fe68e0096df0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates/"moves" a point from the current position towards the destination point. Returns 1 if currentPos collides with destinnationPos otherwise returns a 0. <br  />
 <br /></td></tr>
<tr class="separator:a4f429fa4b4869ffec1fe68e0096df0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ec815cdd95d6d4e8dbca3d4504bf7"><td class="memItemLeft" align="right" valign="top"><a id="a9f2ec815cdd95d6d4e8dbca3d4504bf7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a9f2ec815cdd95d6d4e8dbca3d4504bf7">rotVex</a> (float angInRadians, <a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b)=0</td></tr>
<tr class="memdesc:a9f2ec815cdd95d6d4e8dbca3d4504bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> vectors a &amp; b around their common plane, by angle expressed in radians. <br /></td></tr>
<tr class="separator:a9f2ec815cdd95d6d4e8dbca3d4504bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3844039cba0ebb9a402846ff75d0ea44"><td class="memItemLeft" align="right" valign="top"><a id="a3844039cba0ebb9a402846ff75d0ea44"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a3844039cba0ebb9a402846ff75d0ea44">rotVexD</a> (float angInDegrees, <a class="el" href="structpoint3d.html">point3d</a> *a, <a class="el" href="structpoint3d.html">point3d</a> *b)=0</td></tr>
<tr class="memdesc:a3844039cba0ebb9a402846ff75d0ea44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint3d.html" title="3 floats (x, y &amp; z) usually to describe a point in 3D">point3d</a> vectors a &amp; b around their common plane, by angle expressed in degrees. <br /></td></tr>
<tr class="separator:a3844039cba0ebb9a402846ff75d0ea44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a65813a7db65fe864baf6a1c6982c"><td class="memItemLeft" align="right" valign="top"><a id="af39a65813a7db65fe864baf6a1c6982c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#af39a65813a7db65fe864baf6a1c6982c">rotVex</a> (float angInRadians, <a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b)=0</td></tr>
<tr class="memdesc:af39a65813a7db65fe864baf6a1c6982c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> vectors a &amp; b around their common plane, by angle expressed in radians. <br /></td></tr>
<tr class="separator:af39a65813a7db65fe864baf6a1c6982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6db6fb81f0353372b0103ad3db8d42"><td class="memItemLeft" align="right" valign="top"><a id="aef6db6fb81f0353372b0103ad3db8d42"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#aef6db6fb81f0353372b0103ad3db8d42">rotVexD</a> (float angInDegrees, <a class="el" href="structpoint2d.html">point2d</a> *a, <a class="el" href="structpoint2d.html">point2d</a> *b)=0</td></tr>
<tr class="memdesc:aef6db6fb81f0353372b0103ad3db8d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate two <a class="el" href="structpoint2d.html" title="2 floats (x &amp; y) usually to describe a point in 2D">point2d</a> vectors a &amp; b around their common plane, by angle expressed in degrees. <br /></td></tr>
<tr class="separator:aef6db6fb81f0353372b0103ad3db8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68e9524c89c41ac3ada58c15e0bebd5"><td class="memItemLeft" align="right" valign="top"><a id="ac68e9524c89c41ac3ada58c15e0bebd5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac68e9524c89c41ac3ada58c15e0bebd5">_kzaddstack</a> (const char *fileName)=0</td></tr>
<tr class="memdesc:ac68e9524c89c41ac3ada58c15e0bebd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function - global function (these not multi-thread safe!) <br /></td></tr>
<tr class="separator:ac68e9524c89c41ac3ada58c15e0bebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e78b799e3ae44ff3b67417e3e80d2b"><td class="memItemLeft" align="right" valign="top"><a id="a19e78b799e3ae44ff3b67417e3e80d2b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a19e78b799e3ae44ff3b67417e3e80d2b">_kzuninit</a> ()=0</td></tr>
<tr class="memdesc:a19e78b799e3ae44ff3b67417e3e80d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function - global function (these not multi-thread safe!) <br /></td></tr>
<tr class="separator:a19e78b799e3ae44ff3b67417e3e80d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f3b162ccb635a0eb83dcbacf56265c"><td class="memItemLeft" align="right" valign="top"><a id="ac2f3b162ccb635a0eb83dcbacf56265c"></a>
virtual kzfind_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac2f3b162ccb635a0eb83dcbacf56265c">_kzfindfilestart</a> (const char *st)=0</td></tr>
<tr class="memdesc:ac2f3b162ccb635a0eb83dcbacf56265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access. <br /></td></tr>
<tr class="separator:ac2f3b162ccb635a0eb83dcbacf56265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67381ce58613a4b0bc370fc0411b6c9e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a67381ce58613a4b0bc370fc0411b6c9e">_kzfindfile</a> (kzfind_t *find, <a class="el" href="structkzfileinfo__t.html">kzfileinfo_t</a> *fileinfo)=0</td></tr>
<tr class="memdesc:a67381ce58613a4b0bc370fc0411b6c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access.  <a href="class_i_voxie_box.html#a67381ce58613a4b0bc370fc0411b6c9e">More...</a><br /></td></tr>
<tr class="separator:a67381ce58613a4b0bc370fc0411b6c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059258e0dee220e1c1ea504dd13a87aa"><td class="memItemLeft" align="right" valign="top"><a id="a059258e0dee220e1c1ea504dd13a87aa"></a>
virtual kzfile_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a059258e0dee220e1c1ea504dd13a87aa">_kzsetfil</a> (FILE *fileName)=0</td></tr>
<tr class="memdesc:a059258e0dee220e1c1ea504dd13a87aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access. <br /></td></tr>
<tr class="separator:a059258e0dee220e1c1ea504dd13a87aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac251b1200f1e2c559988ac6e57b140c1"><td class="memItemLeft" align="right" valign="top"><a id="ac251b1200f1e2c559988ac6e57b140c1"></a>
virtual kzfile_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac251b1200f1e2c559988ac6e57b140c1">_kzopen</a> (const char *)=0</td></tr>
<tr class="memdesc:ac251b1200f1e2c559988ac6e57b140c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access. <br /></td></tr>
<tr class="separator:ac251b1200f1e2c559988ac6e57b140c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1704f8bd0c013f2b4f99bfd8b645b5"><td class="memItemLeft" align="right" valign="top"><a id="a8e1704f8bd0c013f2b4f99bfd8b645b5"></a>
virtual kzfile_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a8e1704f8bd0c013f2b4f99bfd8b645b5">_kzopen_ext</a> (const char *, const char *, const char *)=0</td></tr>
<tr class="memdesc:a8e1704f8bd0c013f2b4f99bfd8b645b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access. <br /></td></tr>
<tr class="separator:a8e1704f8bd0c013f2b4f99bfd8b645b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf45e4850627f80aa257c94b96f74d39"><td class="memItemLeft" align="right" valign="top"><a id="adf45e4850627f80aa257c94b96f74d39"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#adf45e4850627f80aa257c94b96f74d39">_kzread</a> (kzfile_t *kzfile, void *buffer, unsigned int leng)=0</td></tr>
<tr class="memdesc:adf45e4850627f80aa257c94b96f74d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:adf45e4850627f80aa257c94b96f74d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4407429323c1866c71ff5931f865ab7e"><td class="memItemLeft" align="right" valign="top"><a id="a4407429323c1866c71ff5931f865ab7e"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a4407429323c1866c71ff5931f865ab7e">_kzfilelength</a> (kzfile_t *kzfile)=0</td></tr>
<tr class="memdesc:a4407429323c1866c71ff5931f865ab7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:a4407429323c1866c71ff5931f865ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58795c9909fc919ac3de7c4d754bb0b"><td class="memItemLeft" align="right" valign="top"><a id="ab58795c9909fc919ac3de7c4d754bb0b"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ab58795c9909fc919ac3de7c4d754bb0b">_kztell</a> (kzfile_t *kzfile)=0</td></tr>
<tr class="memdesc:ab58795c9909fc919ac3de7c4d754bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:ab58795c9909fc919ac3de7c4d754bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b72171e7a42a1c0fd587201d19656f"><td class="memItemLeft" align="right" valign="top"><a id="a88b72171e7a42a1c0fd587201d19656f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a88b72171e7a42a1c0fd587201d19656f">_kzseek</a> (kzfile_t *kzfile, int offset, int whence)=0</td></tr>
<tr class="memdesc:a88b72171e7a42a1c0fd587201d19656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:a88b72171e7a42a1c0fd587201d19656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3147a9aa04b6ec5b9cd75e32380c45"><td class="memItemLeft" align="right" valign="top"><a id="a5a3147a9aa04b6ec5b9cd75e32380c45"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a5a3147a9aa04b6ec5b9cd75e32380c45">_kzgetc</a> (kzfile_t *kzfile)=0</td></tr>
<tr class="memdesc:a5a3147a9aa04b6ec5b9cd75e32380c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:a5a3147a9aa04b6ec5b9cd75e32380c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4508ce1b9a68b424c1df85bb4f16f05"><td class="memItemLeft" align="right" valign="top"><a id="ac4508ce1b9a68b424c1df85bb4f16f05"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#ac4508ce1b9a68b424c1df85bb4f16f05">_kzeof</a> (kzfile_t *kzfile)=0</td></tr>
<tr class="memdesc:ac4508ce1b9a68b424c1df85bb4f16f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:ac4508ce1b9a68b424c1df85bb4f16f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1632d20be76efc05602bb27901a21"><td class="memItemLeft" align="right" valign="top"><a id="a51c1632d20be76efc05602bb27901a21"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a51c1632d20be76efc05602bb27901a21">_kzclose</a> (kzfile_t *kzfile)=0</td></tr>
<tr class="memdesc:a51c1632d20be76efc05602bb27901a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access <br /></td></tr>
<tr class="separator:a51c1632d20be76efc05602bb27901a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6ad15ce1aa026195c13ab891ac73b5"><td class="memItemLeft" align="right" valign="top"><a id="a7e6ad15ce1aa026195c13ab891ac73b5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a7e6ad15ce1aa026195c13ab891ac73b5">_kpgetdim</a> (const char *buffer, int nby, int *xsiz, int *ysiz)=0</td></tr>
<tr class="memdesc:a7e6ad15ce1aa026195c13ab891ac73b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal image decoder function. All 'kp...' functions are to do with Ken's picture library (Low-level PNG/JPG decoding functions) <br /></td></tr>
<tr class="separator:a7e6ad15ce1aa026195c13ab891ac73b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357f81218c594928a3332453579186d"><td class="memItemLeft" align="right" valign="top"><a id="a3357f81218c594928a3332453579186d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a3357f81218c594928a3332453579186d">_kprender</a> (const char *buffer, int nby, INT_PTR fptr, int bpl, int xsiz, int ysiz, int xoff, int yoff)=0</td></tr>
<tr class="memdesc:a3357f81218c594928a3332453579186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal image decoder function. All 'kp...' functions are to do with Ken's picture library (Low-level PNG/JPG decoding functions) <br /></td></tr>
<tr class="separator:a3357f81218c594928a3332453579186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631f8725c083e8234869b65b2c831d7f"><td class="memItemLeft" align="right" valign="top"><a id="a631f8725c083e8234869b65b2c831d7f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_voxie_box.html#a631f8725c083e8234869b65b2c831d7f">_kpzload</a> (const char *fileName, INT_PTR *fptr, INT_PTR *bpl, INT_PTR *xsiz, INT_PTR *ysiz)=0</td></tr>
<tr class="memdesc:a631f8725c083e8234869b65b2c831d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">! Internal image decoder function. All 'kp...' functions are to do with Ken's picture library (High-level (easy) picture loading function) <br /></td></tr>
<tr class="separator:a631f8725c083e8234869b65b2c831d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class. </p>
<p>Contains all the methods and attributes needed to encapsulate Voxiebox.dll into its the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class these methods and attributes are abstract and are overwritten by the <a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> class on runtime.</p>
<p>For detailed attributes and methods information see the member information on </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_voxie_box.html" title="VoxieBox class.">VoxieBox</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a67381ce58613a4b0bc370fc0411b6c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67381ce58613a4b0bc370fc0411b6c9e">&#9670;&nbsp;</a></span>_kzfindfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IVoxieBox::_kzfindfile </td>
          <td>(</td>
          <td class="paramtype">kzfind_t *&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkzfileinfo__t.html">kzfileinfo_t</a> *&#160;</td>
          <td class="paramname"><em>fileinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal zip file management function. All 'kz...' functions are to do with Ken's zip file access. </p>
<dl class="section return"><dt>Returns</dt><dd>1:found, 0:~found, NOTE:keep calling until ret 0 else mem leak </dd></dl>

<p>Implemented in <a class="el" href="class_voxie_box.html#a4f3658452833363b42e2185df980c3ff">VoxieBox</a>.</p>

</div>
</div>
<a id="a28bf8b9e96a4c0b2777abf9f4936a257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bf8b9e96a4c0b2777abf9f4936a257">&#9670;&nbsp;</a></span>getNavSensitivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double IVoxieBox::getNavSensitivity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNavID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>returns the current Space Nav internal sensitivity setting </dd></dl>

<p>Implemented in <a class="el" href="class_voxie_box.html#ae07bee3c01da9e338ecace0a62f1e76a">VoxieBox</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="vx_c_p_p_8h_source.html">vxCPP.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
