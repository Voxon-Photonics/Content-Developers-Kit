(C) 2017 VOXON Photonics. All rights Reserved
Voxiebox SDK by Ken Silverman: Runs Voxiebox under Windows 7/8/10 64-bit, with support for emulation in a window.
----------------------------------------------------------------------------------------------------
Overly sparse and very incomplete history:
06/04/2013: Voxiebox SDK first internal release to company.
06/05/2013: Function documentation written.
06/10/2013: Update for Java; structure changes.
07/18/2013: Add voxi_drawheimap(). Add sndfx_aud[] to voxi_wind_t structure.
07/22/2013: Add voxi_playsound().
08/27/2013: Add functions for XBox controller; improve voxi_drawcube(); implement voxi_drawbox();
            add voxi_drawspr().
12/22/2013: Add voxi_setaudmixcb(), voxi_wind_t:samprate, voxi_wind_t:nchans.
01/23/2014: Many changes made for initial semi-public release.
02/19/2014: Rename voxi_* to voxie_* for consistency.
11/26/2017: Updated lots of stuff, including menus, voxie_drawmeshtex(), .REC file playback functions.
02/10/2018: Reorganize voxie_wind_t structure for support of multiple displays.

----------------------------------------------------------------------------------------------------
File description:

Voxiebox DLL files:
   voxiebox.dll           Compiled library
   voxiebox.ini           Settings file loaded by voxiebox.dll
   voxiebox_menu0.ini     Included from voxiebox.ini
   voxiebox.h             Header for C/C++ usage of voxiebox.dll
   voxiebox.txt           This document

Voxiesimp files:
   voxiesimp.exe          Compiled executable (from C# because it's smaller)
   voxiesimp.c            Simple example for C/C++
   voxiesimp.cs           Simple example for C#
   voxiesimp.java         Simple example for Java
   jna.jar                Java DLL support library
   javcomp.bat            Command line Java compile

Voxiedemo files:
   voxiedemo.exe          Compiled example program
   voxiedemo.c            Source code in C/C++
   voxiedemo.txt          Documentation on modes/keys
   voxiedemo.ini          Settings for voxiedemo
   voxiedemo_user.ini     Included from voxiedemo.ini
   voxiedemo_dotmunch.ini Included from voxiedemo.ini
   anim.ini               Saved positions & orientations of models for voxiedemo (VoxieOS uses posori.ini)
   icons.zip              Selection screen models
   canyon.png             Heightmap example
   chessdat.zip           Chess models
   mun_data.zip           Dot munch models
   flystomp.zip           Fly stomp data
   caco.kv6               Ken's silly mascot
   meathead.stl           Ken's silly mascot #2

Voxon's own file formats:
   *.kv6; *.kvs         Ken Silverman's 3D voxel formats (KV6 from Voxlap; KVS for surface voxel octrees)
   *.kni                A movie file containing color images, depth images, infrared images, and audio. Used for depth cameras. See knife.exe/kniview.exe
   *.rec                A recording of a sequence of Voxiebox graphics and audio commands. Can create a REC file in the runtime Voxiebox menu.

Standard file formats supported:
   *.mol                Standard molecule format
   *.stl; *.obj; *.ply  Standard 3D polygon formats
   *.dcm                Standard DICOM (medical) format

   *.png; *.jpg; *.gif  Standard image formats
   *.bmp; *.tga; *.pcx

   *.wav; *.flac        Standard audio formats
   *.mp3; *.m4a; *.wma  Additional audio formats provided by Windows Media (IMFSourceReader) - others supported.


----------------------------------------------------------------------------------------------------
Window setup functions:

typedef struct { float x, y; } point2d; //Used for 2D points
#define MAXDISP 4
typedef struct
{
   point2d keyst[8];           //settings for quadrilateral (keystone) compensation (use voxiedemo mode 2 to calibrate)
   int colo_r, colo_g, colo_b; //initial values at startup for rgb color mode
   int mono_r, mono_g, mono_b; //initial values at startup for mono mode
   int mirrorx, mirrory;       //projector hardware flipping (I suggest avoiding this)
} voxie_disp_t;
typedef struct
{
   int useemu; float emuhang, emuvang, emudist;                                                                        //Emulation
   int xdim, ydim, projrate, framepervol, usecol, dispnum, bitspervol; voxie_disp_t disp[MAXDISP];                     //Display
   int hwsync_frame0, hwsync_phase, hwsync_amp[4], hwsync_pha[4], hwsync_levthresh, voxie_vol;                         //Actuator
   int ilacemode, drawstroke, dither, smear, usekeystone, flip, menu_on_voxie; float aspx, aspy, aspz, gamma, density; //Render
   int sndfx_vol, voxie_aud, excl_audio, sndfx_aud[2], playsamprate, playnchans, recsamprate, recnchans;               //Audio
   int isrecording, hacks, dispcur;                                                                                    //Misc.
   double freq, phase;                                                                                                 //Obsolete

   int thread_override_hack; //0:default thread behavior, 1..n:force n threads for voxie_drawspr()/voxie_drawheimap(); bound to: {1 .. #CPU cores (1 less on hw)}
   int motortyp; //0=DCBrush+A*, 1=CP+FreqIn+A*, 2=BL_Airplane+A*, 3=VSpin1.0+CP+FreqIn, 4=VSpin1.0+BL+A4915, 5=VSpin1.0+BL+WS2408
   int clipshape; //0=rectangle (vw.aspx,vw.aspy), 1=circle (vw.aspr)
   int goalrpm, cpmaxrpm, ianghak, ldotnum, reserved0;
   int upndow; //0=sawtooth, 1=triangle
   int nblades; //0=VX1 (not spinner), 1=/|, 2=/|/|, ..
   int usejoy; //-1=none, 0=joyInfoEx, 1=XInput
   int dimcaps;
   float emugam;
   float asprmin;
   float sync_usb_offset;
   int sensemask[3], outcol[3];
   float aspr, sawtoothrat;
} voxie_wind_t;

voxie_wind_t fields:
   int useemu;             //0=run on Voxiebox hardware
                           //1= emulator: perspective view, looks like authentic hardware
                           //2=simulator: perspective view, using standard rendering for 2D display
                           //3= emulator: orthogonal view, looks like authentic hardware
                           //4= emulator: orthogonal view, looks like authentic hardware (older/slower code)
   float emuhang;          //emulator horizontal angle (radians)
   float emuvang;          //emulator vertical   angle (radians)
   float emudist;          //emulator distance; minimum is 2000.0.

   int xdim, ydim;         //projector dimensions (912,1140)
   int projrate;           //projector rate in Hz {60..107}
   int framepervol;        //# projector frames per volume {1..16}. Ex:framepervol=3 at projrate=60
                           //gives 60/3 = 20Hz volume rate
   int usecol;             //0=mono white, 1=full color time multiplexed,
                           //-1=red, -2=green, -3=yellow, -4=blue, -5=magenta, -6=cyan
   int dispnum;            //number of displays to search for and use (typically 1)
   int bitspervol;         //bit planes per volume; written by DLL (useful for custom volume renderer)
   voxie_disp_t disp[MAXDISP]; //see voxie_disp_t

   int hwsync_frame0;      //first frame offset (-1 to disable sync hw)
   int hwsync_phase;       //high precision phase offset
   int hwsync_amp[4];      //amplitude {0..65536} for each channel
   int hwsync_pha[4];      //phase {0..65536} for each channel
   int hwsync_levthresh;   //threshold ADC value for peak detection {0..1024, but typically in range: 256..512}
   int voxie_vol;          //amplitude scale when using sine wave audio output {0..100}

   int ilacemode;          //interlace mode: 0:default, 6:2/3 color mode;uses outcol[]) {0-7?}
   int drawstroke;         //1=draw on up stroke, 2=draw on down stroke, 3=draw on both up&down
   int dither;             //0=no dither, 1=height dither, 2=time dither, 3=height&time dither
   int smear;              //1+=increase brightness in x-y at post processing (slower render), 0=not
   int usekeystone;        //0=no keystone compensation (for testing only), 1=keystone quadrilateral compensation (default) - see proj[]
   int flip;               //flip coordinate system in voxiebox.dll
   int menu_on_voxie;      //1=display menu on voxiebox view
   float aspx, aspy, aspz; //aspect ratio, loaded from voxiebox.ini, used by application. Values typically around 1.f
   float gamma;            //gamma value for interpolating in voxie_drawspr()/voxie_drawheimap().
   float density;          //scale factor controlling dot density of STL model rendering (default:1.f)

   int sndfx_vol;          //amplitude scale of sound effects {0..100}
   int voxie_aud;          //audio channel index of motor. (Playback devices..Speakers..Configure..Audio Channels)
   int excl_audio;         //1=exclusive audio mode (much faster & more stable sync - recommended!
                           //0=shared audio mode (if audio access to other programs required)
   int sndfx_aud[2];       //audio channel indices of sound effects, [0]=left, [1]=right
   int playsamprate;       //sample rate used by audio driver (written by voxie_init()). 0 is written if no audio channels are enabled in voxiebox.ini.
   int playnchans;         //number of audio channels expected to be rendered by user audio mixer
   int recsamprate;        //recording sample rate - to use, must write before voxie_init()
   int recnchans;          //number of audio channels in recording callback

   int isrecording;        //0=normally, 1 when .REC file recorder is in progress (written by DLL)
   int hacks;              //bit0!=0:exclusive mouse; bit1!=0:disable REC/TCP options under File menu (for Voxieplay)
   int dispcur;            //current display selected in menus {0..dispnum-1}

   double freq;            //starting value in Hz (must be set before first call to voxie_init()); obsolete - not used by current hardware
   double phase;           //phase lock {0.0..1.0} (can be updated on later calls to voxie_init()); obsolete - not used by current hardware

   int thread_override_hack; //0:default thread behavior, 1..n:force n threads for voxie_drawspr()/voxie_drawheimap(); bound to: {1 .. #CPU cores (1 less on hw)}
   int motortyp;           //0=DCBrush+A*, 1=CP+FreqIn+A*, 2=BL_Airplane+A*, 3=VSpin1.0+CP+FreqIn, 4=VSpin1.0+BL+A4915, 5=VSpin1.0+BL+WS2408
   int clipshape;          //0=rectangle (vw.aspx,vw.aspy), 1=circle (vw.aspr). Can be changed at run-time.
   int goalrpm;            //desired rotation rate
   int cpmaxrpm;           //maximum rotation rate for CP.
   int ianghak;            //phase offset for rotation (0-65535)
   int ldotnum;            //Affects brightness. Range:{0..3}, 0=default
   int upndow;             //screen shape: 0=sawtooth, 1=triangle
   int nblades;            //screen shape: 0=VX1 (not spinner), 1=/| or /\, 2=/|/| or /\/\, ..
   int usejoy;             //which Joystick API to use in DLL: -1=none, 0=joyInfoEx, 1=XInput
   int dimcaps;            //Dim top & bottom by sine - up/dn mode only. 0 is default.
   float emugam;           //gamma applied to emulator rendering mode #1. Typical range: 0.25-4.0
   float asprmin;          //minimum radius; typically 0.10
   float sync_usb_offset;  //offset to USB timing (see VoxieBox menu Stats..On:PDF)
   int sensemask[3];       //for multicolor/multiprojector modes: which data goes to projector. Ex (R/B mode): [0]=0xff0000, [1]=0x00ff00
   int outcol[3];          //for multicolor/multiprojector modes: LED color of projector        Ex (R/B mode): [0]=0xff0000, [1]=0x00ff00
   float aspr;             //size of radius; typically 1.41 or sqrt(2) to circumscribe square
   float sawtoothrat;      //for /|/| or /| screens; typically: 0.875, range: ~0.5-1.0

   //Call this before voxie_init() to load the DLL and default settings from voxiebox.ini
void voxie_loadini_int (voxie_wind_t *vw);

   //Retrieve current vw structure being used by DLL (a convenient place to call this is right after voxie_frame_end())
void voxie_getvw (voxie_wind_t *vw);

   //Call this after voxie_loadini_int(). On the first call, this function sets up the window and
   //starts the motor (if applicable). On later calls, you may override some parameters of the
   //vw structure. You may override the default settings in your code. For example:
   //   voxie_loadini_int(&vw); vw.useemu = 1; voxie_init(&vw);
   //..would use emulation regardless of the setting in voxiebox.ini.
int voxie_init (voxie_wind_t *vw);

   //Call this once at the end of your program.
void voxie_uninit_int (void);

   //Returns compile date and time of VOXIEBOX.DLL as a 64-bit int in this format:
   //year*1e10 + month*1e8 + day*1e6 + hour*1e4 + minute*1e2 + second
   //For example, April 8, 2024 at 16:38:44 would be: 20240408163844
 __int64 voxie_getversion (void);

----------------------------------------------------------------------------------------------------
Keyboard & Mouse:

typedef struct
{
      //Mouse button status (0-7). obstat is the bstat from the previous voxie_breath().
      //To detect the instant of click, use: if ((bstat&1) > (obstat&1)) { MessageBeep(0); }
   int bstat, obstat;

      //Delta mouse cursor position relative to the last voxie_breath() call. Not sensitive to
      //window edges. Use this for games.
   int dmousx, dmousy, dmousz;
} voxie_inputs_t;

   //Call this once per frame to update variables in voxie_inputs_t structure.
   //Returns 0 if program is still running or non-zero if program wants to quit.
int voxie_breath (voxie_inputs_t *vi);

   //Call this to tell Voxiebox library you want to quit the application.
   //voxie_breath() will return non-zero on its next call.
void voxie_quitloop (void);

   //Call at any time to return the time in seconds since the program started.
   //Resolution should be accurate to a microsecond or better.
double voxie_klock (void);

   //Returns the status of a key (0=up, 1=down but was up in previous voxie_breath(), 3=down).
   //Input is a keyboard scan code. This function is useful for game controls, such as shifts and
   //arrow keys where multiple keys may be held down simultaneously. Here are some commonly used
   //scancodes:
   //   0xc8:Up       0xd0:Down
   //   0xcb:Left     0xcd:Right
   //   0x2a:L.Shift  0x36:R.Shift
   //   0x1d:L.Ctrl   0x9d:R.Ctrl
   //   0x38:L.Alt    0xb8:R.Alt
   //   0xc9:PageUp   0xd1:PageDn
   //   0xc7:Home     0xcf:End
   //   0x52:'0' on keypad
int voxie_keystat (int scancode);

   //Returns buffered ASCII keyboard input. Useful for typing stuff like your name, for example.
   //You may continue to call this function in a while loop until it returns 0. Returns:
   //   0: buffer is empty
   //nonzero:
   //   bits  7-0: ASCII code ('A'=65,'a'=97,'0'=48,etc..)
   //   bits 15-8: Keyboard Scan Code
   //   bit    16: Left  Shift was down at time of this keypress
   //   bit    17: Right Shift was down at time of this keypress
   //   bit    18: Left  Ctrl  was down at time of this keypress
   //   bit    19: Right Ctrl  was down at time of this keypress
   //   bit    20: Left  Alt   was down at time of this keypress
   //   bit    21: Right Alt   was down at time of this keypress
int voxie_keyread (void);

typedef struct
{
   short but;      //XBox controller buttons (same layout as XInput)
   short lt, rt;   //XBox controller left&right triggers (0..255)
   short tx0, ty0; //XBox controller left  joypad (-32768..32767)
   short tx1, ty1; //XBox controller right joypad (-32768..32767)
   short hat;      //Hat (for supporting DirectInput controllers)
} voxie_xbox_t;

   //Copies XBox controller state to vx structure
   //id: which controller to query (0-3)
   //vx: structure to be filled in by function (if successful)
   //returns: 1=success (safe to check next controller (id+1)), 0=fail
int voxie_xbox_read (int id, voxie_xbox_t *vx);

   //Activates motors in XBox controller. Be sure to call again later with lmot=0.f, rmot=0.f!
   //  id: which controller to set (0-3)
   //lmot: left  motor speed (0.f-1.f, 0.f=off)
   //rmot: right motor speed (0.f-1.f, 0.f=off)
void voxie_xbox_write (int id, float lmot, float rmot);

typedef struct
{
   float dx, dy, dz; //Space Navigator translation
   float ax, ay, az; //Space Navigator rotation
   int but; //Space Navigator button status
} voxie_nav_t;

   //Copies 3DConnexion Space Navigator controller state to nav structure
   //id: which controller to query (ignored for now)
   //nav: structure to be filled in by function (if successful)
   //returns: 1=success (safe to check next controller (id+1)), 0=fail
int voxie_nav_read (int id, voxie_nav_t *nav);
----------------------------------------------------------------------------------------------------
Menus:

enum {MENU_TEXT=0, MENU_LINE, MENU_BUTTON, MENU_HSLIDER=MENU_BUTTON+4, MENU_VSLIDER, MENU_EDIT,
   MENU_EDIT_DO, MENU_TOGGLE, MENU_PICKFILE};

   //Start building menu (call once per menu)
   //menu_update: callback function to handle interaction updates. See example user function below.
   //   userdata: a pointer to a user-defined structure (optional / for convenience only).
   //   bkfilnam: an image file to be used as background (should be 1024x600 for the LCD display)
   //NOTE: call with voxie_menu_reset(0,0); to remove the user menu
void voxie_menu_reset (int (*menu_update)(int id, char *st, double val, int how, void *userdata),
                       void *userdata, char *bkfilnam);

   //Add user menu tab (NOTE: there's only space for 2 more tabs on the 7" 1024x600 LCD screen)
   //   st: name of tab
   //  x,y: top-left corner of tab item area
   //xs,ys: size of tab item area
void voxie_menu_addtab (char *st, int x, int y, int xs, int ys);

   //Add item to menu tab
   //   st: name of text/button/slider
   //  x,y: top-left corner offset relative to tab
   //xs,ys: size of item
   //   id: user-defined low integer (use enum to differentiate easily)
   // type: MENU_TEXT:     text (decoration only)
   //       MENU_LINE:     line (decoration only)
   //       MENU_BUTTON+3: push button (single button)
   //       MENU_BUTTON+1: push button (first in group - auto-depresses others so only 1 on)
   //       MENU_BUTTON  : push button (in middle of group)
   //       MENU_BUTTON+2: push button (last in group - auto-depresses others so only 1 on)
   //       MENU_HSLIDER:  horizontal slider
   //       MENU_VSLIDER:  vertical slider
   //       MENU_EDIT:     edit text box
   //       MENU_EDIT_DO:  edit text box, click next item on 'Enter'
   //       MENU_TOGGLE:   combo box (w/o the drop down). Useful for saving space in dialog.
   //                      Specify multiple strings in 'st' using \r as separator.
   //       MENU_PICKFILE: file selector. Specify type in 2nd string. Ex: "Browse\r*.kv6"
   //  col: color of item (typically 0xffffff)
   //    v: starting value
   //v0,v1: min,max range of values (respectively)
   //vstp0: minor step in values
   //vstp1: major step in values
void voxie_menu_additem (char *st, int x, int y, int xs, int ys, int id, int type, int down,
                         int col, double v, double v0, double v1, double vstp0, double vstp1);

      //Example callback function for menu:
      // id: id of which button was pressed
      // st: current string (for user edit box (MENU_EDIT))
      //  v: new value to set (if a slider)
      //how: tells how button or slider was changed: (0:enter, 1:left/right arrow, 2:click button,
      //                                              3:drag slider, 4:slider arrow)
      //userdata: pointer to user-defined structure (helpful to avoid global variables)
   enum {MENU_SPEED_BUTTON_1,MENU_SPEED_BUTTON_2,MENU_SPEED_BUTTON_3,MENU_SPEED_SLIDER,MENU_FILE};
   static int gspeed = 1;
   static int menu_update (int id, char *st, double v, int how, void *userdata)
   {
      switch(id)
      {
         case MENU_SPEED_BUTTON_1: gspeed = 1; break;
         case MENU_SPEED_BUTTON_2: gspeed = 2; break;
         case MENU_SPEED_BUTTON_3: gspeed = 3; break;
         case MENU_SPEED_SLIDER: gspeed = (int)v; break;
         case MENU_FILE: printf("File:%s\n",st); break; //NOTE:don't use printf in graphical app :P
      }
      return(1);
   }

   //Once the menu is created, use this function to update a string, button status, or slider value
   //in the menu item. It will change the menu items for any id values that match. If st is null,
   //it will be left alone. 'down' is the status of a button (0=up, 1=down), and 'v' is the value
   //for sliders. If a field is not applicable, just pass a 0.
void voxie_menu_updateitem (int id, char *st, int down, double v);
----------------------------------------------------------------------------------------------------
Touch controls:

   //Touch controls:
   //st: string to display. Arrows use special string code: 0xcb,0xcd,0xc8,0xd0 (up,down,left,right respectively) following by null terminator.
   //x0,y0: top-left coord of button rect
   //xs,ys: size of button rect
   //fcol,bcol: foreground/background color (24-bit). Use -1 for transparent background.
   //keycode: keyboard scan code * 256 + ASCII code (0 if N/A). Examples: 'a':0x1d61, Enter:0x1c0d, Up arrow:0xc800, R.Shift:0x3600
   //    Special keycodes for mouse: Mouse:0x0000, LBut:0x0001, RBut:0x0002, MBut:0x0003
   //
   //static const touchkey_t mytouchkey[] =
   //{
   //   "a",    24,348,100,100, 0x405060,      -1, 0x1d61,
   //   "\xc8",156,348,100,100, 0x605040,0x202020, 0xc800,
   //}
typedef struct { char *st; int x0, y0, xs, ys, fcol, bcol, keycode; } touchkey_t;

void voxie_touch_custom (const touchkey_t *touchkey, int num);
----------------------------------------------------------------------------------------------------
Graphics, low level (direct frame access):

#define VOXIEFRAME_FLAGS_BUFFERED 0 //default: buffers voxie gfx commands internally for potential speedup
#define VOXIEFRAME_FLAGS_IMMEDIATE 1 //do not buffer - 'or' this flag when calling voxie rendering functions from multiple threads
typedef struct
{
   INT_PTR f;              //Pointer to top-left-up of current frame to draw
   INT_PTR p;              //Number of bytes per horizontal line (x)
   INT_PTR fp;             //Number of bytes per 24-plane frame (1/3 of screen)
   int x, y;               //Width and height of viewport
   int flags;              //See VOXIEFRAME_FLAGS_* above.
   int drawplanes;         //Number of bit planes used for drawing
   int x0, y0, x1, y1;     //Viewport extents
   float xmul, ymul, zmul; //Transform for medium and high level graphics functions..
   float xadd, yadd, zadd; //Transform is: actual_x = passed_x * xmul + xadd
   tiletype f2d;           //2D debug window (valid between voxie_frame_start() & voxie_frame_end())
} voxie_frame_t;

   //Causes a screen capture of the volumetric buffer to occur on the next frame. Writes to the
   //next available nonexistent numbered file: VOXIE0000.PNG, VOXIE0001.PNG, ..
   // captyp: 1:PNG, 2:PLY
void voxie_doscreencap (int captyp);

   //You may call this any number of times during rendering.
   //x0, y0, z0, x1, y1, z1: 3D coordinates of upper-left-top and lower-right-bottom corners.
   //   For Voxiebox, use: -1.0,-1.0,-0.2,+1.0,+1.0,+0.2 (respectively) for cube aspect.
   //   or: 0.0, 0.0,vw.z0,vw.x1-vw.x0,vw.y1-vw.y0,vw.z1 (respectively) for 1-to-1 pixel access.
void voxie_setview (voxie_frame_t *vf, float x0, float y0, float z0, float x1, float y1, float z1);

   //Call after each voxie_setview() to mask off a plane of a specified thickness. Use for viewing
   //a slice of a scene.
   //x0, y0, z0: A point on the center of the mask plane
   //nx, ny, nz: The normal vector; the magnitude of this vector determines the thickness of the plane.
void voxie_setmaskplane (voxie_frame_t *vf, float x0, float y0, float z0, float nx, float ny, float nz);

   //You must call this once before drawing anything to the voxel buffer. vf will be written by
   //voxie_frame_start(). You may use the vf structure if you wish to do your own low-level drawing.
   //Otherwise, just pass it to the drawing functions as is.
int voxie_frame_start (voxie_frame_t *vf);

   //For advanced users only: flush all graphics commands on internal buffer, causing all graphics commands
   //to actually execute and complete. This might be used if one wanted to do some low level access to the
   //voxel buffer.
void voxie_flush (void);

   //You must call this once after done drawing. The blitter will flip to it when it finishes
   //rendering the current frame.
void voxie_frame_end (void);

   //Set brightness of color components on projector hardware.
   //Range per component: 0:darkest, 255:brightest
   //WARNING:Be careful not to overheat projector!
void voxie_setleds (int id, int r, int g, int b);

   //Advanced utility function for keystone calibration (used by graphcalc and keystone calibration in voxiedemo)
   //  disp: display number: {0..vw.dispnum-1}
   //   dir: direction. 1=forward, -1=inverse
   //   x,y: input point; {-1.f .. +1.f}
   //     z: input plane: {0 .. vw.framepervol*24-1}
   // xo,yo: keystone adjusted output point
void voxie_project (int disp, int dir, float x, float y, int z, float *xo, float *yo);

   //Free filename from VOXIEBOX.DLL internal cache (any filename passed to voxie_drawmeshtex(), voxie_drawheimap(), voxie_drawspr())
   //Pass "*" to remove entire internal cache
void voxie_free (char *filename);

----------------------------------------------------------------------------------------------------
Graphics, medium level (basic primitives):

   //3D point
typedef struct { float x, y, z; } point3d;

   //Used by voxie_drawpol(). 3D point with index to next point on loop (starting at 0)
typedef struct { float x, y, z; int p2; } pol_t;

   //Used by voxie_drawmeshtex(). 3D point with texture coordinate and color (ARGB32).
typedef struct { float x, y, z, u, v; int col; } poltex_t;

   //Draw single voxel at specified location.
   //  fx,fy,fz: location
   //       col: 24-bit color
void voxie_drawvox (voxie_frame_t *vf, float fx, float fy, float fz, int col);
   //NOTE: The intensity of each color component in col is used for dithering, meaning a voxel might
   //not plot if the intensity of the color component is less than 255. This is by design to allow
   //shades. If you want the voxel to always plot, use 255's in each color component.

   //Draw filled rectangle.
   //  x0,y0,z0: top/left/up corner
   //  x1,y1,z1: bot/right/down corner
   //  fillmode: 0:dots, 1:lines, 2:surfaces, 3:solid
   //       col: 24-bit color
void voxie_drawbox (voxie_frame_t *vf, float x0, float y0, float z0, float x1, float y1, float z1,
                    int fillmode, int col);

   //Draw line
   //  x0,y0,z0: 1st point
   //  x1,y1,z1: 2nd point
   //       col: 24-bit color
void voxie_drawlin (voxie_frame_t *vf, float x0, float y0, float z0, float x1, float y1, float z1,
                    int col);

   //Draw filled polygon. Assumes points are in loop order and coplanar. p2 is an index to the
   //next point on the loop. Holes/multiple loops are supported. For example, this would draw a flat
   //rectangle:
   //   pol_t pt[4];
   //   pt[0].x = 0.0; pt[0].y = 0.0; pt[0].z = 0.0; pt[0].p2 = 1;
   //   pt[1].x = 0.5; pt[1].y = 0.0; pt[1].z = 0.0; pt[1].p2 = 2;
   //   pt[2].x = 0.5; pt[2].y = 0.8; pt[2].z = 0.0; pt[2].p2 = 3;
   //   pt[3].x = 0.0; pt[3].y = 0.8; pt[3].z = 0.0; pt[3].p2 = 0;
   //   voxie_drawpol(&vf,pt,4,7);
   //
   //  pt: See description of pol_t structure above.
   //   n: number of vertices
   // col: 24-bit color
void voxie_drawpol (voxie_frame_t *vf, pol_t *pt, int n, int col);

   //Draw multiple dots, lines, polygons, or filled mesh.
   //      //For fillmode 0, mesh and meshn are ignored - pass 0's in their place.
   //   poltex_t vt[4]; int i = 0;
   //   vt[0].x =-0.8; vt[0].y =-0.8; vt[0].z = 0.0; vt[0].col = 0xffffff;
   //   vt[1].x =+0.8; vt[1].y =+0.8; vt[1].z = 0.0; vt[1].col = 0xffffff;
   //   vt[2].x =-0.8; vt[2].y =+0.8; vt[2].z = 0.0; vt[2].col = 0xffffff;
   //   vt[3].x =+0.8; vt[3].y =-0.8; vt[3].z = 0.0; vt[3].col = 0xffffff;
   //   voxie_drawmeshtex(&vf,0,vt,4,0,0,0,0xffffff);
   //
   //      //Example for fillmode 1 (line list): wireframe 'X'
   //   poltex_t vt[4]; int mesh[6]; i = 0;
   //   vt[0].x =-0.8; vt[0].y =-0.8; vt[0].z = 0.0; vt[0].col = 0xffffff;
   //   vt[1].x =+0.8; vt[1].y =+0.8; vt[1].z = 0.0; vt[1].col = 0xffffff;
   //   vt[2].x =-0.8; vt[2].y =+0.8; vt[2].z = 0.0; vt[2].col = 0xffffff;
   //   vt[3].x =+0.8; vt[3].y =-0.8; vt[3].z = 0.0; vt[3].col = 0xffffff;
   //   mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = -3; /*-3 = end line sequence as unconnected loop (-1 & -2 behave similar to fillmode 2 or 3 below)*/
   //   mesh[i++] = 2; mesh[i++] = 3; mesh[i++] = -3;
   //   voxie_drawmeshtex(&vf,0,vt,4,mesh,i,1,0xffffff);
   //
   //      //Example for fillmode 2 (polygon list) or fillmode 3 (solid filled): tetrahedron
   //   poltex_t vt[4]; int mesh[16], i = 0;
   //   vt[0].x =-0.4; vt[0].y =-0.4; vt[0].z =-0.4; vt[0].col = 0xffffff;
   //   vt[1].x =-0.4; vt[1].y =+0.4; vt[1].z =+0.4; vt[1].col = 0xffffff;
   //   vt[2].x =+0.4; vt[2].y =-0.4; vt[2].z =+0.4; vt[2].col = 0xffffff;
   //   vt[3].x =+0.4; vt[3].y =+0.4; vt[3].z =-0.4; vt[3].col = 0xffffff;
   //   mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = 2; mesh[i++] = -1; /*-1 = end of polygonal facet*/
   //   mesh[i++] = 1; mesh[i++] = 0; mesh[i++] = 3; mesh[i++] = -1;
   //   mesh[i++] = 2; mesh[i++] = 1; mesh[i++] = 3; mesh[i++] = -1;
   //   mesh[i++] = 0; mesh[i++] = 2; mesh[i++] = 3; mesh[i++] = -1;
   //   voxie_drawmeshtex(&vf,0,vt,4,mesh,i,2 /*or 3*/,0xffffff);
   //
   //      //Example for fillmode 2 (complex poly w/hole: 2-triangle donut)
   //   poltex_t vt[6]; int mesh[8], i = 0;
   //   vt[0].x =-0.75; vt[0].y =+0.50; vt[0].z = 0.0; vt[0].col = 0xffffff;  //     / \
   //   vt[1].x = 0.00; vt[1].y =-0.75; vt[1].z = 0.0; vt[1].col = 0xffffff;  //    / . \
   //   vt[2].x =+0.75; vt[2].y =+0.50; vt[2].z = 0.0; vt[2].col = 0xffffff;  //   / /_\ \
   //   vt[3].x =-0.25; vt[3].y =+0.25; vt[3].z = 0.0; vt[3].col = 0xffffff;  //  /       \
   //   vt[4].x = 0.00; vt[4].y =-0.25; vt[4].z = 0.0; vt[4].col = 0xffffff;  // /---------\
   //   vt[5].x =+0.25; vt[5].y =+0.25; vt[5].z = 0.0; vt[5].col = 0xffffff;
   //   mesh[i++] = 0; mesh[i++] = 1; mesh[i++] = 2; mesh[i++] = -2; /*-2 = end loop*/
   //   mesh[i++] = 3; mesh[i++] = 4; mesh[i++] = 5; mesh[i++] = -1; /*-1 = end polygonal facet*/
   //   voxie_drawmeshtex(&vf,0,vt,4,mesh,i,2 /*or 3*/,0xffffff);
   //
   //  texnam: texture filename; pointer to tiletype structure if (flags&8); null for no texture
   //          Be sure to fill .u and .v fields of poltex_t when using a texture.
   //      vt: list of vertices
   //     vtn: number of vertices
   //    mesh: list of facets as vertex indices or -1 to end current primitive and start next one
   //          For complex polygons, insert -2 at end of contour (if more loops on same plane).
   //             Use -1 to end plane
   //   meshn: number of entries in mesh array
   //   flags: +0:dots, +1:lines, +2:surfaces, +3:solid, +8:texnam is tiletype * instead of filename
   //     col: 24-bit color
void voxie_drawmeshtex (voxie_frame_t *vf, char *texnam, poltex_t *vt, int vtn, int *mesh, int meshn,
                        int flags, int col);

   //Draw sphere
   //  fx,fy,fz: center location
   //       rad: radius
   //     issol: 0=shell, 1=solid filled
   //       col: 24-bit color
void voxie_drawsph (voxie_frame_t *vf, float fx, float fy, float fz, float rad, int issol, int col);

   //Draw cone with rounded ends (also draws cylinder/sphere)
   //  x0,y0,z0,r0: sphere 0 center&radius
   //  x1,y1,z1,r1: sphere 1 center&radius
   //  fillmode: 0=shell, 1=solid filled
   //       col: 24-bit color
void voxie_drawcone (voxie_frame_t *vf, float x0, float y0, float z0, float r0,
                                        float x1, float y1, float z1, float r1,
                                        int fillmode, int col);

   //Draw sprite (voxel model).
   //      fnam: filename. Cached internally. Currently supported:KV6,STL,OBJ,PLY.
   //                                         May be supported: KVX,KVS
   //         p: position of center of model (pivot)
   //     r,d,f: right, down, forward vectors (respectively)
   //       col: color multiplier. 24-bit color, each 8 bits scales intensity of respective
   //            component. 64=1.0 or no scale. Use 0x404040 for no change; 0x808080 to draw as
   //            double brightness, etc.. (currently ignored)
   //forcescale: for STL files, forces scale factor (for alignment inside ZIP animations) Leave this
   //            0.f typically.
   //fdrawratio: fraction of model to draw (hack for animation)
   //     flags: Bit 0:0=normal, 1:wireframe
   //   returns: 1=found file&valid, 0=bad file
int voxie_drawspr     (voxie_frame_t *vf, const char *fnam, point3d *p, point3d *r, point3d *d,
                       point3d *f, int col);
int voxie_drawspr_ext (voxie_frame_t *vf, const char *fnam, point3d *p, point3d *r, point3d *d,
                       point3d *f, int col, float forcescale, float fdrawratio, int flags);

----------------------------------------------------------------------------------------------------
Graphics, high level:

   //2D array of pixels
   //  f: pointer to top-left pixel
   //  p: pitch - number of bytes per horizontal line (usually x*4 but may be higher or negative)
   //x,y: image dimensions
typedef struct { INT_PTR f, p, x, y; } tiletype;

   //Draw line-based 'skeleton' text. Supports any orientation.
   //   p: top-left-up corner or first character
   //   r: right vector - length is size of single character
   //   d: down vector - length is height of character
   // col: 24-bit color
   //  st: null-terminated ASCII byte string.
void voxie_printalph (voxie_frame_t *vf, point3d *p, point3d *r, point3d *d, int col,
                      const char *st);

   //Draw cube using specified vectors. Parallelepipeds supported - vectors need not be orthogonal.
   //       p: top-left-up corner
   //       r: right vector
   //       d: down vector
   //       f: forward vector
   //fillmode: 0:dots, 1:edges/wireframe, 2:surfaces, 3:solid filled
   //     col: 24-bit color
void voxie_drawcube (voxie_frame_t *vf, point3d *p, point3d *r, point3d *d, point3d *f,
                     int fillmode, int col);

   //Draw heightmap
   //  filnam: filename or pointer to 2d array containing image; heightmap stored alpha channel
   // p/r/d/f: position of top-left corner and orientation (restrictions: r.z = d.z = f.x = f.y = 0)
   //          Also: p.z is height=0, p.z+f.z is height=255
   //colorkey: ARGB 32-bit color to be transparent (supported in nearest mode only)
   //   flags: (1<<0): reserved (height dither now controlled by vw.dither)
   //          (1<<1): 0=nearest filter   , 1=bilinear filter  (recommended)
   //          (1<<2): 0=color dither off , 1=color dither on  (recommended)
   //          (1<<3): 0=filnam is filename string, 1=filnam is tiletype * or pointer to 2d array.
   //          (1<<4): 0=texture clamp    , 1=texture wrap
   //          (1<<5): 0=8-bit height     , 1=mapzen.com terrarium style height
   //returns average height in middle region, range:{0..255}
void voxie_drawheimap (voxie_frame_t *vf, char *filnam,
                       point3d *p, point3d *r, point3d *d, point3d *f,
                       int colorkey, int reserved, int flags)
----------------------------------------------------------------------------------------------------
Graphics, 2D debug functions (draws simple stuff to window background)

NOTE: The top 64 rows are typically occupied by the menu, which means you should use a y of at least
      64 in order for your graphics to be visible. An exception to this is the top-right corner when
      you are running in emulation mode, however please note that this corner would be off screen on
      the small 7" LCD display on the VX1/VX2 hardware (which has a resolution of 1024x600).

   //Draw 6x8 monospace text to window
   // x,y: top-left corner of start position
   //fcol: foreground color (-1 to indicate transparent)
   //bcol: background color (-1 to indicate transparent)
   //  st: ASCII null terminated text string (must be pre-formatted by caller). \n is supported as a
   //      convenience to write multiple lines in a single call.
void voxie_debug_print6x8 (int x, int y, int fcol, int bcol, const char *st);
   //Same as above with printf-style formatting (C/C++ only; a cover-up function in VOXIEBOX.H)
void voxie_debug_print6x8_ (int x, int y, int fcol, int bcol, const char *fmt, ...);

   //Draw single pixel.
   //  x,y: pixel location
   //  col: 24-bit RGB color
void voxie_debug_drawpix (int x, int y, int col);

   //Draw horizontal line:
   //x0,x1: x extents, x0 < x1
   //    y: row
   //  col: 24-bit RGB color
void voxie_debug_drawhlin (int x0, int x1, int y, int col);

   //Draw line
   //x0,y0: 1st point
   //x1,y1: 2nd point
   //  col: 24-bit RGB color
void voxie_debug_drawline (float x0, float y0, float x1, float y1, int col);

   //Draw circle
   //xc,yc: pixel center
   //    r: radius
   //  col: 24-bit RGB color
void voxie_debug_drawcirc (int xc, int yc, int r, int col);

   //Draw filled rectangle
   //x0,y0: top-left corner
   //x1,y1: bot-right corner
   //  col: 24-bit RGB color
void voxie_debug_drawrectfill (int x0, int y0, int x1, int y1, int col);

   //Draw filled circle
   //  x,y: pixel center
   //    r: radius
   //  col: 24-bit RGB color
void voxie_debug_drawcircfill (int x, int y, int r, int col);

----------------------------------------------------------------------------------------------------
Sound:

   //  filnam: filename (WAV or FLAC) of sound to play
   //    chan: which channel of WAV or FLAC to extract
   //volperc0: % of full volume to left  channel {0..100, although may exceed 100}
   //volperc1: % of full volume to right channel {0..100, although may exceed 100}
   //  frqmul: frequency scaling. use 1.0 for default sample rate, 2.0 for 1 octave up, etc..
   //returns:
   //   0..MAX-1 if success. Use this as a handle passed to voxie_playsound_update().
   //   -1 if file not found or other error related to loading.
   //   -2 if none of the MAX audio voice slots were free. New sounds don't play if list is full.
int voxie_playsound (const char *filnam, int chan, int volperc0, int volperc1, float frqmul);

   //Update parameters of a sound while playing. To turn off sound, set volperc0 & volperc1 to 0's.
   //To turn off all sounds, use a handle of -1. Example: voxie_playsound_update(-1,-1,0,0,0.f);
void voxie_playsound_update (int handle, int chan, int volperc0, int volperc1, float frqmul);

   //Register custom audio mixer callback function. If used, this function will be called from a
   //separate thread, every 3ms (for Voxiebox mode), or every 20ms (for emulated mode).
   //Format is set by Voxiebox library. To get sample rate and number of channels, read samprate and
   //nchans from the voxie_wind_t structure after the call to voxie_init(). The sample format is
   //always signed 32-bit integers, with the PCM located in the least significant 24 bits.
void voxie_setaudplaycb (void (*userplayfunc)(int *samps, int nframes));
void voxie_setaudreccb (void (*userrecfunc)(int *samps, int nframes));
----------------------------------------------------------------------------------------------------
.REC file playback:

   //This structure can typically be left alone.
typedef struct
{
   FILE *fil; //Warning: do not use 'fil' from user code - for internal use only.
   double timleft;
   float *frametim;
   int *frameseek, framemal, kztableoffs;
   int playmode, framecur, framenum;
   int currep, animmode/*0=forward, 1=ping-pong, 2=reverse*/;
} voxie_rec_t;

   //Start .REC file playback
   //    vr: user-allocated structure to maintain playback state
   //filnam: .REC filename or IP address/server to connect to
   //  port: port string in decimal as ASCII
   // flags: |1: will write to stdout with a readable dump of the commands
   //        |2: net mode (fnam is TCP IP/server name to join, or null if hosting)
int voxie_rec_open (voxie_rec_t *vr, char *filnam, char *port, int flags);

   //Call once per frame
    //domode:
    //   -1=dump to stdout
    //    0=seek only (no render/sound)
    //    1=render w/no sound
    //    2=render w/sound
int voxie_rec_play (voxie_rec_t *vr, voxie_frame_t *vf, int domode);

   //Close file handle and free buffers
void voxie_rec_close (voxie_rec_t *vr);

----------------------------------------------------------------------------------------------------
These functions are used internally by voxiebox.dll and shared externally mainly to save exe space.
They are used by voxiedemo for various purposes. These functions can be used to load images from the
following image formats:
   JPG, PNG, GIF, PCX, TGA, BMP, DDS, CEL
And they can be used as generic file loading functions for the following archive formats:
   ZIP, TAR, GZ, GRP, and directories.

   NOTE: "filename.tar.gz" is not currently supported due to the requirement of having to load the entire archive in order to achieve random file access.
                           (Yes, it does get better compression due to sharing the dictionary across files - what a shame.)
         "filename.gz.tar" will work fine, but is wasteful due to stupidly large .TAR headers per file.
         If you ever wondered why .ZIP was popular, now you know why ;-)

   //Global functions (these 2 not multithread safe!):
int (__cdecl *kzaddstack)(const char *filnam);
void (__cdecl *kzuninit)(void);

   //Find files
struct kzfind_t; //<-- structure is private / used internally (similar to FILE structure)
kzfind_t *(__cdecl *kzfindfilestart)(const char *st); //pass wildcard string
int       (__cdecl *kzfindfile     )(kzfind_t *find, char *filnam, int filnamby); //returns 1:found, 0:~found, NOTE:keep calling until ret 0 else mem leak ;P

   //File load (similar to fopen(),fread(),etc.., but can also load files inside ZIP/GZ/TAR/GRP)
struct kzfile_t; //<-- structure is private / used internally (similar to FILE structure)
kzfile_t *(__cdecl *kzsetfil)(FILE *fil);
kzfile_t *(__cdecl *kzopen  )(const char *filnam);
unsigned int (__cdecl *kzread      )(kzfile_t *kzfil, void *buffer, unsigned int leng);
unsigned int (__cdecl *kzfilelength)(kzfile_t *kzfil);
unsigned int (__cdecl *kztell      )(kzfile_t *kzfil);
int          (__cdecl *kzseek      )(kzfile_t *kzfil, int offset, int whence);
int          (__cdecl *kzgetc      )(kzfile_t *kzfil);
int          (__cdecl *kzeof       )(kzfile_t *kzfil);
void         (__cdecl *kzclose     )(kzfile_t *kzfil);

   //Lo-level image decoding funcs:
enum { KPLIB_NONE=0, KPLIB_PNG, KPLIB_JPG, KPLIB_GIF, KPLIB_CEL, KPLIB_BMP, KPLIB_PCX, KPLIB_DDS, KPLIB_TGA}; //kpgetdim() returns this
int (__cdecl *kpgetdim) (const char *buf, int nby, int *xsiz, int *ysiz);
int (__cdecl *kprender) (const char *buf, int nby, INT_PTR fptr, int bpl, int xsiz, int ysiz, int xoff, int yoff);

   //Hi-level (easy) image decode (uses kzfile_t internally):
int (__cdecl *kpzload) (const char *filnam, INT_PTR *fptr, INT_PTR *bpl, INT_PTR *xsiz, INT_PTR *ysiz);

----------------------------------------------------------------------------------------------------
Additional utility functions in C header (voxiebox.h), intended for C code only:

   //Loads DLL, prepares function pointers, and calls voxie_init_int() internally,
   //meaning you shouldn't call voxie_init_int() if you use this instead.
int voxie_load (voxie_wind_t *vw);

   //Calls voxie_uninit_int() internally and closes DLL handle. Do not call voxie_uninit_int() if
   //you use this instead. Set mode parameter to 0.
void voxie_uninit (int mode);

   //voxie_printalph() with support for printf-style formatting, i.e.: "val:%d",val);
void voxie_printalph_ (voxie_frame_t *vf, point3d *p, point3d *r, point3d *d, int col,
                       const char *fmt, ...);
----------------------------------------------------------------------------------------------------
